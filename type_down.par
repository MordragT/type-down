%start TypeDown
%title "TypeDown grammar"
%comment "Empty grammar generated by `parol`"
%line_comment "//"
%block_comment "/\*/" "\*/"
%auto_newline_off

%scanner Element {
    %block_comment "/\*/" "\*/"
    %auto_newline_off
    %auto_ws_off
}
%scanner String {
    %auto_newline_off
    %auto_ws_off
}
%scanner Code {
    %auto_newline_off
    %line_comment "//"
    %block_comment "/\*/" "\*/"
}
%scanner Math {}
%scanner Raw {
    %auto_newline_off
}

%%

// scanner for the different modes: raw, markup, math, code
TypeDown
    : { NewLine^ } Block
    ;

Block
    : RawBlock
    | MarkBlock
    | CodeBlock
    | MathBlock
    ;

NewBlock
    : NewLine^ { NewLine^ } Block
    ;

String
    : DoubleQuoteToken^ %push(String) StringContent %pop() DoubleQuoteToken^
    ;

StringContent
    : <String>/[^"]*/
    ;

// MarkUp ------------------------------------------------------
MarkBlock
    : Heading
    | Paragraph
    | List
    | OrderedList
    | Table
    | Blockquote
    | Term
    ;

HeadingSign
    : EquToken { EquToken }
    ;

Heading
    : HeadingSign Line [ NewBlock ]
    ;

Paragraph
    : Line [ NewBlock | Paragraph ]
    ;

// TODO list indentation
List: MinusToken^ Line [ NewBlock | List ]
    ;

OrderedList
    : PlusToken^ Line [ NewBlock | OrderedList ]
    ;

Table
    : PipeToken^ { Elements PipeToken^ } NewLine^ [ NewBlock | Table ]
    ;

BlockquoteSign
    : <INITIAL>/>+/
    ;

Blockquote
    : BlockquoteSign Line [ NewBlock | Blockquote ]
    ;

Term: SlashToken Line [ NewBlock | Term ]
    ;

// ImageSign
//     : <INITIAL>'!'
//     ;
// Image
//     : ImageSign %push(Code) Call %pop(Code)
//     ;
Line: Elements NewLine^
    ;

Elements
    : %push(Element) [ WhiteSpace^ ] Element { WhiteSpace^ Element } %pop()
    ;

// TODO inline math
Element
    : Format
    | Label
    | Reference
    ;

Label
    : LeftAngleToken^ %push(Code) IdentifierToken %pop() RightAngleToken^
    ;

Reference
    : AtToken^ %push(Code) IdentifierToken %pop()
    ;

Emoji
    : ColonDoubleToken^ %push(Code) IdentifierToken { DotToken IdentifierToken } %pop()
      ColonDoubleToken^
    ;

Format
    : TextToken
    | Emoji
    | Monospace
    | Italic
    | Bold
    | Strikethrough
    | Subscript
    | Supscript
    | SingleQuote
    | DoubleQuote
    ;

Format01
    : TextToken
    | Emoji
    | Monospace
    | Italic
    | Bold
    | Strikethrough
    | Subscript
    | Supscript
    | SingleQuote
    ;

Format02
    : TextToken
    | Emoji
    | Monospace
    | Italic
    | Bold
    | Strikethrough
    | Subscript
    | Supscript
    ;

Format03
    : TextToken
    | Emoji
    | Monospace
    | Italic
    | Bold
    | Strikethrough
    ;

Format04
    : TextToken
    | Emoji
    | Monospace
    | Italic
    | Bold
    ;

Format05
    : TextToken
    | Emoji
    | Monospace
    | Italic
    ;

Format06
    : TextToken
    | Emoji
    | Monospace
    ;

Format07
    : TextToken
    | Emoji
    ;

DoubleQuote
    : DoubleQuoteToken^ { Format01 } DoubleQuoteToken^
    ;

SingleQuote
    : SingleQuoteToken^ { Format02 } SingleQuoteToken^
    ;

Subscript
    : UnderscoreDoubleToken^ { Format03 } UnderscoreDoubleToken^
    ;

Supscript
    : CaretToken^ { Format03 } CaretToken^
    ;

Strikethrough
    : TildeToken^ { Format04 } TildeToken^
    ;

Bold: AsteriskToken^ { Format05 } AsteriskToken^
    ;

Italic
    : UnderscoreToken^ { Format06 } UnderscoreToken^
    ;

Monospace
    : BacktickToken^ { Format07 } BacktickToken^
    ;

// Raw ------------------------------------------------------
RawBlock
    : BacktickTripleToken^ [ TextToken ] NewLine^ %push(Raw) RawText %pop() BacktickTripleToken^
      NewLine^ [ NewBlock ]
    ;

RawText
    : <Raw>/([^`]|\n)+/
    ;

// TODO add newlines everywhere
// Code ------------------------------------------------------
CodeBlock
    : HashToken^ %push(Code) Expr NewLine^ %pop() [ NewBlock ]
    ;

Expr: Let
    | Makro
    | ControlExpr
    | ValueExpr
    | ListExpr
    ;

ListExpr
    : LeftBraceToken^ NewLine^ Expr NewLine^ { Expr NewLine^ } RightBraceToken^
    ;

ControlExpr
    : IfElse
    | For
    ;

ValueExpr
    : Disjunction
    | Content
    ;

Let : KwLet^ IdentifierToken EquToken^ Expr
    ;

IdentList
    : IdentifierToken { CommaToken^ IdentifierToken }
    ;

Makro
    : KwMakro^ IdentifierToken LeftParenToken^ [ IdentList ] RightParenToken^ EquToken^ Expr
    ;

Content
    : LeftBracketToken^ ContentTail
    ;

ContentTail
    : %push(INITIAL) ( NewLine^ Block | Elements ) %pop() RightBracketToken^
    ;

// TODO maybe not ExprList but StmtList ?
IfElse
    : KwIf Disjunction ( ListExpr | Content ) KwElse ( ListExpr | Content | IfElse )
    ;

// Collection implemented as function call
// as functions have named and unnamed function parameters
// dict function only takes named function calls
// and array function only takes unnammed function calls of the same type
Iterable
    : Access
    | String
    | DigitsToken
    ;

For : KwFor^ IdentifierToken KwIn^ Iterable ( ListExpr | Content )
    ;

Disjunction
    : Conjunction { PipeDoubleToken Conjunction }
    ;

Conjunction
    : Negation { AmperDoubleToken Negation }
    ;

Negation
    : [ ExclamToken ] Relation
    ;

Relation
    : Summation
      [ ( EquDoubleToken | ExclamEquToken | LeftAngleToken | LeftAngleEquToken | RightAngleToken | RightAngleEquToken ) Summation ]
    ;

Summation
    : Multiplication { ( PlusToken | MinusToken ) Multiplication }
    ;

Multiplication
    : Factor { ( SlashToken | AsteriskToken | PercentToken ) Factor }
    ;

// la minustoken in summation
Factor //: [ MinusToken ] Primary

    : Primary
    ;

Primary
    : ( LeftParenToken Disjunction RightParenToken )
    | Value
    ;

Value
    : Access
    | String
    | Number
    | Bool
    ;

Arg : IdentifierToken [ ( ColonToken Value ) | Call ]
    | String
    | Number
    | Bool
    ;

Args: Arg { CommaToken^ Arg }
    ;

Access
    : IdentifierToken [ Call ]
    ;

Call: LeftParenToken^ [ Args ] ( RightParenToken^ | RightParenLeftBracketToken^ ContentTail )
    ;

KwMakro
    : <Code>'makro'
    ;

KwFor
    : <Code>'for'
    ;

KwIn: <Code>'in'
    ;

KwIf: <Code>'if'
    ;

KwElse
    : <Code>'else'
    ;

KwLet
    : <Code>'let'
    ;

KwTrue
    : <Code>'true'
    ;

KwFalse
    : <Code>'false'
    ;

Bool: KwTrue
    | KwFalse
    ;

Number
    : DigitsToken [ DotToken DigitsToken ]
    ;

// Math ------------------------------------------------------
MathBlock
    : SigilToken %push(Math) Formular %pop() SigilToken [ NewBlock ]
    ;

Formular
    : Symbol
    ;

// TODO Numbers, integral, infinity, nothing(empty set)
Symbol
    : Greek
    | Variable
    | DoubleStruck
    | Operation //| StringToken
    ;

Alpha
    : <Math>'Alpha'
    | <Math>'alpha'
    ;

Beta: <Math>'Beta'
    | <Math>'beta'
    ;

Gamma
    : <Math>'Gamma'
    | <Math>'gamma'
    ;

Delta
    : <Math>'Delta'
    | <Math>'delta'
    ;

Epsilon
    : <Math>'Epsilon'
    | <Math>'epsilon'
    ;

Zeta: <Math>'Zeta'
    | <Math>'zeta'
    ;

Eta : <Math>'Eta'
    | <Math>'eta'
    ;

Theta
    : <Math>'Theta'
    | <Math>'theta'
    ;

Iota: <Math>'Iota'
    | <Math>'iota'
    ;

Kappa
    : <Math>'Kappa'
    | <Math>'kappa'
    ;

Lambda
    : <Math>'Lambda'
    | <Math>'lambda'
    ;

Mu  : <Math>'Mu'
    | <Math>'mu'
    ;

Nu  : <Math>'Nu'
    | <Math>'nu'
    ;

Xi  : <Math>'Xi'
    | <Math>'xi'
    ;

Omicron
    : <Math>'Omicron'
    | <Math>'omicron'
    ;

Pi  : <Math>'Pi'
    | <Math>'pi'
    | <Math>'product'
    ;

Rho : <Math>'Rho'
    | <Math>'rho'
    ;

Sigma
    : <Math>'Sigma'
    | <Math>'sigma'
    | <Math>'sum'
    ;

Tau : <Math>'Tau'
    | <Math>'tau'
    ;

Upsilon
    : <Math>'Upsilon'
    | <Math>'upsilon'
    ;

Phi : <Math>'Phi'
    | <Math>'phi'
    ;

Chi : <Math>'Chi'
    | <Math>'chi'
    ;

Psi : <Math>'Psi'
    | <Math>'psi'
    ;

Omega
    : <Math>'Omega'
    | <Math>'omega'
    ;

Greek
    : Alpha
    | Beta
    | Gamma
    | Delta
    | Epsilon
    | Zeta
    | Eta
    | Theta
    | Iota
    | Kappa
    | Lambda
    | Mu
    | Nu
    | Xi
    | Omicron
    | Pi
    | Rho
    | Sigma
    | Tau
    | Upsilon
    | Phi
    | Chi
    | Psi
    | Omega
    ;

DoubleStruck
    : <Math>'AA'
    | <Math>'BB'
    | <Math>'CC'
    | <Math>'DD'
    | <Math>'EE'
    | <Math>'FF'
    | <Math>'GG'
    | <Math>'HH'
    | <Math>'II'
    | <Math>'JJ'
    | <Math>'KK'
    | <Math>'LL'
    | <Math>'MM'
    | <Math>'NN'
    | <Math>'OO'
    | <Math>'PP'
    | <Math>'QQ'
    | <Math>'RR'
    | <Math>'SS'
    | <Math>'TT'
    | <Math>'UU'
    | <Math>'VV'
    | <Math>'WW'
    | <Math>'XX'
    | <Math>'YY'
    | <Math>'ZZ'
    ;

Not : <Math>'not'
    ;

And : <Math>'and'
    ;

Or  : <Math>'or'
    ;

ForAll
    : <Math>'forall'
    ;

Exists
    : <Math>'exists'
    ;

Left: <Math>'left'
    ;

Right
    : <Math>'right'
    ;

Top : <Math>'top'
    ;

Bot : <Math>'bot'
    ;

Tack: <Math>'tack' [ DotToken ( Left | Right | Top | Bot ) ]
    ;

Logical
    : And
    | Or
    | Not
    | ForAll
    | Exists
    | Tack
    ;

Equal
    : <Math>'eq' [ DotToken Not ]
    ;

Identical
    : <Math>'ident' [ DotToken Not ]
    ;

Approx
    : <Math>'approx' [ DotToken Not ]
    ;

Prop: <Math>'prop'
    ;

Less: <Math>'le' [ DotToken Equal ]
    ;

Greater
    : <Math>'ge' [ DotToken Equal ]
    ;

In  : <Math>'in' [ DotToken Not ]
    ;

Subset
    : <Math>'subset' [ DotToken ( Not | Equal ) ]
    ;

Supset
    : <Math>'supset' [ DotToken ( Not | Equal ) ]
    ;

Relation
    : Equal
    | Identical
    | Approx
    | Prop
    | Less
    | Greater
    | In
    | Subset
    | Supset
    ;

Variable
    : <Math>/[a-zA-Z]/
    ;

Attach
    : UnderscoreToken
    | CaretToken
    ;

Plus: <Math>'plus'
    | PlusToken
    ;

Minus
    : <Math>'minus'
    | MinusToken
    ;

Frac: <Math>'frac'
    | SlashToken
    ;

Times
    : <Math>'times'
    | AsteriskToken
    ;

Operation
    : Logical
    | Relation
    | Attach
    | Plus
    | Minus
    | Frac
    | Times
    ;

// Group
//     : BracketLeft Formular BracketRight
//     ;
// Tokens ------------------------------------------------------
EquDoubleToken
    : <Code>'=='
    ;

EquToken
    : <INITIAL, Code>'='
    ;

PlusToken
    : <INITIAL, Code, Math>'+'
    ;

MinusToken
    : <INITIAL, Code, Math>'-'
    ;

SlashToken
    : <INITIAL, Code, Math>'/'
    ;

AsteriskToken
    : <Element, Code, Math>'*'
    ;

PercentToken
    : <Code>'%'
    ;

PipeDoubleToken
    : <Code>'||'
    ;

PipeToken
    : <INITIAL>'|'
    ;

UnderscoreDoubleToken
    : <Element>'__'
    ;

UnderscoreToken
    : <Element, Math>'_'
    ;

CaretToken
    : <Element, Math>'^'
    ;

BacktickTripleToken
    : <INITIAL>'```'
    ;

BacktickToken
    : <Element>'`'
    ;

TildeToken
    : <Element>'~'
    ;

HashToken
    : <INITIAL>'#'
    ;

SigilToken
    : <INITIAL>'$'
    ;

AtToken
    : <Element>'@'
    ;

CommaToken
    : <Code>','
    ;

// SemiColonToken
//     : ';'
//     ;
DotToken
    : <Code, Math>'.'
    ;

ColonDoubleToken
    : <Element>'::'
    ;

ColonToken
    : <Code>':'
    ;

LeftParenToken
    : <Code, Math>'('
    ;

RightParenLeftBracketToken
    : <Code>')['
    ;

RightParenToken
    : <Code, Math>')'
    ;

LeftBraceToken
    : <Code>'{'
    ;

RightBraceToken
    : <Code>'}'
    ;

LeftBracketToken
    : <Code>'['
    ;

RightBracketToken
    : <Code, Element>']'
    ;

LeftAngleEquToken
    : <Code>'<='
    ;

LeftAngleToken
    : <Element>'<'
    ;

RightAngleEquToken
    : <Code>'>='
    ;

RightAngleToken
    : <Element>'>'
    ;

ExclamEquToken
    : <Code>'!='
    ;

ExclamToken
    : <Code>'!'
    ;

AmperDoubleToken
    : <Code>'&&'
    ;

DigitsToken
    : <Code>/[0-9]+/
    ;

IdentifierToken
    : <Code>/[a-zA-Z_][0-9a-zA-Z_]*/
    ;

// EmojiIdentifierToken
//     : <INITIAL>/[a-zA-Z_][0-9a-zA-Z_\.]*/
//     ;
WhiteSpace
    : <Element>/[ \t]+/
    ;

NewLine
    : <INITIAL, Element, Code>/\n/
    ;

TextToken
    : <INITIAL, Element>/[A-Za-z0-9\.\&\=\+\-\(\)\:]+/
    ;

SingleQuoteToken
    : <Element>/\'/
    ;

DoubleQuoteToken
    : <Element, Code>/\"/
    ;
