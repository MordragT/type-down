%start TypeDown
%title "TypeDown grammar"
%comment "Empty grammar generated by `parol`"
%line_comment "//"
%block_comment "/\*/" "\*/"
%auto_newline_off

%scanner Code {
    %line_comment "//"
    %block_comment "/\*/" "\*/"
}
%scanner Math {}
%scanner Raw {
    %auto_newline_off
}

%%

// scanner for the different modes: raw, markup, math, code
TypeDown
    : { NewLine } Block
    ;

Block
    : Markup
    | RawMode
    | CodeMode
    | MathMode
    ;

// MarkUp ------------------------------------------------------
Markup
    : Heading
    | Paragraph
    | List
    | OrderedList
    ;

Heading
    : HeadingSign TextLine NewBlock
    ;

HeadingSign
    : <INITIAL>/=+/
    ;

Paragraph
    : TextLine [ NewBlock | ( NewLine Paragraph ) ]
    ;

List: ListSign TextLine [ NewBlock | ( NewLine List ) ]
    ;

ListSign
    : <INITIAL>'-'
    ;

OrderedList
    : OrderedListSign TextLine [ NewBlock | ( NewLine OrderedList ) ]
    ;

OrderedListSign
    : <INITIAL>'+'
    ;

TextLine
    : <INITIAL>/.+/
    ;

NewBlock
    : <INITIAL>/\n\n+/ Block
    ;

NewLine
    : <INITIAL>/\n/
    ;

// Raw ------------------------------------------------------
RawMode
    : '```' %push(Raw) [ Language ] RawText %pop() '```' [ NewBlock ]
    ;

Language
    : <Raw>"[a-zA-Z]+"
    ;

RawText
    : <Raw>/(.|\n)*/
    ;

// Code ------------------------------------------------------
CodeMode
    : <INITIAL>'#' %push(Code) ( Stmt | Expr | CodeList ) %pop() [ NewBlock ]
    ;

CurlyLeft
    : <Code>'{'
    ;

CurlyRight
    : <Code>'}'
    ;

BracketLeft
    : <Code>'('
    ;

BracketRight
    : <Code>')'
    ;

SquareLeft
    : <Code>'['
    ;

SquareRight
    : <Code>']'
    ;

Comma
    : <Code>','
    ;

Colon
    : <Code>':'
    ;

Assign
    : <Code>'='
    ;

KwMakro
    : <Code>'makro'
    ;

KwFor
    : <Code>'for'
    ;

KwIn: <Code>'in'
    ;

KwIf: <Code>'if'
    ;

KwElse
    : <Code>'else'
    ;

KwLet
    : <Code>'let'
    ;

Ident
    : <Code>"[a-zA-Z_]\w*"
    ;

String
    : <Code>/\u{0022}[^\u{0022}]*\u{0022}|'[^']*'/
    ;

Integer
    : <Code>/[0-9][0-9]*|[0-9][0-9A-F]*H/
    ;

Real: <Code>/[0-9][0-9]*\.[0-9]*(ED[+-]?[0-9][0-9]*)?/
    ;

StmtList
    : CurlyLeft { Stmt }
    ;

CodeList
    : StmtList [ Expr ] CurlyRight
    ;

Stmt: Let
    | Makro
    ;

Expr: Call
    | ContentMode
    | IfElse
    | For
    | Ident
    | String
    | Integer
    | Real
    ;

ExprList
    : StmtList Expr CurlyRight
    ;

Collection
    : BracketLeft ( KeyValueList | ValueList ) BracketRight
    ;

KeyValue
    : Ident Colon Value
    ;

KeyValueList
    : KeyValue { Comma KeyValue }
    ;

Value
    : Ident
    | Collection
    | String
    | Integer
    | Real
    | Call
    ;

ValueList
    : Value { Comma Value }
    ;

IdentList
    : Ident { Comma Ident }
    ;

Makro
    : KwMakro Ident BracketLeft [ IdentList ] BracketRight Assign ( Expr | ExprList )
    ;

For : KwFor Ident KwIn ( Ident | Collection | String | Call ) ExprList
    ;

IfElse
    : KwIf Todo ExprList KwElse ( ExprList | IfElse )
    ;

Let : KwLet Ident Assign ( Expr | ExprList )
    ;

ContentMode
    : SquareLeft %push(INITIAL) Block %pop() SquareRight
    ;

Call: Ident BracketLeft [ KeyValueList ] BracketRight //[ ContentMode ]
    ;

Todo: <Code>/\w+/
    ;

// MarkUp ------------------------------------------------------
Sigil
    : <Math>'$'
    ;

// Symbol
//     : <Math>'epsilon'
//     | <Math>'Epsilon'
//     | <Math>'x'
//     | <Math>'y'
//     ;
// MathOp
//     : <Math>'+'
//     | <Math>'-'
//     ;
MathMode
    : Sigil %push(Math) /\w+/ %pop() Sigil [ NewBlock ]
    ;
