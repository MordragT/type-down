%start TypeDown
%title "TypeDown grammar"
%comment "Empty grammar generated by `parol`"
%line_comment "//"
%block_comment "/\*/" "\*/"
%auto_newline_off

%scanner Code {
    %line_comment "//"
    %block_comment "/\*/" "\*/"
}
%scanner Math {}
%scanner Raw {
    %auto_newline_off
}

%%

// scanner for the different modes: raw, markup, math, code
TypeDown
    : { NewLine } Block
    ;

Block
    : Markup
    | RawMode
    | CodeMode
    | MathMode
    ;

// MarkUp ------------------------------------------------------
Markup
    : Heading
    | Paragraph
    | List
    | OrderedList
    ;

Heading
    : HeadingSign TextLine NewBlock
    ;

HeadingSign
    : <INITIAL>/=+/
    ;

Paragraph
    : TextLine [ NewBlock | ( NewLine Paragraph ) ]
    ;

List: ListSign TextLine [ NewBlock | ( NewLine List ) ]
    ;

ListSign
    : <INITIAL>'-'
    ;

OrderedList
    : OrderedListSign TextLine [ NewBlock | ( NewLine OrderedList ) ]
    ;

OrderedListSign
    : <INITIAL>'+'
    ;

TextLine
    : <INITIAL>/.+/
    ;

NewBlock
    : <INITIAL>/\n\n+/ Block
    ;

NewLine
    : <INITIAL>/\n/
    ;

// Raw ------------------------------------------------------
RawMode
    : '```' %push(Raw) [ Language ] RawText %pop() '```' [ NewBlock ]
    ;

Language
    : <Raw>/.+/
    ;

RawText
    : <Raw>/(.|\n)*/
    ;

// Code ------------------------------------------------------
CodeMode
    : <INITIAL>'#' %push(Code) ( Stmt | Expr | CodeList ) %pop() [ NewBlock ]
    ;

CurlyLeft
    : <Code>'{'
    ;

CurlyRight
    : <Code>'}'
    ;

BracketLeft
    : <Code>'('
    ;

BracketRight
    : <Code>')'
    ;

SquareLeft
    : <Code>'['
    ;

SquareRight
    : <Code>']'
    ;

Comma
    : <Code>','
    ;

Colon
    : <Code>':'
    ;

Assign
    : <Code>'='
    ;

KwMakro
    : <Code>'makro'
    ;

KwFor
    : <Code>'for'
    ;

KwIn: <Code>'in'
    ;

KwIf: <Code>'if'
    ;

KwElse: <Code>'else'
    ;

KwLet: <Code>'let'
    ;

Ident
    : <Code>"[a-zA-Z_]\w*"
    ;

String
    : <Code>/\u{0022}[^\u{0022}]*\u{0022}|'[^']*'/
    ;

Integer
    : <Code>/[0-9][0-9]*|[0-9][0-9A-F]*H/
    ;

Real: <Code>/[0-9][0-9]*\.[0-9]*(ED[+-]?[0-9][0-9]*)?/
    ;

StmtList
    : CurlyLeft NewLine { Stmt NewLine }
    ;

CodeList
    : StmtList [ Expr NewLine ] CurlyRight
    ;

Stmt: Let
    | Makro
    ;

Expr: Call
    | ContentMode
    | IfElse
    | For
    | Ident
    | String
    | Integer
    | Real
    ;

ExprList
    : StmtList Expr NewLine CurlyRight
    ;

Collection
    : BracketLeft (KeyValueList | ValueList) BracketRight;
    
KeyValue:
    Ident Colon Value
    ;

KeyValueList:
 KeyValue { Comma KeyValue };

Value: Ident | Collection | String | Integer | Real | Call;

ValueList: Value {Comma Value};

Makro: KwMakro Ident BracketLeft [ Args ] BracketRight Assign
      ( Expr | ExprList )
    ;

For : KwFor Ident KwIn (Ident | Collection | String | Call) ExprList
    ;

IfElse
    : KwIf Todo ExprList KwElse ( ExprList | IfElse )
    ;

Let : KwLet Ident Assign ( Expr | ExprList )
    ;

ContentMode
    : SquareLeft ((NewLine ContentBlock) | ContentLine) //%push(INITIAL) [ (TextLine | (NewLine Block)) ] %pop() SquareRight
    ;

ContentLine
    : %push(INITIAL) [TextLine] %pop SquareRight;

ContentBlock
    : %push(INITIAL) []

Call: Ident BracketLeft [ KeyValueList ] BracketRight [ ContentMode ]
    ;

Todo
    : <Code>/.+/
    ;
