%start TypeDown
%title "TypeDown grammar"
%comment "Empty grammar generated by `parol`"
%line_comment "//"
%block_comment "/\*/" "\*/"
%auto_newline_off

%scanner Code {
    %line_comment "//"
    %block_comment "/\*/" "\*/"
}
%scanner Math {}
%scanner Raw {
    %auto_newline_off
}

%%

// scanner for the different modes: raw, markup, math, code
TypeDown
    : { NewLine } Block
    ;

Block
    : Markup
    | RawMode
    | CodeMode
    | MathMode
    ;

// MarkUp ------------------------------------------------------
Markup
    : Heading
    | Paragraph
    | List
    | OrderedList
    ;

Heading
    : HeadingSign TextLine [ NewBlock ]
    ;

HeadingSign
    : <INITIAL>/=+/
    ;

Paragraph
    : TextLine [ NewBlock | Paragraph ]
    ;

List: ListSign TextLine [ NewBlock | List ]
    ;

ListSign
    : <INITIAL>'-'
    ;

OrderedList
    : OrderedListSign TextLine [ NewBlock | OrderedList ]
    ;

OrderedListSign
    : <INITIAL>'+'
    ;

TextLine
    : <INITIAL>/.+/ NewLine
    ;

NewBlock
    : <INITIAL>/\n+/ Block
    ;

NewLine
    : <INITIAL>/\n/
    ;

// Raw ------------------------------------------------------
RawMode
    : '```' %push(Raw) [ Language ] RawText %pop() '```' [ NewBlock ]
    ;

Language
    : <Raw>"[a-zA-Z]+"
    ;

RawText
    : <Raw>/(.|\n)*/
    ;

// Code ------------------------------------------------------
CodeMode
    : <INITIAL>'#' %push(Code) ( Stmt | Expr | CodeList ) %pop() [ NewBlock ]
    ;

CurlyLeft
    : <Code>'{'
    ;

CurlyRight
    : <Code>'}'
    ;

BracketLeft
    : <Code>'('
    ;

BracketRight
    : <Code>')'
    ;

SquareLeft
    : <Code>'['
    ;

SquareRight
    : <Code>']'
    ;

Comma
    : <Code>','
    ;

Colon
    : <Code>':'
    ;

Dot : <Code>'.'
    ;

Assign
    : <Code>'='
    ;

KwMakro
    : <Code>'makro'
    ;

KwFor
    : <Code>'for'
    ;

KwIn: <Code>'in'
    ;

KwIf: <Code>'if'
    ;

KwElse
    : <Code>'else'
    ;

KwLet
    : <Code>'let'
    ;

Ident
    : <Code>/[a-zA-Z_]\w*/
    ;

String
    : <Code>/\u{0022}[^\u{0022}]*\u{0022}|'[^']*'/
    ;

Digit
    : <Code>/[0-9]/
    ;

Digits
    : <Code>/[0-9]+/
    ;

Number
    : Digits [ Fraction ]
    ;

Fraction
    : Dot Digits
    ;

StmtList
    : CurlyLeft { Stmt }
    ;

CodeList
    : StmtList [ Expr ] CurlyRight
    ;

Stmt: Let
    | Makro
    ;

Expr: ContentMode
    | Access
    | IfElse
    | For
    | String
    | Number
    ;

ExprList
    : StmtList Expr CurlyRight
    ;

// TODO make ll1
Collection
    : BracketLeft ( KeyValueList | ValueList ) BracketRight
    ;

KeyValue
    : Ident Colon Value
    ;

KeyValueList
    : KeyValue { Comma KeyValue }
    ;

Value
    : Access
    | Collection
    | String
    | Number
    ;

Iterable
    : Access
    | Collection
    | String
    | Digits
    ;

ValueList
    : Value { Comma Value }
    ;

IdentList
    : Ident { Comma Ident }
    ;

Makro
    : KwMakro Ident BracketLeft [ IdentList ] BracketRight Assign ( Expr | ExprList )
    ;

For : KwFor Ident KwIn Iterable ExprList
    ;

// TODO maybe not ExprList but StmtList ?
IfElse
    : KwIf Todo ExprList KwElse ( ExprList | IfElse )
    ;

Let : KwLet Ident Assign ( Expr | ExprList )
    ;

ContentMode
    : SquareLeft %push(INITIAL) Block %pop() SquareRight
    ;

Access
    : Ident [ Call ]
    ;

Call: BracketLeft [ KeyValueList ] BracketRight //[ ContentMode ]
    ;

Todo: <Code>/\w+/
    ;

// MarkUp ------------------------------------------------------
Sigil
    : <Math>'$'
    ;

// Symbol
//     : <Math>'epsilon'
//     | <Math>'Epsilon'
//     | <Math>'x'
//     | <Math>'y'
//     ;
// MathOp
//     : <Math>'+'
//     | <Math>'-'
//     ;
MathMode
    : Sigil %push(Math) /\w+/ %pop() Sigil [ NewBlock ]
    ;
