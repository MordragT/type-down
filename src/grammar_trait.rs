// ---------------------------------------------------------
// This file was generated by parol.
// It is not intended for manual editing and changes will be
// lost after next build.
// ---------------------------------------------------------

// Disable clippy warnings that can result in the way how parol generates code.
#![allow(clippy::enum_variant_names)]
#![allow(clippy::large_enum_variant)]
#![allow(clippy::upper_case_acronyms)]

use parol_runtime::derive_builder::Builder;
use parol_runtime::log::trace;
#[allow(unused_imports)]
use parol_runtime::parol_macros::{pop_and_reverse_item, pop_item};
use parol_runtime::parser::{ParseTreeType, UserActionsTrait};
use parol_runtime::{ParserError, Result, Token};

/// Semantic actions trait generated for the user grammar
/// All functions have default implementations.
pub trait GrammarTrait<'t> {
    /// Semantic action for non-terminal 'TypeDown'
    fn type_down(&mut self, _arg: &TypeDown<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Block'
    fn block(&mut self, _arg: &Block<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'NewBlock'
    fn new_block(&mut self, _arg: &NewBlock<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'String'
    fn string(&mut self, _arg: &String) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'StringContent'
    fn string_content(&mut self, _arg: &StringContent) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MarkBlock'
    fn mark_block(&mut self, _arg: &MarkBlock) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'HeadingSign'
    fn heading_sign(&mut self, _arg: &HeadingSign<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Heading'
    fn heading(&mut self, _arg: &Heading) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Paragraph'
    fn paragraph(&mut self, _arg: &Paragraph) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'List'
    fn list(&mut self, _arg: &List) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'OrderedList'
    fn ordered_list(&mut self, _arg: &OrderedList) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Table'
    fn table(&mut self, _arg: &Table) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BlockquoteSign'
    fn blockquote_sign(&mut self, _arg: &BlockquoteSign<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Blockquote'
    fn blockquote(&mut self, _arg: &Blockquote) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Label'
    fn label(&mut self, _arg: &Label) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Line'
    fn line(&mut self, _arg: &Line) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Elements'
    fn elements(&mut self, _arg: &Elements) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Element'
    fn element(&mut self, _arg: &Element) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LinkContent'
    fn link_content(&mut self, _arg: &LinkContent) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Link'
    fn link(&mut self, _arg: &Link) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Escape'
    fn escape(&mut self, _arg: &Escape) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Monospace'
    fn monospace(&mut self, _arg: &Monospace) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MonospaceContent'
    fn monospace_content(&mut self, _arg: &MonospaceContent) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Subscript'
    fn subscript(&mut self, _arg: &Subscript) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Supscript'
    fn supscript(&mut self, _arg: &Supscript) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Format'
    fn format(&mut self, _arg: &Format) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Quote'
    fn quote(&mut self, _arg: &Quote) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Strikethrough'
    fn strikethrough(&mut self, _arg: &Strikethrough) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Strong'
    fn strong(&mut self, _arg: &Strong) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Emphasis'
    fn emphasis(&mut self, _arg: &Emphasis) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RawBlock'
    fn raw_block(&mut self, _arg: &RawBlock) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RawText'
    fn raw_text(&mut self, _arg: &RawText) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'CodeBlock'
    fn code_block(&mut self, _arg: &CodeBlock<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Expr'
    fn expr(&mut self, _arg: &Expr<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ListExpr'
    fn list_expr(&mut self, _arg: &ListExpr<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ControlExpr'
    fn control_expr(&mut self, _arg: &ControlExpr<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ValueExpr'
    fn value_expr(&mut self, _arg: &ValueExpr<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Let'
    fn r#let(&mut self, _arg: &Let<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'IdentList'
    fn ident_list(&mut self, _arg: &IdentList) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Makro'
    fn makro(&mut self, _arg: &Makro<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Content'
    fn content(&mut self, _arg: &Content<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ContentTail'
    fn content_tail(&mut self, _arg: &ContentTail<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'IfElse'
    fn if_else(&mut self, _arg: &IfElse<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Iterable'
    fn iterable(&mut self, _arg: &Iterable<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'For'
    fn r#for(&mut self, _arg: &For<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Disjunction'
    fn disjunction(&mut self, _arg: &Disjunction<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Conjunction'
    fn conjunction(&mut self, _arg: &Conjunction<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Negation'
    fn negation(&mut self, _arg: &Negation<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Relation'
    fn relation(&mut self, _arg: &Relation<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Summation'
    fn summation(&mut self, _arg: &Summation<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Multiplication'
    fn multiplication(&mut self, _arg: &Multiplication<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Factor'
    fn factor(&mut self, _arg: &Factor<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Primary'
    fn primary(&mut self, _arg: &Primary<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Value'
    fn value(&mut self, _arg: &Value<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Arg'
    fn arg(&mut self, _arg: &Arg<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Args'
    fn args(&mut self, _arg: &Args<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Access'
    fn access(&mut self, _arg: &Access<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Call'
    fn call(&mut self, _arg: &Call<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'KwMakro'
    fn kw_makro(&mut self, _arg: &KwMakro<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'KwFor'
    fn kw_for(&mut self, _arg: &KwFor<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'KwIn'
    fn kw_in(&mut self, _arg: &KwIn<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'KwIf'
    fn kw_if(&mut self, _arg: &KwIf<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'KwElse'
    fn kw_else(&mut self, _arg: &KwElse<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'KwLet'
    fn kw_let(&mut self, _arg: &KwLet<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'KwTrue'
    fn kw_true(&mut self, _arg: &KwTrue<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'KwFalse'
    fn kw_false(&mut self, _arg: &KwFalse<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Bool'
    fn bool(&mut self, _arg: &Bool<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Number'
    fn number(&mut self, _arg: &Number<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MathBlock'
    fn math_block(&mut self, _arg: &MathBlock<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Formular'
    fn formular(&mut self, _arg: &Formular<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Symbol'
    fn symbol(&mut self, _arg: &Symbol<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Alpha'
    fn alpha(&mut self, _arg: &Alpha<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Beta'
    fn beta(&mut self, _arg: &Beta<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Gamma'
    fn gamma(&mut self, _arg: &Gamma<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Delta'
    fn delta(&mut self, _arg: &Delta<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Epsilon'
    fn epsilon(&mut self, _arg: &Epsilon<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Zeta'
    fn zeta(&mut self, _arg: &Zeta<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Eta'
    fn eta(&mut self, _arg: &Eta<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Theta'
    fn theta(&mut self, _arg: &Theta<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Iota'
    fn iota(&mut self, _arg: &Iota<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Kappa'
    fn kappa(&mut self, _arg: &Kappa<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Lambda'
    fn lambda(&mut self, _arg: &Lambda<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Mu'
    fn mu(&mut self, _arg: &Mu<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Nu'
    fn nu(&mut self, _arg: &Nu<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Xi'
    fn xi(&mut self, _arg: &Xi<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Omicron'
    fn omicron(&mut self, _arg: &Omicron<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Pi'
    fn pi(&mut self, _arg: &Pi<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Rho'
    fn rho(&mut self, _arg: &Rho<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Sigma'
    fn sigma(&mut self, _arg: &Sigma<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Tau'
    fn tau(&mut self, _arg: &Tau<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Upsilon'
    fn upsilon(&mut self, _arg: &Upsilon<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Phi'
    fn phi(&mut self, _arg: &Phi<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Chi'
    fn chi(&mut self, _arg: &Chi<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Psi'
    fn psi(&mut self, _arg: &Psi<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Omega'
    fn omega(&mut self, _arg: &Omega<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Greek'
    fn greek(&mut self, _arg: &Greek<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'DoubleStruck'
    fn double_struck(&mut self, _arg: &DoubleStruck<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Not'
    fn not(&mut self, _arg: &Not<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'And'
    fn and(&mut self, _arg: &And<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Or'
    fn or(&mut self, _arg: &Or<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ForAll'
    fn for_all(&mut self, _arg: &ForAll<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Exists'
    fn exists(&mut self, _arg: &Exists<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Left'
    fn left(&mut self, _arg: &Left<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Right'
    fn right(&mut self, _arg: &Right<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Top'
    fn top(&mut self, _arg: &Top<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Bot'
    fn bot(&mut self, _arg: &Bot<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Tack'
    fn tack(&mut self, _arg: &Tack<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Logical'
    fn logical(&mut self, _arg: &Logical<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Equal'
    fn equal(&mut self, _arg: &Equal<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Identical'
    fn identical(&mut self, _arg: &Identical<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Approx'
    fn approx(&mut self, _arg: &Approx<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Prop'
    fn prop(&mut self, _arg: &Prop<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Less'
    fn less(&mut self, _arg: &Less<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Greater'
    fn greater(&mut self, _arg: &Greater<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'In'
    fn r#in(&mut self, _arg: &In<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Subset'
    fn subset(&mut self, _arg: &Subset<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Supset'
    fn supset(&mut self, _arg: &Supset<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Variable'
    fn variable(&mut self, _arg: &Variable<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Attach'
    fn attach(&mut self, _arg: &Attach<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Plus'
    fn plus(&mut self, _arg: &Plus<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Minus'
    fn minus(&mut self, _arg: &Minus<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Frac'
    fn frac(&mut self, _arg: &Frac<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Times'
    fn times(&mut self, _arg: &Times<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operation'
    fn operation(&mut self, _arg: &Operation<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'EquDoubleToken'
    fn equ_double_token(&mut self, _arg: &EquDoubleToken<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'EquToken'
    fn equ_token(&mut self, _arg: &EquToken<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'PlusToken'
    fn plus_token(&mut self, _arg: &PlusToken<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MinusToken'
    fn minus_token(&mut self, _arg: &MinusToken<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'SlashToken'
    fn slash_token(&mut self, _arg: &SlashToken<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BackslashToken'
    fn backslash_token(&mut self, _arg: &BackslashToken<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AsteriskToken'
    fn asterisk_token(&mut self, _arg: &AsteriskToken<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'PercentToken'
    fn percent_token(&mut self, _arg: &PercentToken<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'PipeDoubleToken'
    fn pipe_double_token(&mut self, _arg: &PipeDoubleToken<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'PipeToken'
    fn pipe_token(&mut self, _arg: &PipeToken<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'UnderscoreDoubleToken'
    fn underscore_double_token(&mut self, _arg: &UnderscoreDoubleToken<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'UnderscoreToken'
    fn underscore_token(&mut self, _arg: &UnderscoreToken<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'CaretToken'
    fn caret_token(&mut self, _arg: &CaretToken<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BacktickTripleToken'
    fn backtick_triple_token(&mut self, _arg: &BacktickTripleToken<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BacktickToken'
    fn backtick_token(&mut self, _arg: &BacktickToken<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TildeToken'
    fn tilde_token(&mut self, _arg: &TildeToken<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'HashToken'
    fn hash_token(&mut self, _arg: &HashToken<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'SigilToken'
    fn sigil_token(&mut self, _arg: &SigilToken<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AtToken'
    fn at_token(&mut self, _arg: &AtToken<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'CommaToken'
    fn comma_token(&mut self, _arg: &CommaToken<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'DotToken'
    fn dot_token(&mut self, _arg: &DotToken<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ColonToken'
    fn colon_token(&mut self, _arg: &ColonToken<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LeftParenToken'
    fn left_paren_token(&mut self, _arg: &LeftParenToken<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RightParenLeftBracketToken'
    fn right_paren_left_bracket_token(
        &mut self,
        _arg: &RightParenLeftBracketToken<'t>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RightParenToken'
    fn right_paren_token(&mut self, _arg: &RightParenToken<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LeftBraceToken'
    fn left_brace_token(&mut self, _arg: &LeftBraceToken<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RightBraceToken'
    fn right_brace_token(&mut self, _arg: &RightBraceToken<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LeftBracketToken'
    fn left_bracket_token(&mut self, _arg: &LeftBracketToken<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RightBracketToken'
    fn right_bracket_token(&mut self, _arg: &RightBracketToken<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LeftAngleEquToken'
    fn left_angle_equ_token(&mut self, _arg: &LeftAngleEquToken<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LeftAngleToken'
    fn left_angle_token(&mut self, _arg: &LeftAngleToken<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RightAngleLeftBracketToken'
    fn right_angle_left_bracket_token(
        &mut self,
        _arg: &RightAngleLeftBracketToken<'t>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RightAngleEquToken'
    fn right_angle_equ_token(&mut self, _arg: &RightAngleEquToken<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RightAngleToken'
    fn right_angle_token(&mut self, _arg: &RightAngleToken<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ExclamEquToken'
    fn exclam_equ_token(&mut self, _arg: &ExclamEquToken<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ExclamToken'
    fn exclam_token(&mut self, _arg: &ExclamToken<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AmperDoubleToken'
    fn amper_double_token(&mut self, _arg: &AmperDoubleToken<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'DigitsToken'
    fn digits_token(&mut self, _arg: &DigitsToken<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'IdentifierToken'
    fn identifier_token(&mut self, _arg: &IdentifierToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'NewLine'
    fn new_line(&mut self, _arg: &NewLine<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'WordToken'
    fn word_token(&mut self, _arg: &WordToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'DoubleQuoteToken'
    fn double_quote_token(&mut self, _arg: &DoubleQuoteToken<'t>) -> Result<()> {
        Ok(())
    }

    /// This method provides skipped language comments.
    /// If you need comments please provide your own implementation of this method.
    fn on_comment_parsed(&mut self, _token: Token<'t>) {}
}

// -------------------------------------------------------------------------------------------------
//
// Output Types of productions deduced from the structure of the transformed grammar
//

///
/// Type derived for production 5
///
/// Block: RawBlock;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BlockRawBlock {
    pub raw_block: Box<RawBlock>,
}

///
/// Type derived for production 6
///
/// Block: MarkBlock;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BlockMarkBlock {
    pub mark_block: Box<MarkBlock>,
}

///
/// Type derived for production 7
///
/// Block: CodeBlock;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BlockCodeBlock<'t> {
    pub code_block: Box<CodeBlock<'t>>,
}

///
/// Type derived for production 8
///
/// Block: MathBlock;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BlockMathBlock<'t> {
    pub math_block: Box<MathBlock<'t>>,
}

///
/// Type derived for production 14
///
/// MarkBlock: Heading;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MarkBlockHeading {
    pub heading: Box<Heading>,
}

///
/// Type derived for production 15
///
/// MarkBlock: Paragraph;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MarkBlockParagraph {
    pub paragraph: Box<Paragraph>,
}

///
/// Type derived for production 16
///
/// MarkBlock: List;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MarkBlockList {
    pub list: Box<List>,
}

///
/// Type derived for production 17
///
/// MarkBlock: OrderedList;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MarkBlockOrderedList {
    pub ordered_list: Box<OrderedList>,
}

///
/// Type derived for production 18
///
/// MarkBlock: Table;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MarkBlockTable {
    pub table: Box<Table>,
}

///
/// Type derived for production 19
///
/// MarkBlock: Blockquote;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MarkBlockBlockquote {
    pub blockquote: Box<Blockquote>,
}

///
/// Type derived for production 51
///
/// Element: WordToken;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ElementWordToken {
    pub word_token: Box<WordToken>,
}

///
/// Type derived for production 52
///
/// Element: Format;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ElementFormat {
    pub format: Box<Format>,
}

///
/// Type derived for production 53
///
/// Element: Link;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ElementLink {
    pub link: Box<Link>,
}

///
/// Type derived for production 54
///
/// Element: Escape;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ElementEscape {
    pub escape: Box<Escape>,
}

///
/// Type derived for production 55
///
/// Element: Subscript;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ElementSubscript {
    pub subscript: Box<Subscript>,
}

///
/// Type derived for production 56
///
/// Element: Supscript;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ElementSupscript {
    pub supscript: Box<Supscript>,
}

///
/// Type derived for production 57
///
/// Element: Monospace;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ElementMonospace {
    pub monospace: Box<Monospace>,
}

///
/// Type derived for production 58
///
/// Element: LeftBracketToken^ /* Clipped */ ElementList /* Vec */ RightBracketToken^ /* Clipped */;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ElementLeftBracketTokenElementListRightBracketToken {
    pub element_list: Vec<ElementList>,
}

///
/// Type derived for production 63
///
/// LinkGroup: RightAngleToken^ /* Clipped */;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LinkGroupRightAngleToken {}

///
/// Type derived for production 64
///
/// LinkGroup: RightAngleLeftBracketToken^ /* Clipped */ LinkGroupList /* Vec */ RightBracketToken^ /* Clipped */;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LinkGroupRightAngleLeftBracketTokenLinkGroupListRightBracketToken {
    pub link_group_list: Vec<LinkGroupList>,
}

///
/// Type derived for production 74
///
/// Format: Emphasis;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FormatEmphasis {
    pub emphasis: Box<Emphasis>,
}

///
/// Type derived for production 75
///
/// Format: Strong;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FormatStrong {
    pub strong: Box<Strong>,
}

///
/// Type derived for production 76
///
/// Format: Strikethrough;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FormatStrikethrough {
    pub strikethrough: Box<Strikethrough>,
}

///
/// Type derived for production 77
///
/// Format: Quote;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FormatQuote {
    pub quote: Box<Quote>,
}

///
/// Type derived for production 80
///
/// QuoteListGroup: WordToken;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct QuoteListGroupWordToken {
    pub word_token: Box<WordToken>,
}

///
/// Type derived for production 81
///
/// QuoteListGroup: Emphasis;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct QuoteListGroupEmphasis {
    pub emphasis: Box<Emphasis>,
}

///
/// Type derived for production 82
///
/// QuoteListGroup: Strong;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct QuoteListGroupStrong {
    pub strong: Box<Strong>,
}

///
/// Type derived for production 83
///
/// QuoteListGroup: Strikethrough;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct QuoteListGroupStrikethrough {
    pub strikethrough: Box<Strikethrough>,
}

///
/// Type derived for production 87
///
/// StrikethroughListGroup: WordToken;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StrikethroughListGroupWordToken {
    pub word_token: Box<WordToken>,
}

///
/// Type derived for production 88
///
/// StrikethroughListGroup: Emphasis;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StrikethroughListGroupEmphasis {
    pub emphasis: Box<Emphasis>,
}

///
/// Type derived for production 89
///
/// StrikethroughListGroup: Strong;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StrikethroughListGroupStrong {
    pub strong: Box<Strong>,
}

///
/// Type derived for production 93
///
/// StrongListGroup: WordToken;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StrongListGroupWordToken {
    pub word_token: Box<WordToken>,
}

///
/// Type derived for production 94
///
/// StrongListGroup: Emphasis;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StrongListGroupEmphasis {
    pub emphasis: Box<Emphasis>,
}

///
/// Type derived for production 104
///
/// Expr: Let;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ExprLet<'t> {
    pub r#let: Box<Let<'t>>,
}

///
/// Type derived for production 105
///
/// Expr: Makro;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ExprMakro<'t> {
    pub makro: Box<Makro<'t>>,
}

///
/// Type derived for production 106
///
/// Expr: ControlExpr;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ExprControlExpr<'t> {
    pub control_expr: Box<ControlExpr<'t>>,
}

///
/// Type derived for production 107
///
/// Expr: ValueExpr;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ExprValueExpr<'t> {
    pub value_expr: Box<ValueExpr<'t>>,
}

///
/// Type derived for production 108
///
/// Expr: ListExpr;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ExprListExpr<'t> {
    pub list_expr: Box<ListExpr<'t>>,
}

///
/// Type derived for production 112
///
/// ControlExpr: IfElse;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ControlExprIfElse<'t> {
    pub if_else: Box<IfElse<'t>>,
}

///
/// Type derived for production 113
///
/// ControlExpr: For;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ControlExprFor<'t> {
    pub r#for: Box<For<'t>>,
}

///
/// Type derived for production 114
///
/// ValueExpr: Disjunction;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ValueExprDisjunction<'t> {
    pub disjunction: Box<Disjunction<'t>>,
}

///
/// Type derived for production 115
///
/// ValueExpr: Content;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ValueExprContent<'t> {
    pub content: Box<Content<'t>>,
}

///
/// Type derived for production 125
///
/// ContentTailGroup: NewLine^ /* Clipped */ Block;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ContentTailGroupNewLineBlock<'t> {
    pub block: Box<Block<'t>>,
}

///
/// Type derived for production 126
///
/// ContentTailGroup: Elements;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ContentTailGroupElements {
    pub elements: Box<Elements>,
}

///
/// Type derived for production 128
///
/// IfElseGroup0: ListExpr;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IfElseGroup0ListExpr<'t> {
    pub list_expr: Box<ListExpr<'t>>,
}

///
/// Type derived for production 129
///
/// IfElseGroup0: Content;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IfElseGroup0Content<'t> {
    pub content: Box<Content<'t>>,
}

///
/// Type derived for production 130
///
/// IfElseGroup0: IfElse;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IfElseGroup0IfElse<'t> {
    pub if_else: Box<IfElse<'t>>,
}

///
/// Type derived for production 131
///
/// IfElseGroup: ListExpr;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IfElseGroupListExpr<'t> {
    pub list_expr: Box<ListExpr<'t>>,
}

///
/// Type derived for production 132
///
/// IfElseGroup: Content;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IfElseGroupContent<'t> {
    pub content: Box<Content<'t>>,
}

///
/// Type derived for production 133
///
/// Iterable: Access;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IterableAccess<'t> {
    pub access: Box<Access<'t>>,
}

///
/// Type derived for production 134
///
/// Iterable: String;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IterableString {
    pub string: Box<String>,
}

///
/// Type derived for production 135
///
/// Iterable: DigitsToken;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IterableDigitsToken<'t> {
    pub digits_token: Box<DigitsToken<'t>>,
}

///
/// Type derived for production 137
///
/// ForGroup: ListExpr;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ForGroupListExpr<'t> {
    pub list_expr: Box<ListExpr<'t>>,
}

///
/// Type derived for production 138
///
/// ForGroup: Content;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ForGroupContent<'t> {
    pub content: Box<Content<'t>>,
}

///
/// Type derived for production 148
///
/// Relation: Summation RelationOpt /* Option */;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RelationSummationRelationOpt<'t> {
    pub summation: Box<Summation<'t>>,
    pub relation_opt: Option<Box<RelationOpt<'t>>>,
}

///
/// Type derived for production 150
///
/// RelationOptGroup: EquDoubleToken;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RelationOptGroupEquDoubleToken<'t> {
    pub equ_double_token: Box<EquDoubleToken<'t>>,
}

///
/// Type derived for production 151
///
/// RelationOptGroup: ExclamEquToken;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RelationOptGroupExclamEquToken<'t> {
    pub exclam_equ_token: Box<ExclamEquToken<'t>>,
}

///
/// Type derived for production 152
///
/// RelationOptGroup: LeftAngleToken;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RelationOptGroupLeftAngleToken<'t> {
    pub left_angle_token: Box<LeftAngleToken<'t>>,
}

///
/// Type derived for production 153
///
/// RelationOptGroup: LeftAngleEquToken;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RelationOptGroupLeftAngleEquToken<'t> {
    pub left_angle_equ_token: Box<LeftAngleEquToken<'t>>,
}

///
/// Type derived for production 154
///
/// RelationOptGroup: RightAngleToken;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RelationOptGroupRightAngleToken<'t> {
    pub right_angle_token: Box<RightAngleToken<'t>>,
}

///
/// Type derived for production 155
///
/// RelationOptGroup: RightAngleEquToken;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RelationOptGroupRightAngleEquToken<'t> {
    pub right_angle_equ_token: Box<RightAngleEquToken<'t>>,
}

///
/// Type derived for production 159
///
/// SummationListGroup: PlusToken;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SummationListGroupPlusToken<'t> {
    pub plus_token: Box<PlusToken<'t>>,
}

///
/// Type derived for production 160
///
/// SummationListGroup: MinusToken;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SummationListGroupMinusToken<'t> {
    pub minus_token: Box<MinusToken<'t>>,
}

///
/// Type derived for production 164
///
/// MultiplicationListGroup: SlashToken;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MultiplicationListGroupSlashToken<'t> {
    pub slash_token: Box<SlashToken<'t>>,
}

///
/// Type derived for production 165
///
/// MultiplicationListGroup: AsteriskToken;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MultiplicationListGroupAsteriskToken<'t> {
    pub asterisk_token: Box<AsteriskToken<'t>>,
}

///
/// Type derived for production 166
///
/// MultiplicationListGroup: PercentToken;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MultiplicationListGroupPercentToken<'t> {
    pub percent_token: Box<PercentToken<'t>>,
}

///
/// Type derived for production 169
///
/// Primary: LeftParenToken Disjunction RightParenToken;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PrimaryLeftParenTokenDisjunctionRightParenToken<'t> {
    pub left_paren_token: Box<LeftParenToken<'t>>,
    pub disjunction: Box<Disjunction<'t>>,
    pub right_paren_token: Box<RightParenToken<'t>>,
}

///
/// Type derived for production 170
///
/// Primary: Value;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PrimaryValue<'t> {
    pub value: Box<Value<'t>>,
}

///
/// Type derived for production 171
///
/// Value: Access;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ValueAccess<'t> {
    pub access: Box<Access<'t>>,
}

///
/// Type derived for production 172
///
/// Value: String;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ValueString {
    pub string: Box<String>,
}

///
/// Type derived for production 173
///
/// Value: Number;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ValueNumber<'t> {
    pub number: Box<Number<'t>>,
}

///
/// Type derived for production 174
///
/// Value: Bool;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ValueBool<'t> {
    pub bool: Box<Bool<'t>>,
}

///
/// Type derived for production 175
///
/// Arg: IdentifierToken ArgOpt /* Option */;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArgIdentifierTokenArgOpt<'t> {
    pub identifier_token: Box<IdentifierToken>,
    pub arg_opt: Option<Box<ArgOpt<'t>>>,
}

///
/// Type derived for production 176
///
/// Arg: String;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArgString {
    pub string: Box<String>,
}

///
/// Type derived for production 177
///
/// Arg: Number;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArgNumber<'t> {
    pub number: Box<Number<'t>>,
}

///
/// Type derived for production 178
///
/// Arg: Bool;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArgBool<'t> {
    pub bool: Box<Bool<'t>>,
}

///
/// Type derived for production 180
///
/// ArgOptGroup: ColonToken Value;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArgOptGroupColonTokenValue<'t> {
    pub colon_token: Box<ColonToken<'t>>,
    pub value: Box<Value<'t>>,
}

///
/// Type derived for production 181
///
/// ArgOptGroup: Call;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArgOptGroupCall<'t> {
    pub call: Box<Call<'t>>,
}

///
/// Type derived for production 190
///
/// CallGroup: RightParenToken^ /* Clipped */;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct CallGroupRightParenToken {}

///
/// Type derived for production 191
///
/// CallGroup: RightParenLeftBracketToken^ /* Clipped */ ContentTail;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct CallGroupRightParenLeftBracketTokenContentTail<'t> {
    pub content_tail: Box<ContentTail<'t>>,
}

///
/// Type derived for production 202
///
/// Bool: KwTrue;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BoolKwTrue<'t> {
    pub kw_true: Box<KwTrue<'t>>,
}

///
/// Type derived for production 203
///
/// Bool: KwFalse;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BoolKwFalse<'t> {
    pub kw_false: Box<KwFalse<'t>>,
}

///
/// Type derived for production 209
///
/// Symbol: Greek;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SymbolGreek<'t> {
    pub greek: Box<Greek<'t>>,
}

///
/// Type derived for production 210
///
/// Symbol: Variable;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SymbolVariable<'t> {
    pub variable: Box<Variable<'t>>,
}

///
/// Type derived for production 211
///
/// Symbol: DoubleStruck;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SymbolDoubleStruck<'t> {
    pub double_struck: Box<DoubleStruck<'t>>,
}

///
/// Type derived for production 212
///
/// Symbol: Operation;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SymbolOperation<'t> {
    pub operation: Box<Operation<'t>>,
}

///
/// Type derived for production 213
///
/// Alpha: <Math>'Alpha';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AlphaAlpha<'t> {
    pub alpha: Token<'t>, /* Alpha */
}

///
/// Type derived for production 214
///
/// Alpha: <Math>'alpha';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AlphaAlpha0<'t> {
    pub alpha: Token<'t>, /* alpha */
}

///
/// Type derived for production 215
///
/// Beta: <Math>'Beta';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BetaBeta<'t> {
    pub beta: Token<'t>, /* Beta */
}

///
/// Type derived for production 216
///
/// Beta: <Math>'beta';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BetaBeta0<'t> {
    pub beta: Token<'t>, /* beta */
}

///
/// Type derived for production 217
///
/// Gamma: <Math>'Gamma';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct GammaGamma<'t> {
    pub gamma: Token<'t>, /* Gamma */
}

///
/// Type derived for production 218
///
/// Gamma: <Math>'gamma';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct GammaGamma0<'t> {
    pub gamma: Token<'t>, /* gamma */
}

///
/// Type derived for production 219
///
/// Delta: <Math>'Delta';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DeltaDelta<'t> {
    pub delta: Token<'t>, /* Delta */
}

///
/// Type derived for production 220
///
/// Delta: <Math>'delta';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DeltaDelta0<'t> {
    pub delta: Token<'t>, /* delta */
}

///
/// Type derived for production 221
///
/// Epsilon: <Math>'Epsilon';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct EpsilonEpsilon<'t> {
    pub epsilon: Token<'t>, /* Epsilon */
}

///
/// Type derived for production 222
///
/// Epsilon: <Math>'epsilon';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct EpsilonEpsilon0<'t> {
    pub epsilon: Token<'t>, /* epsilon */
}

///
/// Type derived for production 223
///
/// Zeta: <Math>'Zeta';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ZetaZeta<'t> {
    pub zeta: Token<'t>, /* Zeta */
}

///
/// Type derived for production 224
///
/// Zeta: <Math>'zeta';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ZetaZeta0<'t> {
    pub zeta: Token<'t>, /* zeta */
}

///
/// Type derived for production 225
///
/// Eta: <Math>'Eta';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct EtaEta<'t> {
    pub eta: Token<'t>, /* Eta */
}

///
/// Type derived for production 226
///
/// Eta: <Math>'eta';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct EtaEta0<'t> {
    pub eta: Token<'t>, /* eta */
}

///
/// Type derived for production 227
///
/// Theta: <Math>'Theta';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ThetaTheta<'t> {
    pub theta: Token<'t>, /* Theta */
}

///
/// Type derived for production 228
///
/// Theta: <Math>'theta';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ThetaTheta0<'t> {
    pub theta: Token<'t>, /* theta */
}

///
/// Type derived for production 229
///
/// Iota: <Math>'Iota';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IotaIota<'t> {
    pub iota: Token<'t>, /* Iota */
}

///
/// Type derived for production 230
///
/// Iota: <Math>'iota';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IotaIota0<'t> {
    pub iota: Token<'t>, /* iota */
}

///
/// Type derived for production 231
///
/// Kappa: <Math>'Kappa';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct KappaKappa<'t> {
    pub kappa: Token<'t>, /* Kappa */
}

///
/// Type derived for production 232
///
/// Kappa: <Math>'kappa';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct KappaKappa0<'t> {
    pub kappa: Token<'t>, /* kappa */
}

///
/// Type derived for production 233
///
/// Lambda: <Math>'Lambda';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LambdaLambda<'t> {
    pub lambda: Token<'t>, /* Lambda */
}

///
/// Type derived for production 234
///
/// Lambda: <Math>'lambda';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LambdaLambda0<'t> {
    pub lambda: Token<'t>, /* lambda */
}

///
/// Type derived for production 235
///
/// Mu: <Math>'Mu';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MuMu<'t> {
    pub mu: Token<'t>, /* Mu */
}

///
/// Type derived for production 236
///
/// Mu: <Math>'mu';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MuMu0<'t> {
    pub mu: Token<'t>, /* mu */
}

///
/// Type derived for production 237
///
/// Nu: <Math>'Nu';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct NuNu<'t> {
    pub nu: Token<'t>, /* Nu */
}

///
/// Type derived for production 238
///
/// Nu: <Math>'nu';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct NuNu0<'t> {
    pub nu: Token<'t>, /* nu */
}

///
/// Type derived for production 239
///
/// Xi: <Math>'Xi';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct XiXi<'t> {
    pub xi: Token<'t>, /* Xi */
}

///
/// Type derived for production 240
///
/// Xi: <Math>'xi';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct XiXi0<'t> {
    pub xi: Token<'t>, /* xi */
}

///
/// Type derived for production 241
///
/// Omicron: <Math>'Omicron';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct OmicronOmicron<'t> {
    pub omicron: Token<'t>, /* Omicron */
}

///
/// Type derived for production 242
///
/// Omicron: <Math>'omicron';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct OmicronOmicron0<'t> {
    pub omicron: Token<'t>, /* omicron */
}

///
/// Type derived for production 243
///
/// Pi: <Math>'Pi';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PiPi<'t> {
    pub pi: Token<'t>, /* Pi */
}

///
/// Type derived for production 244
///
/// Pi: <Math>'pi';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PiPi0<'t> {
    pub pi: Token<'t>, /* pi */
}

///
/// Type derived for production 245
///
/// Pi: <Math>'product';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PiProduct<'t> {
    pub product: Token<'t>, /* product */
}

///
/// Type derived for production 246
///
/// Rho: <Math>'Rho';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RhoRho<'t> {
    pub rho: Token<'t>, /* Rho */
}

///
/// Type derived for production 247
///
/// Rho: <Math>'rho';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RhoRho0<'t> {
    pub rho: Token<'t>, /* rho */
}

///
/// Type derived for production 248
///
/// Sigma: <Math>'Sigma';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SigmaSigma<'t> {
    pub sigma: Token<'t>, /* Sigma */
}

///
/// Type derived for production 249
///
/// Sigma: <Math>'sigma';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SigmaSigma0<'t> {
    pub sigma: Token<'t>, /* sigma */
}

///
/// Type derived for production 250
///
/// Sigma: <Math>'sum';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SigmaSum<'t> {
    pub sum: Token<'t>, /* sum */
}

///
/// Type derived for production 251
///
/// Tau: <Math>'Tau';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TauTau<'t> {
    pub tau: Token<'t>, /* Tau */
}

///
/// Type derived for production 252
///
/// Tau: <Math>'tau';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TauTau0<'t> {
    pub tau: Token<'t>, /* tau */
}

///
/// Type derived for production 253
///
/// Upsilon: <Math>'Upsilon';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct UpsilonUpsilon<'t> {
    pub upsilon: Token<'t>, /* Upsilon */
}

///
/// Type derived for production 254
///
/// Upsilon: <Math>'upsilon';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct UpsilonUpsilon0<'t> {
    pub upsilon: Token<'t>, /* upsilon */
}

///
/// Type derived for production 255
///
/// Phi: <Math>'Phi';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PhiPhi<'t> {
    pub phi: Token<'t>, /* Phi */
}

///
/// Type derived for production 256
///
/// Phi: <Math>'phi';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PhiPhi0<'t> {
    pub phi: Token<'t>, /* phi */
}

///
/// Type derived for production 257
///
/// Chi: <Math>'Chi';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ChiChi<'t> {
    pub chi: Token<'t>, /* Chi */
}

///
/// Type derived for production 258
///
/// Chi: <Math>'chi';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ChiChi0<'t> {
    pub chi: Token<'t>, /* chi */
}

///
/// Type derived for production 259
///
/// Psi: <Math>'Psi';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PsiPsi<'t> {
    pub psi: Token<'t>, /* Psi */
}

///
/// Type derived for production 260
///
/// Psi: <Math>'psi';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PsiPsi0<'t> {
    pub psi: Token<'t>, /* psi */
}

///
/// Type derived for production 261
///
/// Omega: <Math>'Omega';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct OmegaOmega<'t> {
    pub omega: Token<'t>, /* Omega */
}

///
/// Type derived for production 262
///
/// Omega: <Math>'omega';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct OmegaOmega0<'t> {
    pub omega: Token<'t>, /* omega */
}

///
/// Type derived for production 263
///
/// Greek: Alpha;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct GreekAlpha<'t> {
    pub alpha: Box<Alpha<'t>>,
}

///
/// Type derived for production 264
///
/// Greek: Beta;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct GreekBeta<'t> {
    pub beta: Box<Beta<'t>>,
}

///
/// Type derived for production 265
///
/// Greek: Gamma;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct GreekGamma<'t> {
    pub gamma: Box<Gamma<'t>>,
}

///
/// Type derived for production 266
///
/// Greek: Delta;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct GreekDelta<'t> {
    pub delta: Box<Delta<'t>>,
}

///
/// Type derived for production 267
///
/// Greek: Epsilon;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct GreekEpsilon<'t> {
    pub epsilon: Box<Epsilon<'t>>,
}

///
/// Type derived for production 268
///
/// Greek: Zeta;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct GreekZeta<'t> {
    pub zeta: Box<Zeta<'t>>,
}

///
/// Type derived for production 269
///
/// Greek: Eta;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct GreekEta<'t> {
    pub eta: Box<Eta<'t>>,
}

///
/// Type derived for production 270
///
/// Greek: Theta;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct GreekTheta<'t> {
    pub theta: Box<Theta<'t>>,
}

///
/// Type derived for production 271
///
/// Greek: Iota;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct GreekIota<'t> {
    pub iota: Box<Iota<'t>>,
}

///
/// Type derived for production 272
///
/// Greek: Kappa;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct GreekKappa<'t> {
    pub kappa: Box<Kappa<'t>>,
}

///
/// Type derived for production 273
///
/// Greek: Lambda;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct GreekLambda<'t> {
    pub lambda: Box<Lambda<'t>>,
}

///
/// Type derived for production 274
///
/// Greek: Mu;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct GreekMu<'t> {
    pub mu: Box<Mu<'t>>,
}

///
/// Type derived for production 275
///
/// Greek: Nu;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct GreekNu<'t> {
    pub nu: Box<Nu<'t>>,
}

///
/// Type derived for production 276
///
/// Greek: Xi;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct GreekXi<'t> {
    pub xi: Box<Xi<'t>>,
}

///
/// Type derived for production 277
///
/// Greek: Omicron;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct GreekOmicron<'t> {
    pub omicron: Box<Omicron<'t>>,
}

///
/// Type derived for production 278
///
/// Greek: Pi;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct GreekPi<'t> {
    pub pi: Box<Pi<'t>>,
}

///
/// Type derived for production 279
///
/// Greek: Rho;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct GreekRho<'t> {
    pub rho: Box<Rho<'t>>,
}

///
/// Type derived for production 280
///
/// Greek: Sigma;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct GreekSigma<'t> {
    pub sigma: Box<Sigma<'t>>,
}

///
/// Type derived for production 281
///
/// Greek: Tau;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct GreekTau<'t> {
    pub tau: Box<Tau<'t>>,
}

///
/// Type derived for production 282
///
/// Greek: Upsilon;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct GreekUpsilon<'t> {
    pub upsilon: Box<Upsilon<'t>>,
}

///
/// Type derived for production 283
///
/// Greek: Phi;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct GreekPhi<'t> {
    pub phi: Box<Phi<'t>>,
}

///
/// Type derived for production 284
///
/// Greek: Chi;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct GreekChi<'t> {
    pub chi: Box<Chi<'t>>,
}

///
/// Type derived for production 285
///
/// Greek: Psi;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct GreekPsi<'t> {
    pub psi: Box<Psi<'t>>,
}

///
/// Type derived for production 286
///
/// Greek: Omega;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct GreekOmega<'t> {
    pub omega: Box<Omega<'t>>,
}

///
/// Type derived for production 287
///
/// DoubleStruck: <Math>'AA';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DoubleStruckAA<'t> {
    pub a_a: Token<'t>, /* AA */
}

///
/// Type derived for production 288
///
/// DoubleStruck: <Math>'BB';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DoubleStruckBB<'t> {
    pub b_b: Token<'t>, /* BB */
}

///
/// Type derived for production 289
///
/// DoubleStruck: <Math>'CC';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DoubleStruckCC<'t> {
    pub c_c: Token<'t>, /* CC */
}

///
/// Type derived for production 290
///
/// DoubleStruck: <Math>'DD';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DoubleStruckDD<'t> {
    pub d_d: Token<'t>, /* DD */
}

///
/// Type derived for production 291
///
/// DoubleStruck: <Math>'EE';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DoubleStruckEE<'t> {
    pub e_e: Token<'t>, /* EE */
}

///
/// Type derived for production 292
///
/// DoubleStruck: <Math>'FF';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DoubleStruckFF<'t> {
    pub f_f: Token<'t>, /* FF */
}

///
/// Type derived for production 293
///
/// DoubleStruck: <Math>'GG';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DoubleStruckGG<'t> {
    pub g_g: Token<'t>, /* GG */
}

///
/// Type derived for production 294
///
/// DoubleStruck: <Math>'HH';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DoubleStruckHH<'t> {
    pub h_h: Token<'t>, /* HH */
}

///
/// Type derived for production 295
///
/// DoubleStruck: <Math>'II';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DoubleStruckII<'t> {
    pub i_i: Token<'t>, /* II */
}

///
/// Type derived for production 296
///
/// DoubleStruck: <Math>'JJ';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DoubleStruckJJ<'t> {
    pub j_j: Token<'t>, /* JJ */
}

///
/// Type derived for production 297
///
/// DoubleStruck: <Math>'KK';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DoubleStruckKK<'t> {
    pub k_k: Token<'t>, /* KK */
}

///
/// Type derived for production 298
///
/// DoubleStruck: <Math>'LL';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DoubleStruckLL<'t> {
    pub l_l: Token<'t>, /* LL */
}

///
/// Type derived for production 299
///
/// DoubleStruck: <Math>'MM';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DoubleStruckMM<'t> {
    pub m_m: Token<'t>, /* MM */
}

///
/// Type derived for production 300
///
/// DoubleStruck: <Math>'NN';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DoubleStruckNN<'t> {
    pub n_n: Token<'t>, /* NN */
}

///
/// Type derived for production 301
///
/// DoubleStruck: <Math>'OO';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DoubleStruckOO<'t> {
    pub o_o: Token<'t>, /* OO */
}

///
/// Type derived for production 302
///
/// DoubleStruck: <Math>'PP';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DoubleStruckPP<'t> {
    pub p_p: Token<'t>, /* PP */
}

///
/// Type derived for production 303
///
/// DoubleStruck: <Math>'QQ';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DoubleStruckQQ<'t> {
    pub q_q: Token<'t>, /* QQ */
}

///
/// Type derived for production 304
///
/// DoubleStruck: <Math>'RR';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DoubleStruckRR<'t> {
    pub r_r: Token<'t>, /* RR */
}

///
/// Type derived for production 305
///
/// DoubleStruck: <Math>'SS';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DoubleStruckSS<'t> {
    pub s_s: Token<'t>, /* SS */
}

///
/// Type derived for production 306
///
/// DoubleStruck: <Math>'TT';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DoubleStruckTT<'t> {
    pub t_t: Token<'t>, /* TT */
}

///
/// Type derived for production 307
///
/// DoubleStruck: <Math>'UU';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DoubleStruckUU<'t> {
    pub u_u: Token<'t>, /* UU */
}

///
/// Type derived for production 308
///
/// DoubleStruck: <Math>'VV';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DoubleStruckVV<'t> {
    pub v_v: Token<'t>, /* VV */
}

///
/// Type derived for production 309
///
/// DoubleStruck: <Math>'WW';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DoubleStruckWW<'t> {
    pub w_w: Token<'t>, /* WW */
}

///
/// Type derived for production 310
///
/// DoubleStruck: <Math>'XX';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DoubleStruckXX<'t> {
    pub x_x: Token<'t>, /* XX */
}

///
/// Type derived for production 311
///
/// DoubleStruck: <Math>'YY';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DoubleStruckYY<'t> {
    pub y_y: Token<'t>, /* YY */
}

///
/// Type derived for production 312
///
/// DoubleStruck: <Math>'ZZ';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DoubleStruckZZ<'t> {
    pub z_z: Token<'t>, /* ZZ */
}

///
/// Type derived for production 324
///
/// TackOptGroup: Left;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TackOptGroupLeft<'t> {
    pub left: Box<Left<'t>>,
}

///
/// Type derived for production 325
///
/// TackOptGroup: Right;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TackOptGroupRight<'t> {
    pub right: Box<Right<'t>>,
}

///
/// Type derived for production 326
///
/// TackOptGroup: Top;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TackOptGroupTop<'t> {
    pub top: Box<Top<'t>>,
}

///
/// Type derived for production 327
///
/// TackOptGroup: Bot;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TackOptGroupBot<'t> {
    pub bot: Box<Bot<'t>>,
}

///
/// Type derived for production 329
///
/// Logical: And;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LogicalAnd<'t> {
    pub and: Box<And<'t>>,
}

///
/// Type derived for production 330
///
/// Logical: Or;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LogicalOr<'t> {
    pub or: Box<Or<'t>>,
}

///
/// Type derived for production 331
///
/// Logical: Not;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LogicalNot<'t> {
    pub not: Box<Not<'t>>,
}

///
/// Type derived for production 332
///
/// Logical: ForAll;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LogicalForAll<'t> {
    pub for_all: Box<ForAll<'t>>,
}

///
/// Type derived for production 333
///
/// Logical: Exists;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LogicalExists<'t> {
    pub exists: Box<Exists<'t>>,
}

///
/// Type derived for production 334
///
/// Logical: Tack;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LogicalTack<'t> {
    pub tack: Box<Tack<'t>>,
}

///
/// Type derived for production 356
///
/// SubsetOptGroup: Not;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SubsetOptGroupNot<'t> {
    pub not: Box<Not<'t>>,
}

///
/// Type derived for production 357
///
/// SubsetOptGroup: Equal;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SubsetOptGroupEqual<'t> {
    pub equal: Box<Equal<'t>>,
}

///
/// Type derived for production 361
///
/// SupsetOptGroup: Not;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SupsetOptGroupNot<'t> {
    pub not: Box<Not<'t>>,
}

///
/// Type derived for production 362
///
/// SupsetOptGroup: Equal;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SupsetOptGroupEqual<'t> {
    pub equal: Box<Equal<'t>>,
}

///
/// Type derived for production 364
///
/// Relation: Equal;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RelationEqual<'t> {
    pub equal: Box<Equal<'t>>,
}

///
/// Type derived for production 365
///
/// Relation: Identical;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RelationIdentical<'t> {
    pub identical: Box<Identical<'t>>,
}

///
/// Type derived for production 366
///
/// Relation: Approx;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RelationApprox<'t> {
    pub approx: Box<Approx<'t>>,
}

///
/// Type derived for production 367
///
/// Relation: Prop;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RelationProp<'t> {
    pub prop: Box<Prop<'t>>,
}

///
/// Type derived for production 368
///
/// Relation: Less;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RelationLess<'t> {
    pub less: Box<Less<'t>>,
}

///
/// Type derived for production 369
///
/// Relation: Greater;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RelationGreater<'t> {
    pub greater: Box<Greater<'t>>,
}

///
/// Type derived for production 370
///
/// Relation: In;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RelationIn<'t> {
    pub r#in: Box<In<'t>>,
}

///
/// Type derived for production 371
///
/// Relation: Subset;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RelationSubset<'t> {
    pub subset: Box<Subset<'t>>,
}

///
/// Type derived for production 372
///
/// Relation: Supset;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RelationSupset<'t> {
    pub supset: Box<Supset<'t>>,
}

///
/// Type derived for production 374
///
/// Attach: UnderscoreToken;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AttachUnderscoreToken<'t> {
    pub underscore_token: Box<UnderscoreToken<'t>>,
}

///
/// Type derived for production 375
///
/// Attach: CaretToken;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AttachCaretToken<'t> {
    pub caret_token: Box<CaretToken<'t>>,
}

///
/// Type derived for production 376
///
/// Plus: <Math>'plus';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PlusPlus<'t> {
    pub plus: Token<'t>, /* plus */
}

///
/// Type derived for production 377
///
/// Plus: PlusToken;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PlusPlusToken<'t> {
    pub plus_token: Box<PlusToken<'t>>,
}

///
/// Type derived for production 378
///
/// Minus: <Math>'minus';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MinusMinus<'t> {
    pub minus: Token<'t>, /* minus */
}

///
/// Type derived for production 379
///
/// Minus: MinusToken;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MinusMinusToken<'t> {
    pub minus_token: Box<MinusToken<'t>>,
}

///
/// Type derived for production 380
///
/// Frac: <Math>'frac';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FracFrac<'t> {
    pub frac: Token<'t>, /* frac */
}

///
/// Type derived for production 381
///
/// Frac: SlashToken;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FracSlashToken<'t> {
    pub slash_token: Box<SlashToken<'t>>,
}

///
/// Type derived for production 382
///
/// Times: <Math>'times';
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TimesTimes<'t> {
    pub times: Token<'t>, /* times */
}

///
/// Type derived for production 383
///
/// Times: AsteriskToken;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TimesAsteriskToken<'t> {
    pub asterisk_token: Box<AsteriskToken<'t>>,
}

///
/// Type derived for production 384
///
/// Operation: Logical;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct OperationLogical<'t> {
    pub logical: Box<Logical<'t>>,
}

///
/// Type derived for production 385
///
/// Operation: Relation;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct OperationRelation<'t> {
    pub relation: Box<Relation<'t>>,
}

///
/// Type derived for production 386
///
/// Operation: Attach;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct OperationAttach<'t> {
    pub attach: Box<Attach<'t>>,
}

///
/// Type derived for production 387
///
/// Operation: Plus;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct OperationPlus<'t> {
    pub plus: Box<Plus<'t>>,
}

///
/// Type derived for production 388
///
/// Operation: Minus;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct OperationMinus<'t> {
    pub minus: Box<Minus<'t>>,
}

///
/// Type derived for production 389
///
/// Operation: Frac;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct OperationFrac<'t> {
    pub frac: Box<Frac<'t>>,
}

///
/// Type derived for production 390
///
/// Operation: Times;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct OperationTimes<'t> {
    pub times: Box<Times<'t>>,
}

// -------------------------------------------------------------------------------------------------
//
// Types of non-terminals deduced from the structure of the transformed grammar
//

///
/// Type derived for non-terminal Access
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Access<'t> {
    pub identifier_token: Box<IdentifierToken>,
    pub access_opt: Option<Box<AccessOpt<'t>>>,
}

///
/// Type derived for non-terminal AccessOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AccessOpt<'t> {
    pub call: Box<Call<'t>>,
}

///
/// Type derived for non-terminal Alpha
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Alpha<'t> {
    Alpha(AlphaAlpha<'t>),
    Alpha0(AlphaAlpha0<'t>),
}

///
/// Type derived for non-terminal AmperDoubleToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AmperDoubleToken<'t> {
    pub amper_double_token: Token<'t>, /* && */
}

///
/// Type derived for non-terminal And
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct And<'t> {
    pub and: Token<'t>, /* and */
}

///
/// Type derived for non-terminal Approx
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Approx<'t> {
    pub approx: Token<'t>, /* approx */
    pub approx_opt: Option<Box<ApproxOpt<'t>>>,
}

///
/// Type derived for non-terminal ApproxOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ApproxOpt<'t> {
    pub dot_token: Box<DotToken<'t>>,
    pub not: Box<Not<'t>>,
}

///
/// Type derived for non-terminal Arg
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Arg<'t> {
    IdentifierTokenArgOpt(ArgIdentifierTokenArgOpt<'t>),
    String(ArgString),
    Number(ArgNumber<'t>),
    Bool(ArgBool<'t>),
}

///
/// Type derived for non-terminal ArgOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArgOpt<'t> {
    pub arg_opt_group: Box<ArgOptGroup<'t>>,
}

///
/// Type derived for non-terminal ArgOptGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ArgOptGroup<'t> {
    ColonTokenValue(ArgOptGroupColonTokenValue<'t>),
    Call(ArgOptGroupCall<'t>),
}

///
/// Type derived for non-terminal Args
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Args<'t> {
    pub arg: Box<Arg<'t>>,
    pub args_list: Vec<ArgsList<'t>>,
}

///
/// Type derived for non-terminal ArgsList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArgsList<'t> {
    pub arg: Box<Arg<'t>>,
}

///
/// Type derived for non-terminal AsteriskToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AsteriskToken<'t> {
    pub asterisk_token: Token<'t>, /* * */
}

///
/// Type derived for non-terminal AtToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AtToken<'t> {
    pub at_token: Token<'t>, /* @ */
}

///
/// Type derived for non-terminal Attach
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Attach<'t> {
    UnderscoreToken(AttachUnderscoreToken<'t>),
    CaretToken(AttachCaretToken<'t>),
}

///
/// Type derived for non-terminal BackslashToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BackslashToken<'t> {
    pub backslash_token: Token<'t>, /* \\ */
}

///
/// Type derived for non-terminal BacktickToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BacktickToken<'t> {
    pub backtick_token: Token<'t>, /* ` */
}

///
/// Type derived for non-terminal BacktickTripleToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BacktickTripleToken<'t> {
    pub backtick_triple_token: Token<'t>, /* ``` */
}

///
/// Type derived for non-terminal Beta
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Beta<'t> {
    Beta(BetaBeta<'t>),
    Beta0(BetaBeta0<'t>),
}

///
/// Type derived for non-terminal Block
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Block<'t> {
    RawBlock(BlockRawBlock),
    MarkBlock(BlockMarkBlock),
    CodeBlock(BlockCodeBlock<'t>),
    MathBlock(BlockMathBlock<'t>),
}

///
/// Type derived for non-terminal Blockquote
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Blockquote {
    pub blockquote_sign: crate::token::BlockquoteLevel,
    pub line: Box<Line>,
    pub blockquote_opt: Option<Box<BlockquoteOpt>>,
}

///
/// Type derived for non-terminal BlockquoteOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BlockquoteOpt {
    pub blockquote: Box<Blockquote>,
}

///
/// Type derived for non-terminal BlockquoteSign
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BlockquoteSign<'t> {
    pub right_angle_token: Box<RightAngleToken<'t>>,
    pub blockquote_sign_list: Vec<BlockquoteSignList<'t>>,
}

///
/// Type derived for non-terminal BlockquoteSignList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BlockquoteSignList<'t> {
    pub right_angle_token: Box<RightAngleToken<'t>>,
}

///
/// Type derived for non-terminal Bool
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Bool<'t> {
    KwTrue(BoolKwTrue<'t>),
    KwFalse(BoolKwFalse<'t>),
}

///
/// Type derived for non-terminal Bot
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Bot<'t> {
    pub bot: Token<'t>, /* bot */
}

///
/// Type derived for non-terminal Call
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Call<'t> {
    pub call_opt: Option<Box<CallOpt<'t>>>,
    pub call_group: Box<CallGroup<'t>>,
}

///
/// Type derived for non-terminal CallGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum CallGroup<'t> {
    RightParenToken(CallGroupRightParenToken),
    RightParenLeftBracketTokenContentTail(CallGroupRightParenLeftBracketTokenContentTail<'t>),
}

///
/// Type derived for non-terminal CallOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct CallOpt<'t> {
    pub args: Box<Args<'t>>,
}

///
/// Type derived for non-terminal CaretToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct CaretToken<'t> {
    pub caret_token: Token<'t>, /* ^ */
}

///
/// Type derived for non-terminal Chi
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Chi<'t> {
    Chi(ChiChi<'t>),
    Chi0(ChiChi0<'t>),
}

///
/// Type derived for non-terminal CodeBlock
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct CodeBlock<'t> {
    pub expr: Box<Expr<'t>>,
}

///
/// Type derived for non-terminal ColonToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ColonToken<'t> {
    pub colon_token: Token<'t>, /* : */
}

///
/// Type derived for non-terminal CommaToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct CommaToken<'t> {
    pub comma_token: Token<'t>, /* , */
}

///
/// Type derived for non-terminal Conjunction
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Conjunction<'t> {
    pub negation: Box<Negation<'t>>,
    pub conjunction_list: Vec<ConjunctionList<'t>>,
}

///
/// Type derived for non-terminal ConjunctionList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ConjunctionList<'t> {
    pub amper_double_token: Box<AmperDoubleToken<'t>>,
    pub negation: Box<Negation<'t>>,
}

///
/// Type derived for non-terminal Content
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Content<'t> {
    pub content_tail: Box<ContentTail<'t>>,
}

///
/// Type derived for non-terminal ContentTail
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ContentTail<'t> {
    pub content_tail_group: Box<ContentTailGroup<'t>>,
}

///
/// Type derived for non-terminal ContentTailGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ContentTailGroup<'t> {
    NewLineBlock(ContentTailGroupNewLineBlock<'t>),
    Elements(ContentTailGroupElements),
}

///
/// Type derived for non-terminal ControlExpr
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ControlExpr<'t> {
    IfElse(ControlExprIfElse<'t>),
    For(ControlExprFor<'t>),
}

///
/// Type derived for non-terminal Delta
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Delta<'t> {
    Delta(DeltaDelta<'t>),
    Delta0(DeltaDelta0<'t>),
}

///
/// Type derived for non-terminal DigitsToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DigitsToken<'t> {
    pub digits_token: Token<'t>, /* [0-9]+ */
}

///
/// Type derived for non-terminal Disjunction
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Disjunction<'t> {
    pub conjunction: Box<Conjunction<'t>>,
    pub disjunction_list: Vec<DisjunctionList<'t>>,
}

///
/// Type derived for non-terminal DisjunctionList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DisjunctionList<'t> {
    pub pipe_double_token: Box<PipeDoubleToken<'t>>,
    pub conjunction: Box<Conjunction<'t>>,
}

///
/// Type derived for non-terminal DotToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DotToken<'t> {
    pub dot_token: Token<'t>, /* . */
}

///
/// Type derived for non-terminal DoubleQuoteToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DoubleQuoteToken<'t> {
    pub double_quote_token: Token<'t>, /* \" */
}

///
/// Type derived for non-terminal DoubleStruck
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum DoubleStruck<'t> {
    AA(DoubleStruckAA<'t>),
    BB(DoubleStruckBB<'t>),
    CC(DoubleStruckCC<'t>),
    DD(DoubleStruckDD<'t>),
    EE(DoubleStruckEE<'t>),
    FF(DoubleStruckFF<'t>),
    GG(DoubleStruckGG<'t>),
    HH(DoubleStruckHH<'t>),
    II(DoubleStruckII<'t>),
    JJ(DoubleStruckJJ<'t>),
    KK(DoubleStruckKK<'t>),
    LL(DoubleStruckLL<'t>),
    MM(DoubleStruckMM<'t>),
    NN(DoubleStruckNN<'t>),
    OO(DoubleStruckOO<'t>),
    PP(DoubleStruckPP<'t>),
    QQ(DoubleStruckQQ<'t>),
    RR(DoubleStruckRR<'t>),
    SS(DoubleStruckSS<'t>),
    TT(DoubleStruckTT<'t>),
    UU(DoubleStruckUU<'t>),
    VV(DoubleStruckVV<'t>),
    WW(DoubleStruckWW<'t>),
    XX(DoubleStruckXX<'t>),
    YY(DoubleStruckYY<'t>),
    ZZ(DoubleStruckZZ<'t>),
}

///
/// Type derived for non-terminal Element
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Element {
    WordToken(ElementWordToken),
    Format(ElementFormat),
    Link(ElementLink),
    Escape(ElementEscape),
    Subscript(ElementSubscript),
    Supscript(ElementSupscript),
    Monospace(ElementMonospace),
    LeftBracketTokenElementListRightBracketToken(
        ElementLeftBracketTokenElementListRightBracketToken,
    ),
}

///
/// Type derived for non-terminal ElementList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ElementList {
    pub element: Box<Element>,
}

///
/// Type derived for non-terminal Elements
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Elements {
    pub element: Box<Element>,
    pub elements_list: Vec<ElementsList>,
}

///
/// Type derived for non-terminal ElementsList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ElementsList {
    pub element: Box<Element>,
}

///
/// Type derived for non-terminal Emphasis
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Emphasis {
    pub emphasis_list: Vec<EmphasisList>,
}

///
/// Type derived for non-terminal EmphasisList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct EmphasisList {
    pub word_token: Box<WordToken>,
}

///
/// Type derived for non-terminal Epsilon
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Epsilon<'t> {
    Epsilon(EpsilonEpsilon<'t>),
    Epsilon0(EpsilonEpsilon0<'t>),
}

///
/// Type derived for non-terminal EquDoubleToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct EquDoubleToken<'t> {
    pub equ_double_token: Token<'t>, /* == */
}

///
/// Type derived for non-terminal EquToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct EquToken<'t> {
    pub equ_token: Token<'t>, /* = */
}

///
/// Type derived for non-terminal Equal
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Equal<'t> {
    pub eq: Token<'t>, /* eq */
    pub equal_opt: Option<Box<EqualOpt<'t>>>,
}

///
/// Type derived for non-terminal EqualOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct EqualOpt<'t> {
    pub dot_token: Box<DotToken<'t>>,
    pub not: Box<Not<'t>>,
}

///
/// Type derived for non-terminal Escape
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Escape {
    pub l_bracket_hash_r_bracket: crate::token::Token, /* [\#\\] */
}

///
/// Type derived for non-terminal Eta
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Eta<'t> {
    Eta(EtaEta<'t>),
    Eta0(EtaEta0<'t>),
}

///
/// Type derived for non-terminal ExclamEquToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ExclamEquToken<'t> {
    pub exclam_equ_token: Token<'t>, /* != */
}

///
/// Type derived for non-terminal ExclamToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ExclamToken<'t> {
    pub exclam_token: Token<'t>, /* ! */
}

///
/// Type derived for non-terminal Exists
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Exists<'t> {
    pub exists: Token<'t>, /* exists */
}

///
/// Type derived for non-terminal Expr
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Expr<'t> {
    Let(ExprLet<'t>),
    Makro(ExprMakro<'t>),
    ControlExpr(ExprControlExpr<'t>),
    ValueExpr(ExprValueExpr<'t>),
    ListExpr(ExprListExpr<'t>),
}

///
/// Type derived for non-terminal Factor
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Factor<'t> {
    pub primary: Box<Primary<'t>>,
}

///
/// Type derived for non-terminal For
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct For<'t> {
    pub identifier_token: Box<IdentifierToken>,
    pub iterable: Box<Iterable<'t>>,
    pub for_group: Box<ForGroup<'t>>,
}

///
/// Type derived for non-terminal ForAll
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ForAll<'t> {
    pub for_all: Token<'t>, /* forall */
}

///
/// Type derived for non-terminal ForGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ForGroup<'t> {
    ListExpr(ForGroupListExpr<'t>),
    Content(ForGroupContent<'t>),
}

///
/// Type derived for non-terminal Format
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Format {
    Emphasis(FormatEmphasis),
    Strong(FormatStrong),
    Strikethrough(FormatStrikethrough),
    Quote(FormatQuote),
}

///
/// Type derived for non-terminal Formular
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Formular<'t> {
    pub symbol: Box<Symbol<'t>>,
}

///
/// Type derived for non-terminal Frac
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Frac<'t> {
    Frac(FracFrac<'t>),
    SlashToken(FracSlashToken<'t>),
}

///
/// Type derived for non-terminal Gamma
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Gamma<'t> {
    Gamma(GammaGamma<'t>),
    Gamma0(GammaGamma0<'t>),
}

///
/// Type derived for non-terminal Greater
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Greater<'t> {
    pub ge: Token<'t>, /* ge */
    pub greater_opt: Option<Box<GreaterOpt<'t>>>,
}

///
/// Type derived for non-terminal GreaterOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct GreaterOpt<'t> {
    pub dot_token: Box<DotToken<'t>>,
    pub equal: Box<Equal<'t>>,
}

///
/// Type derived for non-terminal Greek
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Greek<'t> {
    Alpha(GreekAlpha<'t>),
    Beta(GreekBeta<'t>),
    Gamma(GreekGamma<'t>),
    Delta(GreekDelta<'t>),
    Epsilon(GreekEpsilon<'t>),
    Zeta(GreekZeta<'t>),
    Eta(GreekEta<'t>),
    Theta(GreekTheta<'t>),
    Iota(GreekIota<'t>),
    Kappa(GreekKappa<'t>),
    Lambda(GreekLambda<'t>),
    Mu(GreekMu<'t>),
    Nu(GreekNu<'t>),
    Xi(GreekXi<'t>),
    Omicron(GreekOmicron<'t>),
    Pi(GreekPi<'t>),
    Rho(GreekRho<'t>),
    Sigma(GreekSigma<'t>),
    Tau(GreekTau<'t>),
    Upsilon(GreekUpsilon<'t>),
    Phi(GreekPhi<'t>),
    Chi(GreekChi<'t>),
    Psi(GreekPsi<'t>),
    Omega(GreekOmega<'t>),
}

///
/// Type derived for non-terminal HashToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct HashToken<'t> {
    pub hash_token: Token<'t>, /* # */
}

///
/// Type derived for non-terminal Heading
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Heading {
    pub heading_sign: crate::token::HeadingLevel,
    pub line: Box<Line>,
}

///
/// Type derived for non-terminal HeadingSign
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct HeadingSign<'t> {
    pub equ_token: Box<EquToken<'t>>,
    pub heading_sign_list: Vec<HeadingSignList<'t>>,
}

///
/// Type derived for non-terminal HeadingSignList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct HeadingSignList<'t> {
    pub equ_token: Box<EquToken<'t>>,
}

///
/// Type derived for non-terminal IdentList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IdentList {
    pub identifier_token: Box<IdentifierToken>,
    pub ident_list_list: Vec<IdentListList>,
}

///
/// Type derived for non-terminal IdentListList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IdentListList {
    pub identifier_token: Box<IdentifierToken>,
}

///
/// Type derived for non-terminal Identical
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Identical<'t> {
    pub ident: Token<'t>, /* ident */
    pub identical_opt: Option<Box<IdenticalOpt<'t>>>,
}

///
/// Type derived for non-terminal IdenticalOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IdenticalOpt<'t> {
    pub dot_token: Box<DotToken<'t>>,
    pub not: Box<Not<'t>>,
}

///
/// Type derived for non-terminal IdentifierToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IdentifierToken {
    pub identifier_token: crate::token::Token, /* [a-zA-Z_][0-9a-zA-Z_]* */
}

///
/// Type derived for non-terminal IfElse
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IfElse<'t> {
    pub kw_if: Box<KwIf<'t>>,
    pub disjunction: Box<Disjunction<'t>>,
    pub if_else_group: Box<IfElseGroup<'t>>,
    pub kw_else: Box<KwElse<'t>>,
    pub if_else_group0: Box<IfElseGroup0<'t>>,
}

///
/// Type derived for non-terminal IfElseGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum IfElseGroup<'t> {
    ListExpr(IfElseGroupListExpr<'t>),
    Content(IfElseGroupContent<'t>),
}

///
/// Type derived for non-terminal IfElseGroup0
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum IfElseGroup0<'t> {
    ListExpr(IfElseGroup0ListExpr<'t>),
    Content(IfElseGroup0Content<'t>),
    IfElse(IfElseGroup0IfElse<'t>),
}

///
/// Type derived for non-terminal In
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct In<'t> {
    pub kw_in: Token<'t>, /* in */
    pub in_opt: Option<Box<InOpt<'t>>>,
}

///
/// Type derived for non-terminal InOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InOpt<'t> {
    pub dot_token: Box<DotToken<'t>>,
    pub not: Box<Not<'t>>,
}

///
/// Type derived for non-terminal Iota
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Iota<'t> {
    Iota(IotaIota<'t>),
    Iota0(IotaIota0<'t>),
}

///
/// Type derived for non-terminal Iterable
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Iterable<'t> {
    Access(IterableAccess<'t>),
    String(IterableString),
    DigitsToken(IterableDigitsToken<'t>),
}

///
/// Type derived for non-terminal Kappa
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Kappa<'t> {
    Kappa(KappaKappa<'t>),
    Kappa0(KappaKappa0<'t>),
}

///
/// Type derived for non-terminal KwElse
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct KwElse<'t> {
    pub kw_else: Token<'t>, /* else */
}

///
/// Type derived for non-terminal KwFalse
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct KwFalse<'t> {
    pub kw_false: Token<'t>, /* false */
}

///
/// Type derived for non-terminal KwFor
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct KwFor<'t> {
    pub kw_for: Token<'t>, /* for */
}

///
/// Type derived for non-terminal KwIf
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct KwIf<'t> {
    pub kw_if: Token<'t>, /* if */
}

///
/// Type derived for non-terminal KwIn
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct KwIn<'t> {
    pub kw_in: Token<'t>, /* in */
}

///
/// Type derived for non-terminal KwLet
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct KwLet<'t> {
    pub kw_let: Token<'t>, /* let */
}

///
/// Type derived for non-terminal KwMakro
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct KwMakro<'t> {
    pub kw_makro: Token<'t>, /* makro */
}

///
/// Type derived for non-terminal KwTrue
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct KwTrue<'t> {
    pub kw_true: Token<'t>, /* true */
}

///
/// Type derived for non-terminal Label
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Label {
    pub identifier_token: Box<IdentifierToken>,
}

///
/// Type derived for non-terminal Lambda
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Lambda<'t> {
    Lambda(LambdaLambda<'t>),
    Lambda0(LambdaLambda0<'t>),
}

///
/// Type derived for non-terminal Left
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Left<'t> {
    pub left: Token<'t>, /* left */
}

///
/// Type derived for non-terminal LeftAngleEquToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LeftAngleEquToken<'t> {
    pub left_angle_equ_token: Token<'t>, /* <= */
}

///
/// Type derived for non-terminal LeftAngleToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LeftAngleToken<'t> {
    pub left_angle_token: Token<'t>, /* < */
}

///
/// Type derived for non-terminal LeftBraceToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LeftBraceToken<'t> {
    pub left_brace_token: Token<'t>, /* { */
}

///
/// Type derived for non-terminal LeftBracketToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LeftBracketToken<'t> {
    pub left_bracket_token: Token<'t>, /* [ */
}

///
/// Type derived for non-terminal LeftParenToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LeftParenToken<'t> {
    pub left_paren_token: Token<'t>, /* ( */
}

///
/// Type derived for non-terminal Less
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Less<'t> {
    pub le: Token<'t>, /* le */
    pub less_opt: Option<Box<LessOpt<'t>>>,
}

///
/// Type derived for non-terminal LessOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LessOpt<'t> {
    pub dot_token: Box<DotToken<'t>>,
    pub equal: Box<Equal<'t>>,
}

///
/// Type derived for non-terminal Let
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Let<'t> {
    pub identifier_token: Box<IdentifierToken>,
    pub expr: Box<Expr<'t>>,
}

///
/// Type derived for non-terminal Line
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Line {
    pub elements: Box<Elements>,
    pub line_opt: Option<Box<LineOpt>>,
}

///
/// Type derived for non-terminal LineOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LineOpt {
    pub label: Box<Label>,
}

///
/// Type derived for non-terminal Link
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Link {
    pub link_content: Box<LinkContent>,
    pub link_group: Box<LinkGroup>,
}

///
/// Type derived for non-terminal LinkContent
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LinkContent {
    pub link_content: crate::token::Token, /* [^>]* */
}

///
/// Type derived for non-terminal LinkGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum LinkGroup {
    RightAngleToken(LinkGroupRightAngleToken),
    RightAngleLeftBracketTokenLinkGroupListRightBracketToken(
        LinkGroupRightAngleLeftBracketTokenLinkGroupListRightBracketToken,
    ),
}

///
/// Type derived for non-terminal LinkGroupList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LinkGroupList {
    pub element: Box<Element>,
}

///
/// Type derived for non-terminal List
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct List {
    pub line: Box<Line>,
    pub list_opt: Option<Box<ListOpt>>,
}

///
/// Type derived for non-terminal ListExpr
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ListExpr<'t> {
    pub expr: Box<Expr<'t>>,
    pub list_expr_list: Vec<ListExprList<'t>>,
}

///
/// Type derived for non-terminal ListExprList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ListExprList<'t> {
    pub expr: Box<Expr<'t>>,
}

///
/// Type derived for non-terminal ListOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ListOpt {
    pub list: Box<List>,
}

///
/// Type derived for non-terminal Logical
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Logical<'t> {
    And(LogicalAnd<'t>),
    Or(LogicalOr<'t>),
    Not(LogicalNot<'t>),
    ForAll(LogicalForAll<'t>),
    Exists(LogicalExists<'t>),
    Tack(LogicalTack<'t>),
}

///
/// Type derived for non-terminal Makro
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Makro<'t> {
    pub identifier_token: Box<IdentifierToken>,
    pub makro_opt: Option<Box<MakroOpt>>,
    pub expr: Box<Expr<'t>>,
}

///
/// Type derived for non-terminal MakroOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MakroOpt {
    pub ident_list: Box<IdentList>,
}

///
/// Type derived for non-terminal MarkBlock
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum MarkBlock {
    Heading(MarkBlockHeading),
    Paragraph(MarkBlockParagraph),
    List(MarkBlockList),
    OrderedList(MarkBlockOrderedList),
    Table(MarkBlockTable),
    Blockquote(MarkBlockBlockquote),
}

///
/// Type derived for non-terminal MathBlock
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MathBlock<'t> {
    pub sigil_token: Box<SigilToken<'t>>,
    pub formular: Box<Formular<'t>>,
    pub sigil_token0: Box<SigilToken<'t>>,
}

///
/// Type derived for non-terminal Minus
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Minus<'t> {
    Minus(MinusMinus<'t>),
    MinusToken(MinusMinusToken<'t>),
}

///
/// Type derived for non-terminal MinusToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MinusToken<'t> {
    pub minus_token: Token<'t>, /* - */
}

///
/// Type derived for non-terminal Monospace
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Monospace {
    pub monospace_list: Vec<MonospaceList>,
}

///
/// Type derived for non-terminal MonospaceContent
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MonospaceContent {
    pub monospace_content: crate::token::Token, /* [^`]+ */
}

///
/// Type derived for non-terminal MonospaceList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MonospaceList {
    pub monospace_content: Box<MonospaceContent>,
}

///
/// Type derived for non-terminal Mu
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Mu<'t> {
    Mu(MuMu<'t>),
    Mu0(MuMu0<'t>),
}

///
/// Type derived for non-terminal Multiplication
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Multiplication<'t> {
    pub factor: Box<Factor<'t>>,
    pub multiplication_list: Vec<MultiplicationList<'t>>,
}

///
/// Type derived for non-terminal MultiplicationList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MultiplicationList<'t> {
    pub multiplication_list_group: Box<MultiplicationListGroup<'t>>,
    pub factor: Box<Factor<'t>>,
}

///
/// Type derived for non-terminal MultiplicationListGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum MultiplicationListGroup<'t> {
    SlashToken(MultiplicationListGroupSlashToken<'t>),
    AsteriskToken(MultiplicationListGroupAsteriskToken<'t>),
    PercentToken(MultiplicationListGroupPercentToken<'t>),
}

///
/// Type derived for non-terminal Negation
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Negation<'t> {
    pub negation_opt: Option<Box<NegationOpt<'t>>>,
    pub relation: Box<Relation<'t>>,
}

///
/// Type derived for non-terminal NegationOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct NegationOpt<'t> {
    pub exclam_token: Box<ExclamToken<'t>>,
}

///
/// Type derived for non-terminal NewBlock
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct NewBlock<'t> {
    pub new_block_list: Vec<NewBlockList>,
    pub block: Box<Block<'t>>,
}

///
/// Type derived for non-terminal NewBlockList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct NewBlockList {}

///
/// Type derived for non-terminal NewLine
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct NewLine<'t> {
    pub new_line: Token<'t>, /* \n */
}

///
/// Type derived for non-terminal Not
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Not<'t> {
    pub not: Token<'t>, /* not */
}

///
/// Type derived for non-terminal Nu
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Nu<'t> {
    Nu(NuNu<'t>),
    Nu0(NuNu0<'t>),
}

///
/// Type derived for non-terminal Number
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Number<'t> {
    pub digits_token: Box<DigitsToken<'t>>,
    pub number_opt: Option<Box<NumberOpt<'t>>>,
}

///
/// Type derived for non-terminal NumberOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct NumberOpt<'t> {
    pub dot_token: Box<DotToken<'t>>,
    pub digits_token: Box<DigitsToken<'t>>,
}

///
/// Type derived for non-terminal Omega
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Omega<'t> {
    Omega(OmegaOmega<'t>),
    Omega0(OmegaOmega0<'t>),
}

///
/// Type derived for non-terminal Omicron
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Omicron<'t> {
    Omicron(OmicronOmicron<'t>),
    Omicron0(OmicronOmicron0<'t>),
}

///
/// Type derived for non-terminal Operation
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Operation<'t> {
    Logical(OperationLogical<'t>),
    Relation(OperationRelation<'t>),
    Attach(OperationAttach<'t>),
    Plus(OperationPlus<'t>),
    Minus(OperationMinus<'t>),
    Frac(OperationFrac<'t>),
    Times(OperationTimes<'t>),
}

///
/// Type derived for non-terminal Or
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Or<'t> {
    pub or: Token<'t>, /* or */
}

///
/// Type derived for non-terminal OrderedList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct OrderedList {
    pub line: Box<Line>,
    pub ordered_list_opt: Option<Box<OrderedListOpt>>,
}

///
/// Type derived for non-terminal OrderedListOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct OrderedListOpt {
    pub ordered_list: Box<OrderedList>,
}

///
/// Type derived for non-terminal Paragraph
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Paragraph {
    pub line: Box<Line>,
    pub paragraph_opt: Option<Box<ParagraphOpt>>,
}

///
/// Type derived for non-terminal ParagraphOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ParagraphOpt {
    pub paragraph: Box<Paragraph>,
}

///
/// Type derived for non-terminal PercentToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PercentToken<'t> {
    pub percent_token: Token<'t>, /* % */
}

///
/// Type derived for non-terminal Phi
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Phi<'t> {
    Phi(PhiPhi<'t>),
    Phi0(PhiPhi0<'t>),
}

///
/// Type derived for non-terminal Pi
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Pi<'t> {
    Pi(PiPi<'t>),
    Pi0(PiPi0<'t>),
    Product(PiProduct<'t>),
}

///
/// Type derived for non-terminal PipeDoubleToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PipeDoubleToken<'t> {
    pub pipe_double_token: Token<'t>, /* || */
}

///
/// Type derived for non-terminal PipeToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PipeToken<'t> {
    pub pipe_token: Token<'t>, /* | */
}

///
/// Type derived for non-terminal Plus
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Plus<'t> {
    Plus(PlusPlus<'t>),
    PlusToken(PlusPlusToken<'t>),
}

///
/// Type derived for non-terminal PlusToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PlusToken<'t> {
    pub plus_token: Token<'t>, /* + */
}

///
/// Type derived for non-terminal Primary
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Primary<'t> {
    LeftParenTokenDisjunctionRightParenToken(PrimaryLeftParenTokenDisjunctionRightParenToken<'t>),
    Value(PrimaryValue<'t>),
}

///
/// Type derived for non-terminal Prop
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Prop<'t> {
    pub prop: Token<'t>, /* prop */
}

///
/// Type derived for non-terminal Psi
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Psi<'t> {
    Psi(PsiPsi<'t>),
    Psi0(PsiPsi0<'t>),
}

///
/// Type derived for non-terminal Quote
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Quote {
    pub quote_list: Vec<QuoteList>,
}

///
/// Type derived for non-terminal QuoteList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct QuoteList {
    pub quote_list_group: Box<QuoteListGroup>,
}

///
/// Type derived for non-terminal QuoteListGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum QuoteListGroup {
    WordToken(QuoteListGroupWordToken),
    Emphasis(QuoteListGroupEmphasis),
    Strong(QuoteListGroupStrong),
    Strikethrough(QuoteListGroupStrikethrough),
}

///
/// Type derived for non-terminal RawBlock
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RawBlock {
    pub raw_block_opt: Option<Box<RawBlockOpt>>,
    pub raw_text: Box<RawText>,
}

///
/// Type derived for non-terminal RawBlockOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RawBlockOpt {
    pub word_token: Box<WordToken>,
}

///
/// Type derived for non-terminal RawText
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RawText {
    pub raw_text: crate::token::Token, /* ([^`]|\n)+ */
}

///
/// Type derived for non-terminal Relation
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Relation<'t> {
    SummationRelationOpt(RelationSummationRelationOpt<'t>),
    Equal(RelationEqual<'t>),
    Identical(RelationIdentical<'t>),
    Approx(RelationApprox<'t>),
    Prop(RelationProp<'t>),
    Less(RelationLess<'t>),
    Greater(RelationGreater<'t>),
    In(RelationIn<'t>),
    Subset(RelationSubset<'t>),
    Supset(RelationSupset<'t>),
}

///
/// Type derived for non-terminal RelationOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RelationOpt<'t> {
    pub relation_opt_group: Box<RelationOptGroup<'t>>,
    pub summation: Box<Summation<'t>>,
}

///
/// Type derived for non-terminal RelationOptGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum RelationOptGroup<'t> {
    EquDoubleToken(RelationOptGroupEquDoubleToken<'t>),
    ExclamEquToken(RelationOptGroupExclamEquToken<'t>),
    LeftAngleToken(RelationOptGroupLeftAngleToken<'t>),
    LeftAngleEquToken(RelationOptGroupLeftAngleEquToken<'t>),
    RightAngleToken(RelationOptGroupRightAngleToken<'t>),
    RightAngleEquToken(RelationOptGroupRightAngleEquToken<'t>),
}

///
/// Type derived for non-terminal Rho
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Rho<'t> {
    Rho(RhoRho<'t>),
    Rho0(RhoRho0<'t>),
}

///
/// Type derived for non-terminal Right
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Right<'t> {
    pub right: Token<'t>, /* right */
}

///
/// Type derived for non-terminal RightAngleEquToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RightAngleEquToken<'t> {
    pub right_angle_equ_token: Token<'t>, /* >= */
}

///
/// Type derived for non-terminal RightAngleLeftBracketToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RightAngleLeftBracketToken<'t> {
    pub right_angle_left_bracket_token: Token<'t>, /* >[ */
}

///
/// Type derived for non-terminal RightAngleToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RightAngleToken<'t> {
    pub right_angle_token: Token<'t>, /* > */
}

///
/// Type derived for non-terminal RightBraceToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RightBraceToken<'t> {
    pub right_brace_token: Token<'t>, /* } */
}

///
/// Type derived for non-terminal RightBracketToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RightBracketToken<'t> {
    pub right_bracket_token: Token<'t>, /* ] */
}

///
/// Type derived for non-terminal RightParenLeftBracketToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RightParenLeftBracketToken<'t> {
    pub right_paren_left_bracket_token: Token<'t>, /* )[ */
}

///
/// Type derived for non-terminal RightParenToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RightParenToken<'t> {
    pub right_paren_token: Token<'t>, /* ) */
}

///
/// Type derived for non-terminal SigilToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SigilToken<'t> {
    pub sigil_token: Token<'t>, /* $ */
}

///
/// Type derived for non-terminal Sigma
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Sigma<'t> {
    Sigma(SigmaSigma<'t>),
    Sigma0(SigmaSigma0<'t>),
    Sum(SigmaSum<'t>),
}

///
/// Type derived for non-terminal SlashToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SlashToken<'t> {
    pub slash_token: Token<'t>, /* / */
}

///
/// Type derived for non-terminal Strikethrough
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Strikethrough {
    pub strikethrough_list: Vec<StrikethroughList>,
}

///
/// Type derived for non-terminal StrikethroughList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StrikethroughList {
    pub strikethrough_list_group: Box<StrikethroughListGroup>,
}

///
/// Type derived for non-terminal StrikethroughListGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum StrikethroughListGroup {
    WordToken(StrikethroughListGroupWordToken),
    Emphasis(StrikethroughListGroupEmphasis),
    Strong(StrikethroughListGroupStrong),
}

///
/// Type derived for non-terminal String
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct String {
    pub string_content: Box<StringContent>,
}

///
/// Type derived for non-terminal StringContent
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StringContent {
    pub string_content: crate::token::Token, /* [^"]* */
}

///
/// Type derived for non-terminal Strong
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Strong {
    pub strong_list: Vec<StrongList>,
}

///
/// Type derived for non-terminal StrongList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StrongList {
    pub strong_list_group: Box<StrongListGroup>,
}

///
/// Type derived for non-terminal StrongListGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum StrongListGroup {
    WordToken(StrongListGroupWordToken),
    Emphasis(StrongListGroupEmphasis),
}

///
/// Type derived for non-terminal Subscript
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Subscript {
    pub element: Box<Element>,
}

///
/// Type derived for non-terminal Subset
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Subset<'t> {
    pub subset: Token<'t>, /* subset */
    pub subset_opt: Option<Box<SubsetOpt<'t>>>,
}

///
/// Type derived for non-terminal SubsetOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SubsetOpt<'t> {
    pub dot_token: Box<DotToken<'t>>,
    pub subset_opt_group: Box<SubsetOptGroup<'t>>,
}

///
/// Type derived for non-terminal SubsetOptGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum SubsetOptGroup<'t> {
    Not(SubsetOptGroupNot<'t>),
    Equal(SubsetOptGroupEqual<'t>),
}

///
/// Type derived for non-terminal Summation
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Summation<'t> {
    pub multiplication: Box<Multiplication<'t>>,
    pub summation_list: Vec<SummationList<'t>>,
}

///
/// Type derived for non-terminal SummationList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SummationList<'t> {
    pub summation_list_group: Box<SummationListGroup<'t>>,
    pub multiplication: Box<Multiplication<'t>>,
}

///
/// Type derived for non-terminal SummationListGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum SummationListGroup<'t> {
    PlusToken(SummationListGroupPlusToken<'t>),
    MinusToken(SummationListGroupMinusToken<'t>),
}

///
/// Type derived for non-terminal Supscript
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Supscript {
    pub element: Box<Element>,
}

///
/// Type derived for non-terminal Supset
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Supset<'t> {
    pub supset: Token<'t>, /* supset */
    pub supset_opt: Option<Box<SupsetOpt<'t>>>,
}

///
/// Type derived for non-terminal SupsetOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SupsetOpt<'t> {
    pub dot_token: Box<DotToken<'t>>,
    pub supset_opt_group: Box<SupsetOptGroup<'t>>,
}

///
/// Type derived for non-terminal SupsetOptGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum SupsetOptGroup<'t> {
    Not(SupsetOptGroupNot<'t>),
    Equal(SupsetOptGroupEqual<'t>),
}

///
/// Type derived for non-terminal Symbol
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Symbol<'t> {
    Greek(SymbolGreek<'t>),
    Variable(SymbolVariable<'t>),
    DoubleStruck(SymbolDoubleStruck<'t>),
    Operation(SymbolOperation<'t>),
}

///
/// Type derived for non-terminal Table
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Table {
    pub table_list: Vec<TableList>,
    pub table_opt: Option<Box<TableOpt>>,
}

///
/// Type derived for non-terminal TableList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TableList {
    pub elements: Box<Elements>,
}

///
/// Type derived for non-terminal TableOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TableOpt {
    pub table: Box<Table>,
}

///
/// Type derived for non-terminal Tack
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Tack<'t> {
    pub tack: Token<'t>, /* tack */
    pub tack_opt: Option<Box<TackOpt<'t>>>,
}

///
/// Type derived for non-terminal TackOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TackOpt<'t> {
    pub dot_token: Box<DotToken<'t>>,
    pub tack_opt_group: Box<TackOptGroup<'t>>,
}

///
/// Type derived for non-terminal TackOptGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum TackOptGroup<'t> {
    Left(TackOptGroupLeft<'t>),
    Right(TackOptGroupRight<'t>),
    Top(TackOptGroupTop<'t>),
    Bot(TackOptGroupBot<'t>),
}

///
/// Type derived for non-terminal Tau
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Tau<'t> {
    Tau(TauTau<'t>),
    Tau0(TauTau0<'t>),
}

///
/// Type derived for non-terminal Theta
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Theta<'t> {
    Theta(ThetaTheta<'t>),
    Theta0(ThetaTheta0<'t>),
}

///
/// Type derived for non-terminal TildeToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TildeToken<'t> {
    pub tilde_token: Token<'t>, /* ~ */
}

///
/// Type derived for non-terminal Times
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Times<'t> {
    Times(TimesTimes<'t>),
    AsteriskToken(TimesAsteriskToken<'t>),
}

///
/// Type derived for non-terminal Top
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Top<'t> {
    pub top: Token<'t>, /* top */
}

///
/// Type derived for non-terminal TypeDown
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TypeDown<'t> {
    pub type_down_list: Vec<TypeDownList>,
    pub block: Box<Block<'t>>,
    pub type_down_list0: Vec<TypeDownList0<'t>>,
}

///
/// Type derived for non-terminal TypeDownList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TypeDownList {}

///
/// Type derived for non-terminal TypeDownList0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TypeDownList0<'t> {
    pub new_block: Box<NewBlock<'t>>,
}

///
/// Type derived for non-terminal UnderscoreDoubleToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct UnderscoreDoubleToken<'t> {
    pub underscore_double_token: Token<'t>, /* __ */
}

///
/// Type derived for non-terminal UnderscoreToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct UnderscoreToken<'t> {
    pub underscore_token: Token<'t>, /* _ */
}

///
/// Type derived for non-terminal Upsilon
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Upsilon<'t> {
    Upsilon(UpsilonUpsilon<'t>),
    Upsilon0(UpsilonUpsilon0<'t>),
}

///
/// Type derived for non-terminal Value
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Value<'t> {
    Access(ValueAccess<'t>),
    String(ValueString),
    Number(ValueNumber<'t>),
    Bool(ValueBool<'t>),
}

///
/// Type derived for non-terminal ValueExpr
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ValueExpr<'t> {
    Disjunction(ValueExprDisjunction<'t>),
    Content(ValueExprContent<'t>),
}

///
/// Type derived for non-terminal Variable
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Variable<'t> {
    pub variable: Token<'t>, /* [a-zA-Z] */
}

///
/// Type derived for non-terminal WordToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct WordToken {
    pub word_token: crate::token::Token, /* [A-Za-z0-9\.\,\:\;\&\=\+\-\(\)\']+ */
}

///
/// Type derived for non-terminal Xi
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Xi<'t> {
    Xi(XiXi<'t>),
    Xi0(XiXi0<'t>),
}

///
/// Type derived for non-terminal Zeta
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Zeta<'t> {
    Zeta(ZetaZeta<'t>),
    Zeta0(ZetaZeta0<'t>),
}

// -------------------------------------------------------------------------------------------------

///
/// Deduced ASTType of expanded grammar
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ASTType<'t> {
    Access(Access<'t>),
    AccessOpt(Option<Box<AccessOpt<'t>>>),
    Alpha(Alpha<'t>),
    AmperDoubleToken(AmperDoubleToken<'t>),
    And(And<'t>),
    Approx(Approx<'t>),
    ApproxOpt(Option<Box<ApproxOpt<'t>>>),
    Arg(Arg<'t>),
    ArgOpt(Option<Box<ArgOpt<'t>>>),
    ArgOptGroup(ArgOptGroup<'t>),
    Args(Args<'t>),
    ArgsList(Vec<ArgsList<'t>>),
    AsteriskToken(AsteriskToken<'t>),
    AtToken(AtToken<'t>),
    Attach(Attach<'t>),
    BackslashToken(BackslashToken<'t>),
    BacktickToken(BacktickToken<'t>),
    BacktickTripleToken(BacktickTripleToken<'t>),
    Beta(Beta<'t>),
    Block(Block<'t>),
    Blockquote(Blockquote),
    BlockquoteOpt(Option<Box<BlockquoteOpt>>),
    BlockquoteSign(BlockquoteSign<'t>),
    BlockquoteSignList(Vec<BlockquoteSignList<'t>>),
    Bool(Bool<'t>),
    Bot(Bot<'t>),
    Call(Call<'t>),
    CallGroup(CallGroup<'t>),
    CallOpt(Option<Box<CallOpt<'t>>>),
    CaretToken(CaretToken<'t>),
    Chi(Chi<'t>),
    CodeBlock(CodeBlock<'t>),
    ColonToken(ColonToken<'t>),
    CommaToken(CommaToken<'t>),
    Conjunction(Conjunction<'t>),
    ConjunctionList(Vec<ConjunctionList<'t>>),
    Content(Content<'t>),
    ContentTail(ContentTail<'t>),
    ContentTailGroup(ContentTailGroup<'t>),
    ControlExpr(ControlExpr<'t>),
    Delta(Delta<'t>),
    DigitsToken(DigitsToken<'t>),
    Disjunction(Disjunction<'t>),
    DisjunctionList(Vec<DisjunctionList<'t>>),
    DotToken(DotToken<'t>),
    DoubleQuoteToken(DoubleQuoteToken<'t>),
    DoubleStruck(DoubleStruck<'t>),
    Element(Element),
    ElementList(Vec<ElementList>),
    Elements(Elements),
    ElementsList(Vec<ElementsList>),
    Emphasis(Emphasis),
    EmphasisList(Vec<EmphasisList>),
    Epsilon(Epsilon<'t>),
    EquDoubleToken(EquDoubleToken<'t>),
    EquToken(EquToken<'t>),
    Equal(Equal<'t>),
    EqualOpt(Option<Box<EqualOpt<'t>>>),
    Escape(Escape),
    Eta(Eta<'t>),
    ExclamEquToken(ExclamEquToken<'t>),
    ExclamToken(ExclamToken<'t>),
    Exists(Exists<'t>),
    Expr(Expr<'t>),
    Factor(Factor<'t>),
    For(For<'t>),
    ForAll(ForAll<'t>),
    ForGroup(ForGroup<'t>),
    Format(Format),
    Formular(Formular<'t>),
    Frac(Frac<'t>),
    Gamma(Gamma<'t>),
    Greater(Greater<'t>),
    GreaterOpt(Option<Box<GreaterOpt<'t>>>),
    Greek(Greek<'t>),
    HashToken(HashToken<'t>),
    Heading(Heading),
    HeadingSign(HeadingSign<'t>),
    HeadingSignList(Vec<HeadingSignList<'t>>),
    IdentList(IdentList),
    IdentListList(Vec<IdentListList>),
    Identical(Identical<'t>),
    IdenticalOpt(Option<Box<IdenticalOpt<'t>>>),
    IdentifierToken(IdentifierToken),
    IfElse(IfElse<'t>),
    IfElseGroup(IfElseGroup<'t>),
    IfElseGroup0(IfElseGroup0<'t>),
    In(In<'t>),
    InOpt(Option<Box<InOpt<'t>>>),
    Iota(Iota<'t>),
    Iterable(Iterable<'t>),
    Kappa(Kappa<'t>),
    KwElse(KwElse<'t>),
    KwFalse(KwFalse<'t>),
    KwFor(KwFor<'t>),
    KwIf(KwIf<'t>),
    KwIn(KwIn<'t>),
    KwLet(KwLet<'t>),
    KwMakro(KwMakro<'t>),
    KwTrue(KwTrue<'t>),
    Label(Label),
    Lambda(Lambda<'t>),
    Left(Left<'t>),
    LeftAngleEquToken(LeftAngleEquToken<'t>),
    LeftAngleToken(LeftAngleToken<'t>),
    LeftBraceToken(LeftBraceToken<'t>),
    LeftBracketToken(LeftBracketToken<'t>),
    LeftParenToken(LeftParenToken<'t>),
    Less(Less<'t>),
    LessOpt(Option<Box<LessOpt<'t>>>),
    Let(Let<'t>),
    Line(Line),
    LineOpt(Option<Box<LineOpt>>),
    Link(Link),
    LinkContent(LinkContent),
    LinkGroup(LinkGroup),
    LinkGroupList(Vec<LinkGroupList>),
    List(List),
    ListExpr(ListExpr<'t>),
    ListExprList(Vec<ListExprList<'t>>),
    ListOpt(Option<Box<ListOpt>>),
    Logical(Logical<'t>),
    Makro(Makro<'t>),
    MakroOpt(Option<Box<MakroOpt>>),
    MarkBlock(MarkBlock),
    MathBlock(MathBlock<'t>),
    Minus(Minus<'t>),
    MinusToken(MinusToken<'t>),
    Monospace(Monospace),
    MonospaceContent(MonospaceContent),
    MonospaceList(Vec<MonospaceList>),
    Mu(Mu<'t>),
    Multiplication(Multiplication<'t>),
    MultiplicationList(Vec<MultiplicationList<'t>>),
    MultiplicationListGroup(MultiplicationListGroup<'t>),
    Negation(Negation<'t>),
    NegationOpt(Option<Box<NegationOpt<'t>>>),
    NewBlock(NewBlock<'t>),
    NewBlockList(Vec<NewBlockList>),
    NewLine(NewLine<'t>),
    Not(Not<'t>),
    Nu(Nu<'t>),
    Number(Number<'t>),
    NumberOpt(Option<Box<NumberOpt<'t>>>),
    Omega(Omega<'t>),
    Omicron(Omicron<'t>),
    Operation(Operation<'t>),
    Or(Or<'t>),
    OrderedList(OrderedList),
    OrderedListOpt(Option<Box<OrderedListOpt>>),
    Paragraph(Paragraph),
    ParagraphOpt(Option<Box<ParagraphOpt>>),
    PercentToken(PercentToken<'t>),
    Phi(Phi<'t>),
    Pi(Pi<'t>),
    PipeDoubleToken(PipeDoubleToken<'t>),
    PipeToken(PipeToken<'t>),
    Plus(Plus<'t>),
    PlusToken(PlusToken<'t>),
    Primary(Primary<'t>),
    Prop(Prop<'t>),
    Psi(Psi<'t>),
    Quote(Quote),
    QuoteList(Vec<QuoteList>),
    QuoteListGroup(QuoteListGroup),
    RawBlock(RawBlock),
    RawBlockOpt(Option<Box<RawBlockOpt>>),
    RawText(RawText),
    Relation(Relation<'t>),
    RelationOpt(Option<Box<RelationOpt<'t>>>),
    RelationOptGroup(RelationOptGroup<'t>),
    Rho(Rho<'t>),
    Right(Right<'t>),
    RightAngleEquToken(RightAngleEquToken<'t>),
    RightAngleLeftBracketToken(RightAngleLeftBracketToken<'t>),
    RightAngleToken(RightAngleToken<'t>),
    RightBraceToken(RightBraceToken<'t>),
    RightBracketToken(RightBracketToken<'t>),
    RightParenLeftBracketToken(RightParenLeftBracketToken<'t>),
    RightParenToken(RightParenToken<'t>),
    SigilToken(SigilToken<'t>),
    Sigma(Sigma<'t>),
    SlashToken(SlashToken<'t>),
    Strikethrough(Strikethrough),
    StrikethroughList(Vec<StrikethroughList>),
    StrikethroughListGroup(StrikethroughListGroup),
    String(String),
    StringContent(StringContent),
    Strong(Strong),
    StrongList(Vec<StrongList>),
    StrongListGroup(StrongListGroup),
    Subscript(Subscript),
    Subset(Subset<'t>),
    SubsetOpt(Option<Box<SubsetOpt<'t>>>),
    SubsetOptGroup(SubsetOptGroup<'t>),
    Summation(Summation<'t>),
    SummationList(Vec<SummationList<'t>>),
    SummationListGroup(SummationListGroup<'t>),
    Supscript(Supscript),
    Supset(Supset<'t>),
    SupsetOpt(Option<Box<SupsetOpt<'t>>>),
    SupsetOptGroup(SupsetOptGroup<'t>),
    Symbol(Symbol<'t>),
    Table(Table),
    TableList(Vec<TableList>),
    TableOpt(Option<Box<TableOpt>>),
    Tack(Tack<'t>),
    TackOpt(Option<Box<TackOpt<'t>>>),
    TackOptGroup(TackOptGroup<'t>),
    Tau(Tau<'t>),
    Theta(Theta<'t>),
    TildeToken(TildeToken<'t>),
    Times(Times<'t>),
    Top(Top<'t>),
    TypeDown(TypeDown<'t>),
    TypeDownList(Vec<TypeDownList>),
    TypeDownList0(Vec<TypeDownList0<'t>>),
    UnderscoreDoubleToken(UnderscoreDoubleToken<'t>),
    UnderscoreToken(UnderscoreToken<'t>),
    Upsilon(Upsilon<'t>),
    Value(Value<'t>),
    ValueExpr(ValueExpr<'t>),
    Variable(Variable<'t>),
    WordToken(WordToken),
    Xi(Xi<'t>),
    Zeta(Zeta<'t>),
}

/// Auto-implemented adapter grammar
///
/// The lifetime parameter `'t` refers to the lifetime of the scanned text.
/// The lifetime parameter `'u` refers to the lifetime of user grammar object.
///
#[allow(dead_code)]
pub struct GrammarAuto<'t, 'u>
where
    't: 'u,
{
    // Mutable reference of the actual user grammar to be able to call the semantic actions on it
    user_grammar: &'u mut dyn GrammarTrait<'t>,
    // Stack to construct the AST on it
    item_stack: Vec<ASTType<'t>>,
}

///
/// The `GrammarAuto` impl is automatically generated for the
/// given grammar.
///
impl<'t, 'u> GrammarAuto<'t, 'u> {
    pub fn new(user_grammar: &'u mut dyn GrammarTrait<'t>) -> Self {
        Self {
            user_grammar,
            item_stack: Vec::new(),
        }
    }

    #[allow(dead_code)]
    fn push(&mut self, item: ASTType<'t>, context: &str) {
        trace!("push    {}: {:?}", context, item);
        self.item_stack.push(item)
    }

    #[allow(dead_code)]
    fn pop(&mut self, context: &str) -> Option<ASTType<'t>> {
        let item = self.item_stack.pop();
        if let Some(ref item) = item {
            trace!("pop     {}: {:?}", context, item);
        }
        item
    }

    #[allow(dead_code)]
    // Use this function for debugging purposes:
    // trace!("{}", self.trace_item_stack(context));
    fn trace_item_stack(&self, context: &str) -> std::string::String {
        format!(
            "Item stack at {}:\n{}",
            context,
            self.item_stack
                .iter()
                .rev()
                .map(|s| format!("  {:?}", s))
                .collect::<Vec<std::string::String>>()
                .join("\n")
        )
    }

    /// Semantic action for production 0:
    ///
    /// TypeDown: TypeDownList /* Vec */ Block TypeDownList0 /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn type_down(
        &mut self,
        _type_down_list: &ParseTreeType<'t>,
        _block: &ParseTreeType<'t>,
        _type_down_list0: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let type_down_list0 = pop_and_reverse_item!(self, type_down_list0, TypeDownList0, context);
        let block = pop_item!(self, block, Block, context);
        let type_down_list = pop_and_reverse_item!(self, type_down_list, TypeDownList, context);
        let type_down_built = TypeDown {
            type_down_list,
            block: Box::new(block),
            type_down_list0,
        };
        // Calling user action here
        self.user_grammar.type_down(&type_down_built)?;
        self.push(ASTType::TypeDown(type_down_built), context);
        Ok(())
    }

    /// Semantic action for production 1:
    ///
    /// TypeDownList0 /* `Vec<T>::Push` */: NewBlock TypeDownList0;
    ///
    #[parol_runtime::function_name::named]
    fn type_down_list0_0(
        &mut self,
        _new_block: &ParseTreeType<'t>,
        _type_down_list0: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut type_down_list0 = pop_item!(self, type_down_list0, TypeDownList0, context);
        let new_block = pop_item!(self, new_block, NewBlock, context);
        let type_down_list0_0_built = TypeDownList0 {
            new_block: Box::new(new_block),
        };
        // Add an element to the vector
        type_down_list0.push(type_down_list0_0_built);
        self.push(ASTType::TypeDownList0(type_down_list0), context);
        Ok(())
    }

    /// Semantic action for production 2:
    ///
    /// TypeDownList0 /* `Vec<T>::New` */: ;
    ///
    #[parol_runtime::function_name::named]
    fn type_down_list0_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let type_down_list0_1_built = Vec::new();
        self.push(ASTType::TypeDownList0(type_down_list0_1_built), context);
        Ok(())
    }

    /// Semantic action for production 3:
    ///
    /// TypeDownList /* `Vec<T>::Push` */: NewLine^ /* Clipped */ TypeDownList;
    ///
    #[parol_runtime::function_name::named]
    fn type_down_list_0(
        &mut self,
        _new_line: &ParseTreeType<'t>,
        _type_down_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut type_down_list = pop_item!(self, type_down_list, TypeDownList, context);
        // Ignore clipped member 'new_line'
        self.pop(context);
        let type_down_list_0_built = TypeDownList {
        // Ignore clipped member 'new_line'
        };
        // Add an element to the vector
        type_down_list.push(type_down_list_0_built);
        self.push(ASTType::TypeDownList(type_down_list), context);
        Ok(())
    }

    /// Semantic action for production 4:
    ///
    /// TypeDownList /* `Vec<T>::New` */: ;
    ///
    #[parol_runtime::function_name::named]
    fn type_down_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let type_down_list_1_built = Vec::new();
        self.push(ASTType::TypeDownList(type_down_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 5:
    ///
    /// Block: RawBlock;
    ///
    #[parol_runtime::function_name::named]
    fn block_0(&mut self, _raw_block: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let raw_block = pop_item!(self, raw_block, RawBlock, context);
        let block_0_built = BlockRawBlock {
            raw_block: Box::new(raw_block),
        };
        let block_0_built = Block::RawBlock(block_0_built);
        // Calling user action here
        self.user_grammar.block(&block_0_built)?;
        self.push(ASTType::Block(block_0_built), context);
        Ok(())
    }

    /// Semantic action for production 6:
    ///
    /// Block: MarkBlock;
    ///
    #[parol_runtime::function_name::named]
    fn block_1(&mut self, _mark_block: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mark_block = pop_item!(self, mark_block, MarkBlock, context);
        let block_1_built = BlockMarkBlock {
            mark_block: Box::new(mark_block),
        };
        let block_1_built = Block::MarkBlock(block_1_built);
        // Calling user action here
        self.user_grammar.block(&block_1_built)?;
        self.push(ASTType::Block(block_1_built), context);
        Ok(())
    }

    /// Semantic action for production 7:
    ///
    /// Block: CodeBlock;
    ///
    #[parol_runtime::function_name::named]
    fn block_2(&mut self, _code_block: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let code_block = pop_item!(self, code_block, CodeBlock, context);
        let block_2_built = BlockCodeBlock {
            code_block: Box::new(code_block),
        };
        let block_2_built = Block::CodeBlock(block_2_built);
        // Calling user action here
        self.user_grammar.block(&block_2_built)?;
        self.push(ASTType::Block(block_2_built), context);
        Ok(())
    }

    /// Semantic action for production 8:
    ///
    /// Block: MathBlock;
    ///
    #[parol_runtime::function_name::named]
    fn block_3(&mut self, _math_block: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let math_block = pop_item!(self, math_block, MathBlock, context);
        let block_3_built = BlockMathBlock {
            math_block: Box::new(math_block),
        };
        let block_3_built = Block::MathBlock(block_3_built);
        // Calling user action here
        self.user_grammar.block(&block_3_built)?;
        self.push(ASTType::Block(block_3_built), context);
        Ok(())
    }

    /// Semantic action for production 9:
    ///
    /// NewBlock: NewLine^ /* Clipped */ NewBlockList /* Vec */ Block;
    ///
    #[parol_runtime::function_name::named]
    fn new_block(
        &mut self,
        _new_line: &ParseTreeType<'t>,
        _new_block_list: &ParseTreeType<'t>,
        _block: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let block = pop_item!(self, block, Block, context);
        let new_block_list = pop_and_reverse_item!(self, new_block_list, NewBlockList, context);
        // Ignore clipped member 'new_line'
        self.pop(context);
        let new_block_built = NewBlock {
            // Ignore clipped member 'new_line'
            new_block_list,
            block: Box::new(block),
        };
        // Calling user action here
        self.user_grammar.new_block(&new_block_built)?;
        self.push(ASTType::NewBlock(new_block_built), context);
        Ok(())
    }

    /// Semantic action for production 10:
    ///
    /// NewBlockList /* `Vec<T>::Push` */: NewLine^ /* Clipped */ NewBlockList;
    ///
    #[parol_runtime::function_name::named]
    fn new_block_list_0(
        &mut self,
        _new_line: &ParseTreeType<'t>,
        _new_block_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut new_block_list = pop_item!(self, new_block_list, NewBlockList, context);
        // Ignore clipped member 'new_line'
        self.pop(context);
        let new_block_list_0_built = NewBlockList {
        // Ignore clipped member 'new_line'
        };
        // Add an element to the vector
        new_block_list.push(new_block_list_0_built);
        self.push(ASTType::NewBlockList(new_block_list), context);
        Ok(())
    }

    /// Semantic action for production 11:
    ///
    /// NewBlockList /* `Vec<T>::New` */: ;
    ///
    #[parol_runtime::function_name::named]
    fn new_block_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let new_block_list_1_built = Vec::new();
        self.push(ASTType::NewBlockList(new_block_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 12:
    ///
    /// String: DoubleQuoteToken^ /* Clipped */ %push(String) StringContent %pop() DoubleQuoteToken^ /* Clipped */;
    ///
    #[parol_runtime::function_name::named]
    fn string(
        &mut self,
        _double_quote_token: &ParseTreeType<'t>,
        _string_content: &ParseTreeType<'t>,
        _double_quote_token0: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        // Ignore clipped member 'double_quote_token0'
        self.pop(context);
        let string_content = pop_item!(self, string_content, StringContent, context);
        // Ignore clipped member 'double_quote_token'
        self.pop(context);
        let string_built = String {
            // Ignore clipped member 'double_quote_token'
            string_content: Box::new(string_content),
            // Ignore clipped member 'double_quote_token0'
        };
        // Calling user action here
        self.user_grammar.string(&string_built)?;
        self.push(ASTType::String(string_built), context);
        Ok(())
    }

    /// Semantic action for production 13:
    ///
    /// StringContent: <String>/[^"]*/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn string_content(&mut self, string_content: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let string_content = string_content
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let string_content_built = StringContent { string_content };
        // Calling user action here
        self.user_grammar.string_content(&string_content_built)?;
        self.push(ASTType::StringContent(string_content_built), context);
        Ok(())
    }

    /// Semantic action for production 14:
    ///
    /// MarkBlock: Heading;
    ///
    #[parol_runtime::function_name::named]
    fn mark_block_0(&mut self, _heading: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let heading = pop_item!(self, heading, Heading, context);
        let mark_block_0_built = MarkBlockHeading {
            heading: Box::new(heading),
        };
        let mark_block_0_built = MarkBlock::Heading(mark_block_0_built);
        // Calling user action here
        self.user_grammar.mark_block(&mark_block_0_built)?;
        self.push(ASTType::MarkBlock(mark_block_0_built), context);
        Ok(())
    }

    /// Semantic action for production 15:
    ///
    /// MarkBlock: Paragraph;
    ///
    #[parol_runtime::function_name::named]
    fn mark_block_1(&mut self, _paragraph: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let paragraph = pop_item!(self, paragraph, Paragraph, context);
        let mark_block_1_built = MarkBlockParagraph {
            paragraph: Box::new(paragraph),
        };
        let mark_block_1_built = MarkBlock::Paragraph(mark_block_1_built);
        // Calling user action here
        self.user_grammar.mark_block(&mark_block_1_built)?;
        self.push(ASTType::MarkBlock(mark_block_1_built), context);
        Ok(())
    }

    /// Semantic action for production 16:
    ///
    /// MarkBlock: List;
    ///
    #[parol_runtime::function_name::named]
    fn mark_block_2(&mut self, _list: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let list = pop_item!(self, list, List, context);
        let mark_block_2_built = MarkBlockList {
            list: Box::new(list),
        };
        let mark_block_2_built = MarkBlock::List(mark_block_2_built);
        // Calling user action here
        self.user_grammar.mark_block(&mark_block_2_built)?;
        self.push(ASTType::MarkBlock(mark_block_2_built), context);
        Ok(())
    }

    /// Semantic action for production 17:
    ///
    /// MarkBlock: OrderedList;
    ///
    #[parol_runtime::function_name::named]
    fn mark_block_3(&mut self, _ordered_list: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ordered_list = pop_item!(self, ordered_list, OrderedList, context);
        let mark_block_3_built = MarkBlockOrderedList {
            ordered_list: Box::new(ordered_list),
        };
        let mark_block_3_built = MarkBlock::OrderedList(mark_block_3_built);
        // Calling user action here
        self.user_grammar.mark_block(&mark_block_3_built)?;
        self.push(ASTType::MarkBlock(mark_block_3_built), context);
        Ok(())
    }

    /// Semantic action for production 18:
    ///
    /// MarkBlock: Table;
    ///
    #[parol_runtime::function_name::named]
    fn mark_block_4(&mut self, _table: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let table = pop_item!(self, table, Table, context);
        let mark_block_4_built = MarkBlockTable {
            table: Box::new(table),
        };
        let mark_block_4_built = MarkBlock::Table(mark_block_4_built);
        // Calling user action here
        self.user_grammar.mark_block(&mark_block_4_built)?;
        self.push(ASTType::MarkBlock(mark_block_4_built), context);
        Ok(())
    }

    /// Semantic action for production 19:
    ///
    /// MarkBlock: Blockquote;
    ///
    #[parol_runtime::function_name::named]
    fn mark_block_5(&mut self, _blockquote: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let blockquote = pop_item!(self, blockquote, Blockquote, context);
        let mark_block_5_built = MarkBlockBlockquote {
            blockquote: Box::new(blockquote),
        };
        let mark_block_5_built = MarkBlock::Blockquote(mark_block_5_built);
        // Calling user action here
        self.user_grammar.mark_block(&mark_block_5_built)?;
        self.push(ASTType::MarkBlock(mark_block_5_built), context);
        Ok(())
    }

    /// Semantic action for production 20:
    ///
    /// HeadingSign: EquToken HeadingSignList /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn heading_sign(
        &mut self,
        _equ_token: &ParseTreeType<'t>,
        _heading_sign_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let heading_sign_list =
            pop_and_reverse_item!(self, heading_sign_list, HeadingSignList, context);
        let equ_token = pop_item!(self, equ_token, EquToken, context);
        let heading_sign_built = HeadingSign {
            equ_token: Box::new(equ_token),
            heading_sign_list,
        };
        // Calling user action here
        self.user_grammar.heading_sign(&heading_sign_built)?;
        self.push(ASTType::HeadingSign(heading_sign_built), context);
        Ok(())
    }

    /// Semantic action for production 21:
    ///
    /// HeadingSignList /* `Vec<T>::Push` */: EquToken HeadingSignList;
    ///
    #[parol_runtime::function_name::named]
    fn heading_sign_list_0(
        &mut self,
        _equ_token: &ParseTreeType<'t>,
        _heading_sign_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut heading_sign_list = pop_item!(self, heading_sign_list, HeadingSignList, context);
        let equ_token = pop_item!(self, equ_token, EquToken, context);
        let heading_sign_list_0_built = HeadingSignList {
            equ_token: Box::new(equ_token),
        };
        // Add an element to the vector
        heading_sign_list.push(heading_sign_list_0_built);
        self.push(ASTType::HeadingSignList(heading_sign_list), context);
        Ok(())
    }

    /// Semantic action for production 22:
    ///
    /// HeadingSignList /* `Vec<T>::New` */: ;
    ///
    #[parol_runtime::function_name::named]
    fn heading_sign_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let heading_sign_list_1_built = Vec::new();
        self.push(ASTType::HeadingSignList(heading_sign_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 23:
    ///
    /// Heading: HeadingSign : HeadingLevel Line;
    ///
    #[parol_runtime::function_name::named]
    fn heading(
        &mut self,
        _heading_sign: &ParseTreeType<'t>,
        _line: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let line = pop_item!(self, line, Line, context);
        let heading_sign = pop_item!(self, heading_sign, HeadingSign, context);
        let heading_built = Heading {
            heading_sign: (&heading_sign)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            line: Box::new(line),
        };
        // Calling user action here
        self.user_grammar.heading(&heading_built)?;
        self.push(ASTType::Heading(heading_built), context);
        Ok(())
    }

    /// Semantic action for production 24:
    ///
    /// Paragraph: Line ParagraphOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn paragraph(
        &mut self,
        _line: &ParseTreeType<'t>,
        _paragraph_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let paragraph_opt = pop_item!(self, paragraph_opt, ParagraphOpt, context);
        let line = pop_item!(self, line, Line, context);
        let paragraph_built = Paragraph {
            line: Box::new(line),
            paragraph_opt,
        };
        // Calling user action here
        self.user_grammar.paragraph(&paragraph_built)?;
        self.push(ASTType::Paragraph(paragraph_built), context);
        Ok(())
    }

    /// Semantic action for production 25:
    ///
    /// ParagraphOpt /* `Option<T>::Some` */: Paragraph;
    ///
    #[parol_runtime::function_name::named]
    fn paragraph_opt_0(&mut self, _paragraph: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let paragraph = pop_item!(self, paragraph, Paragraph, context);
        let paragraph_opt_0_built = ParagraphOpt {
            paragraph: Box::new(paragraph),
        };
        self.push(
            ASTType::ParagraphOpt(Some(Box::new(paragraph_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 26:
    ///
    /// ParagraphOpt /* `Option<T>::None` */: ;
    ///
    #[parol_runtime::function_name::named]
    fn paragraph_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ParagraphOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 27:
    ///
    /// List: MinusToken^ /* Clipped */ Line ListOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn list(
        &mut self,
        _minus_token: &ParseTreeType<'t>,
        _line: &ParseTreeType<'t>,
        _list_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let list_opt = pop_item!(self, list_opt, ListOpt, context);
        let line = pop_item!(self, line, Line, context);
        // Ignore clipped member 'minus_token'
        self.pop(context);
        let list_built = List {
            // Ignore clipped member 'minus_token'
            line: Box::new(line),
            list_opt,
        };
        // Calling user action here
        self.user_grammar.list(&list_built)?;
        self.push(ASTType::List(list_built), context);
        Ok(())
    }

    /// Semantic action for production 28:
    ///
    /// ListOpt /* `Option<T>::Some` */: List;
    ///
    #[parol_runtime::function_name::named]
    fn list_opt_0(&mut self, _list: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let list = pop_item!(self, list, List, context);
        let list_opt_0_built = ListOpt {
            list: Box::new(list),
        };
        self.push(ASTType::ListOpt(Some(Box::new(list_opt_0_built))), context);
        Ok(())
    }

    /// Semantic action for production 29:
    ///
    /// ListOpt /* `Option<T>::None` */: ;
    ///
    #[parol_runtime::function_name::named]
    fn list_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ListOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 30:
    ///
    /// OrderedList: PlusToken^ /* Clipped */ Line OrderedListOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn ordered_list(
        &mut self,
        _plus_token: &ParseTreeType<'t>,
        _line: &ParseTreeType<'t>,
        _ordered_list_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ordered_list_opt = pop_item!(self, ordered_list_opt, OrderedListOpt, context);
        let line = pop_item!(self, line, Line, context);
        // Ignore clipped member 'plus_token'
        self.pop(context);
        let ordered_list_built = OrderedList {
            // Ignore clipped member 'plus_token'
            line: Box::new(line),
            ordered_list_opt,
        };
        // Calling user action here
        self.user_grammar.ordered_list(&ordered_list_built)?;
        self.push(ASTType::OrderedList(ordered_list_built), context);
        Ok(())
    }

    /// Semantic action for production 31:
    ///
    /// OrderedListOpt /* `Option<T>::Some` */: OrderedList;
    ///
    #[parol_runtime::function_name::named]
    fn ordered_list_opt_0(&mut self, _ordered_list: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ordered_list = pop_item!(self, ordered_list, OrderedList, context);
        let ordered_list_opt_0_built = OrderedListOpt {
            ordered_list: Box::new(ordered_list),
        };
        self.push(
            ASTType::OrderedListOpt(Some(Box::new(ordered_list_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 32:
    ///
    /// OrderedListOpt /* `Option<T>::None` */: ;
    ///
    #[parol_runtime::function_name::named]
    fn ordered_list_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::OrderedListOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 33:
    ///
    /// Table: PipeToken^ /* Clipped */ TableList /* Vec */ NewLine^ /* Clipped */ TableOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn table(
        &mut self,
        _pipe_token: &ParseTreeType<'t>,
        _table_list: &ParseTreeType<'t>,
        _new_line: &ParseTreeType<'t>,
        _table_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let table_opt = pop_item!(self, table_opt, TableOpt, context);
        // Ignore clipped member 'new_line'
        self.pop(context);
        let table_list = pop_and_reverse_item!(self, table_list, TableList, context);
        // Ignore clipped member 'pipe_token'
        self.pop(context);
        let table_built = Table {
            // Ignore clipped member 'pipe_token'
            table_list,
            // Ignore clipped member 'new_line'
            table_opt,
        };
        // Calling user action here
        self.user_grammar.table(&table_built)?;
        self.push(ASTType::Table(table_built), context);
        Ok(())
    }

    /// Semantic action for production 34:
    ///
    /// TableList /* `Vec<T>::Push` */: Elements PipeToken^ /* Clipped */ TableList;
    ///
    #[parol_runtime::function_name::named]
    fn table_list_0(
        &mut self,
        _elements: &ParseTreeType<'t>,
        _pipe_token: &ParseTreeType<'t>,
        _table_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut table_list = pop_item!(self, table_list, TableList, context);
        // Ignore clipped member 'pipe_token'
        self.pop(context);
        let elements = pop_item!(self, elements, Elements, context);
        let table_list_0_built = TableList {
            // Ignore clipped member 'pipe_token'
            elements: Box::new(elements),
        };
        // Add an element to the vector
        table_list.push(table_list_0_built);
        self.push(ASTType::TableList(table_list), context);
        Ok(())
    }

    /// Semantic action for production 35:
    ///
    /// TableList /* `Vec<T>::New` */: ;
    ///
    #[parol_runtime::function_name::named]
    fn table_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let table_list_1_built = Vec::new();
        self.push(ASTType::TableList(table_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 36:
    ///
    /// TableOpt /* `Option<T>::Some` */: Table;
    ///
    #[parol_runtime::function_name::named]
    fn table_opt_0(&mut self, _table: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let table = pop_item!(self, table, Table, context);
        let table_opt_0_built = TableOpt {
            table: Box::new(table),
        };
        self.push(
            ASTType::TableOpt(Some(Box::new(table_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 37:
    ///
    /// TableOpt /* `Option<T>::None` */: ;
    ///
    #[parol_runtime::function_name::named]
    fn table_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::TableOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 38:
    ///
    /// BlockquoteSign: RightAngleToken BlockquoteSignList /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn blockquote_sign(
        &mut self,
        _right_angle_token: &ParseTreeType<'t>,
        _blockquote_sign_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let blockquote_sign_list =
            pop_and_reverse_item!(self, blockquote_sign_list, BlockquoteSignList, context);
        let right_angle_token = pop_item!(self, right_angle_token, RightAngleToken, context);
        let blockquote_sign_built = BlockquoteSign {
            right_angle_token: Box::new(right_angle_token),
            blockquote_sign_list,
        };
        // Calling user action here
        self.user_grammar.blockquote_sign(&blockquote_sign_built)?;
        self.push(ASTType::BlockquoteSign(blockquote_sign_built), context);
        Ok(())
    }

    /// Semantic action for production 39:
    ///
    /// BlockquoteSignList /* `Vec<T>::Push` */: RightAngleToken BlockquoteSignList;
    ///
    #[parol_runtime::function_name::named]
    fn blockquote_sign_list_0(
        &mut self,
        _right_angle_token: &ParseTreeType<'t>,
        _blockquote_sign_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut blockquote_sign_list =
            pop_item!(self, blockquote_sign_list, BlockquoteSignList, context);
        let right_angle_token = pop_item!(self, right_angle_token, RightAngleToken, context);
        let blockquote_sign_list_0_built = BlockquoteSignList {
            right_angle_token: Box::new(right_angle_token),
        };
        // Add an element to the vector
        blockquote_sign_list.push(blockquote_sign_list_0_built);
        self.push(ASTType::BlockquoteSignList(blockquote_sign_list), context);
        Ok(())
    }

    /// Semantic action for production 40:
    ///
    /// BlockquoteSignList /* `Vec<T>::New` */: ;
    ///
    #[parol_runtime::function_name::named]
    fn blockquote_sign_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let blockquote_sign_list_1_built = Vec::new();
        self.push(
            ASTType::BlockquoteSignList(blockquote_sign_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 41:
    ///
    /// Blockquote: BlockquoteSign : BlockquoteLevel Line BlockquoteOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn blockquote(
        &mut self,
        _blockquote_sign: &ParseTreeType<'t>,
        _line: &ParseTreeType<'t>,
        _blockquote_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let blockquote_opt = pop_item!(self, blockquote_opt, BlockquoteOpt, context);
        let line = pop_item!(self, line, Line, context);
        let blockquote_sign = pop_item!(self, blockquote_sign, BlockquoteSign, context);
        let blockquote_built = Blockquote {
            blockquote_sign: (&blockquote_sign)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            line: Box::new(line),
            blockquote_opt,
        };
        // Calling user action here
        self.user_grammar.blockquote(&blockquote_built)?;
        self.push(ASTType::Blockquote(blockquote_built), context);
        Ok(())
    }

    /// Semantic action for production 42:
    ///
    /// BlockquoteOpt /* `Option<T>::Some` */: Blockquote;
    ///
    #[parol_runtime::function_name::named]
    fn blockquote_opt_0(&mut self, _blockquote: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let blockquote = pop_item!(self, blockquote, Blockquote, context);
        let blockquote_opt_0_built = BlockquoteOpt {
            blockquote: Box::new(blockquote),
        };
        self.push(
            ASTType::BlockquoteOpt(Some(Box::new(blockquote_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 43:
    ///
    /// BlockquoteOpt /* `Option<T>::None` */: ;
    ///
    #[parol_runtime::function_name::named]
    fn blockquote_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::BlockquoteOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 44:
    ///
    /// Label: AtToken^ /* Clipped */ %push(Code) IdentifierToken %pop();
    ///
    #[parol_runtime::function_name::named]
    fn label(
        &mut self,
        _at_token: &ParseTreeType<'t>,
        _identifier_token: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let identifier_token = pop_item!(self, identifier_token, IdentifierToken, context);
        // Ignore clipped member 'at_token'
        self.pop(context);
        let label_built = Label {
            // Ignore clipped member 'at_token'
            identifier_token: Box::new(identifier_token),
        };
        // Calling user action here
        self.user_grammar.label(&label_built)?;
        self.push(ASTType::Label(label_built), context);
        Ok(())
    }

    /// Semantic action for production 45:
    ///
    /// Line: Elements LineOpt /* Option */ NewLine^ /* Clipped */;
    ///
    #[parol_runtime::function_name::named]
    fn line(
        &mut self,
        _elements: &ParseTreeType<'t>,
        _line_opt: &ParseTreeType<'t>,
        _new_line: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        // Ignore clipped member 'new_line'
        self.pop(context);
        let line_opt = pop_item!(self, line_opt, LineOpt, context);
        let elements = pop_item!(self, elements, Elements, context);
        let line_built = Line {
            elements: Box::new(elements),
            line_opt,
            // Ignore clipped member 'new_line'
        };
        // Calling user action here
        self.user_grammar.line(&line_built)?;
        self.push(ASTType::Line(line_built), context);
        Ok(())
    }

    /// Semantic action for production 46:
    ///
    /// LineOpt /* `Option<T>::Some` */: Label;
    ///
    #[parol_runtime::function_name::named]
    fn line_opt_0(&mut self, _label: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let label = pop_item!(self, label, Label, context);
        let line_opt_0_built = LineOpt {
            label: Box::new(label),
        };
        self.push(ASTType::LineOpt(Some(Box::new(line_opt_0_built))), context);
        Ok(())
    }

    /// Semantic action for production 47:
    ///
    /// LineOpt /* `Option<T>::None` */: ;
    ///
    #[parol_runtime::function_name::named]
    fn line_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::LineOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 48:
    ///
    /// Elements: Element ElementsList /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn elements(
        &mut self,
        _element: &ParseTreeType<'t>,
        _elements_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let elements_list = pop_and_reverse_item!(self, elements_list, ElementsList, context);
        let element = pop_item!(self, element, Element, context);
        let elements_built = Elements {
            element: Box::new(element),
            elements_list,
        };
        // Calling user action here
        self.user_grammar.elements(&elements_built)?;
        self.push(ASTType::Elements(elements_built), context);
        Ok(())
    }

    /// Semantic action for production 49:
    ///
    /// ElementsList /* `Vec<T>::Push` */: Element ElementsList;
    ///
    #[parol_runtime::function_name::named]
    fn elements_list_0(
        &mut self,
        _element: &ParseTreeType<'t>,
        _elements_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut elements_list = pop_item!(self, elements_list, ElementsList, context);
        let element = pop_item!(self, element, Element, context);
        let elements_list_0_built = ElementsList {
            element: Box::new(element),
        };
        // Add an element to the vector
        elements_list.push(elements_list_0_built);
        self.push(ASTType::ElementsList(elements_list), context);
        Ok(())
    }

    /// Semantic action for production 50:
    ///
    /// ElementsList /* `Vec<T>::New` */: ;
    ///
    #[parol_runtime::function_name::named]
    fn elements_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let elements_list_1_built = Vec::new();
        self.push(ASTType::ElementsList(elements_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 51:
    ///
    /// Element: WordToken;
    ///
    #[parol_runtime::function_name::named]
    fn element_0(&mut self, _word_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_token = pop_item!(self, word_token, WordToken, context);
        let element_0_built = ElementWordToken {
            word_token: Box::new(word_token),
        };
        let element_0_built = Element::WordToken(element_0_built);
        // Calling user action here
        self.user_grammar.element(&element_0_built)?;
        self.push(ASTType::Element(element_0_built), context);
        Ok(())
    }

    /// Semantic action for production 52:
    ///
    /// Element: Format;
    ///
    #[parol_runtime::function_name::named]
    fn element_1(&mut self, _format: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let format = pop_item!(self, format, Format, context);
        let element_1_built = ElementFormat {
            format: Box::new(format),
        };
        let element_1_built = Element::Format(element_1_built);
        // Calling user action here
        self.user_grammar.element(&element_1_built)?;
        self.push(ASTType::Element(element_1_built), context);
        Ok(())
    }

    /// Semantic action for production 53:
    ///
    /// Element: Link;
    ///
    #[parol_runtime::function_name::named]
    fn element_2(&mut self, _link: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let link = pop_item!(self, link, Link, context);
        let element_2_built = ElementLink {
            link: Box::new(link),
        };
        let element_2_built = Element::Link(element_2_built);
        // Calling user action here
        self.user_grammar.element(&element_2_built)?;
        self.push(ASTType::Element(element_2_built), context);
        Ok(())
    }

    /// Semantic action for production 54:
    ///
    /// Element: Escape;
    ///
    #[parol_runtime::function_name::named]
    fn element_3(&mut self, _escape: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let escape = pop_item!(self, escape, Escape, context);
        let element_3_built = ElementEscape {
            escape: Box::new(escape),
        };
        let element_3_built = Element::Escape(element_3_built);
        // Calling user action here
        self.user_grammar.element(&element_3_built)?;
        self.push(ASTType::Element(element_3_built), context);
        Ok(())
    }

    /// Semantic action for production 55:
    ///
    /// Element: Subscript;
    ///
    #[parol_runtime::function_name::named]
    fn element_4(&mut self, _subscript: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let subscript = pop_item!(self, subscript, Subscript, context);
        let element_4_built = ElementSubscript {
            subscript: Box::new(subscript),
        };
        let element_4_built = Element::Subscript(element_4_built);
        // Calling user action here
        self.user_grammar.element(&element_4_built)?;
        self.push(ASTType::Element(element_4_built), context);
        Ok(())
    }

    /// Semantic action for production 56:
    ///
    /// Element: Supscript;
    ///
    #[parol_runtime::function_name::named]
    fn element_5(&mut self, _supscript: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let supscript = pop_item!(self, supscript, Supscript, context);
        let element_5_built = ElementSupscript {
            supscript: Box::new(supscript),
        };
        let element_5_built = Element::Supscript(element_5_built);
        // Calling user action here
        self.user_grammar.element(&element_5_built)?;
        self.push(ASTType::Element(element_5_built), context);
        Ok(())
    }

    /// Semantic action for production 57:
    ///
    /// Element: Monospace;
    ///
    #[parol_runtime::function_name::named]
    fn element_6(&mut self, _monospace: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let monospace = pop_item!(self, monospace, Monospace, context);
        let element_6_built = ElementMonospace {
            monospace: Box::new(monospace),
        };
        let element_6_built = Element::Monospace(element_6_built);
        // Calling user action here
        self.user_grammar.element(&element_6_built)?;
        self.push(ASTType::Element(element_6_built), context);
        Ok(())
    }

    /// Semantic action for production 58:
    ///
    /// Element: LeftBracketToken^ /* Clipped */ ElementList /* Vec */ RightBracketToken^ /* Clipped */;
    ///
    #[parol_runtime::function_name::named]
    fn element_7(
        &mut self,
        _left_bracket_token: &ParseTreeType<'t>,
        _element_list: &ParseTreeType<'t>,
        _right_bracket_token: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        // Ignore clipped member 'right_bracket_token'
        self.pop(context);
        let element_list = pop_and_reverse_item!(self, element_list, ElementList, context);
        // Ignore clipped member 'left_bracket_token'
        self.pop(context);
        let element_7_built = ElementLeftBracketTokenElementListRightBracketToken {
            // Ignore clipped member 'left_bracket_token'
            element_list,
            // Ignore clipped member 'right_bracket_token'
        };
        let element_7_built =
            Element::LeftBracketTokenElementListRightBracketToken(element_7_built);
        // Calling user action here
        self.user_grammar.element(&element_7_built)?;
        self.push(ASTType::Element(element_7_built), context);
        Ok(())
    }

    /// Semantic action for production 59:
    ///
    /// ElementList /* `Vec<T>::Push` */: Element ElementList;
    ///
    #[parol_runtime::function_name::named]
    fn element_list_0(
        &mut self,
        _element: &ParseTreeType<'t>,
        _element_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut element_list = pop_item!(self, element_list, ElementList, context);
        let element = pop_item!(self, element, Element, context);
        let element_list_0_built = ElementList {
            element: Box::new(element),
        };
        // Add an element to the vector
        element_list.push(element_list_0_built);
        self.push(ASTType::ElementList(element_list), context);
        Ok(())
    }

    /// Semantic action for production 60:
    ///
    /// ElementList /* `Vec<T>::New` */: ;
    ///
    #[parol_runtime::function_name::named]
    fn element_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let element_list_1_built = Vec::new();
        self.push(ASTType::ElementList(element_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 61:
    ///
    /// LinkContent: <Link>/[^>]*/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn link_content(&mut self, link_content: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let link_content = link_content
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let link_content_built = LinkContent { link_content };
        // Calling user action here
        self.user_grammar.link_content(&link_content_built)?;
        self.push(ASTType::LinkContent(link_content_built), context);
        Ok(())
    }

    /// Semantic action for production 62:
    ///
    /// Link: LeftAngleToken^ /* Clipped */ %push(Link) LinkContent %pop() LinkGroup;
    ///
    #[parol_runtime::function_name::named]
    fn link(
        &mut self,
        _left_angle_token: &ParseTreeType<'t>,
        _link_content: &ParseTreeType<'t>,
        _link_group: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let link_group = pop_item!(self, link_group, LinkGroup, context);
        let link_content = pop_item!(self, link_content, LinkContent, context);
        // Ignore clipped member 'left_angle_token'
        self.pop(context);
        let link_built = Link {
            // Ignore clipped member 'left_angle_token'
            link_content: Box::new(link_content),
            link_group: Box::new(link_group),
        };
        // Calling user action here
        self.user_grammar.link(&link_built)?;
        self.push(ASTType::Link(link_built), context);
        Ok(())
    }

    /// Semantic action for production 63:
    ///
    /// LinkGroup: RightAngleToken^ /* Clipped */;
    ///
    #[parol_runtime::function_name::named]
    fn link_group_0(&mut self, _right_angle_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        // Ignore clipped member 'right_angle_token'
        self.pop(context);
        let link_group_0_built = LinkGroupRightAngleToken {
        // Ignore clipped member 'right_angle_token'
        };
        let link_group_0_built = LinkGroup::RightAngleToken(link_group_0_built);
        self.push(ASTType::LinkGroup(link_group_0_built), context);
        Ok(())
    }

    /// Semantic action for production 64:
    ///
    /// LinkGroup: RightAngleLeftBracketToken^ /* Clipped */ LinkGroupList /* Vec */ RightBracketToken^ /* Clipped */;
    ///
    #[parol_runtime::function_name::named]
    fn link_group_1(
        &mut self,
        _right_angle_left_bracket_token: &ParseTreeType<'t>,
        _link_group_list: &ParseTreeType<'t>,
        _right_bracket_token: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        // Ignore clipped member 'right_bracket_token'
        self.pop(context);
        let link_group_list = pop_and_reverse_item!(self, link_group_list, LinkGroupList, context);
        // Ignore clipped member 'right_angle_left_bracket_token'
        self.pop(context);
        let link_group_1_built =
            LinkGroupRightAngleLeftBracketTokenLinkGroupListRightBracketToken {
                // Ignore clipped member 'right_angle_left_bracket_token'
                link_group_list,
                // Ignore clipped member 'right_bracket_token'
            };
        let link_group_1_built =
            LinkGroup::RightAngleLeftBracketTokenLinkGroupListRightBracketToken(link_group_1_built);
        self.push(ASTType::LinkGroup(link_group_1_built), context);
        Ok(())
    }

    /// Semantic action for production 65:
    ///
    /// LinkGroupList /* `Vec<T>::Push` */: Element LinkGroupList;
    ///
    #[parol_runtime::function_name::named]
    fn link_group_list_0(
        &mut self,
        _element: &ParseTreeType<'t>,
        _link_group_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut link_group_list = pop_item!(self, link_group_list, LinkGroupList, context);
        let element = pop_item!(self, element, Element, context);
        let link_group_list_0_built = LinkGroupList {
            element: Box::new(element),
        };
        // Add an element to the vector
        link_group_list.push(link_group_list_0_built);
        self.push(ASTType::LinkGroupList(link_group_list), context);
        Ok(())
    }

    /// Semantic action for production 66:
    ///
    /// LinkGroupList /* `Vec<T>::New` */: ;
    ///
    #[parol_runtime::function_name::named]
    fn link_group_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let link_group_list_1_built = Vec::new();
        self.push(ASTType::LinkGroupList(link_group_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 67:
    ///
    /// Escape: BackslashToken^ /* Clipped */ %push(Escape) <Escape>/[\#\\]/ : Token %pop();
    ///
    #[parol_runtime::function_name::named]
    fn escape(
        &mut self,
        _backslash_token: &ParseTreeType<'t>,
        l_bracket_hash_r_bracket: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_bracket_hash_r_bracket = l_bracket_hash_r_bracket
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        // Ignore clipped member 'backslash_token'
        self.pop(context);
        let escape_built = Escape {
            // Ignore clipped member 'backslash_token'
            l_bracket_hash_r_bracket,
        };
        // Calling user action here
        self.user_grammar.escape(&escape_built)?;
        self.push(ASTType::Escape(escape_built), context);
        Ok(())
    }

    /// Semantic action for production 68:
    ///
    /// Monospace: BacktickToken^ /* Clipped */ %push(Monospace) MonospaceList /* Vec */ %pop() BacktickToken^ /* Clipped */;
    ///
    #[parol_runtime::function_name::named]
    fn monospace(
        &mut self,
        _backtick_token: &ParseTreeType<'t>,
        _monospace_list: &ParseTreeType<'t>,
        _backtick_token0: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        // Ignore clipped member 'backtick_token0'
        self.pop(context);
        let monospace_list = pop_and_reverse_item!(self, monospace_list, MonospaceList, context);
        // Ignore clipped member 'backtick_token'
        self.pop(context);
        let monospace_built = Monospace {
            // Ignore clipped member 'backtick_token'
            monospace_list,
            // Ignore clipped member 'backtick_token0'
        };
        // Calling user action here
        self.user_grammar.monospace(&monospace_built)?;
        self.push(ASTType::Monospace(monospace_built), context);
        Ok(())
    }

    /// Semantic action for production 69:
    ///
    /// MonospaceList /* `Vec<T>::Push` */: MonospaceContent MonospaceList;
    ///
    #[parol_runtime::function_name::named]
    fn monospace_list_0(
        &mut self,
        _monospace_content: &ParseTreeType<'t>,
        _monospace_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut monospace_list = pop_item!(self, monospace_list, MonospaceList, context);
        let monospace_content = pop_item!(self, monospace_content, MonospaceContent, context);
        let monospace_list_0_built = MonospaceList {
            monospace_content: Box::new(monospace_content),
        };
        // Add an element to the vector
        monospace_list.push(monospace_list_0_built);
        self.push(ASTType::MonospaceList(monospace_list), context);
        Ok(())
    }

    /// Semantic action for production 70:
    ///
    /// MonospaceList /* `Vec<T>::New` */: ;
    ///
    #[parol_runtime::function_name::named]
    fn monospace_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let monospace_list_1_built = Vec::new();
        self.push(ASTType::MonospaceList(monospace_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 71:
    ///
    /// MonospaceContent: <Monospace>/[^`]+/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn monospace_content(&mut self, monospace_content: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let monospace_content = monospace_content
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let monospace_content_built = MonospaceContent { monospace_content };
        // Calling user action here
        self.user_grammar
            .monospace_content(&monospace_content_built)?;
        self.push(ASTType::MonospaceContent(monospace_content_built), context);
        Ok(())
    }

    /// Semantic action for production 72:
    ///
    /// Subscript: UnderscoreDoubleToken^ /* Clipped */ Element;
    ///
    #[parol_runtime::function_name::named]
    fn subscript(
        &mut self,
        _underscore_double_token: &ParseTreeType<'t>,
        _element: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let element = pop_item!(self, element, Element, context);
        // Ignore clipped member 'underscore_double_token'
        self.pop(context);
        let subscript_built = Subscript {
            // Ignore clipped member 'underscore_double_token'
            element: Box::new(element),
        };
        // Calling user action here
        self.user_grammar.subscript(&subscript_built)?;
        self.push(ASTType::Subscript(subscript_built), context);
        Ok(())
    }

    /// Semantic action for production 73:
    ///
    /// Supscript: CaretToken^ /* Clipped */ Element;
    ///
    #[parol_runtime::function_name::named]
    fn supscript(
        &mut self,
        _caret_token: &ParseTreeType<'t>,
        _element: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let element = pop_item!(self, element, Element, context);
        // Ignore clipped member 'caret_token'
        self.pop(context);
        let supscript_built = Supscript {
            // Ignore clipped member 'caret_token'
            element: Box::new(element),
        };
        // Calling user action here
        self.user_grammar.supscript(&supscript_built)?;
        self.push(ASTType::Supscript(supscript_built), context);
        Ok(())
    }

    /// Semantic action for production 74:
    ///
    /// Format: Emphasis;
    ///
    #[parol_runtime::function_name::named]
    fn format_0(&mut self, _emphasis: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let emphasis = pop_item!(self, emphasis, Emphasis, context);
        let format_0_built = FormatEmphasis {
            emphasis: Box::new(emphasis),
        };
        let format_0_built = Format::Emphasis(format_0_built);
        // Calling user action here
        self.user_grammar.format(&format_0_built)?;
        self.push(ASTType::Format(format_0_built), context);
        Ok(())
    }

    /// Semantic action for production 75:
    ///
    /// Format: Strong;
    ///
    #[parol_runtime::function_name::named]
    fn format_1(&mut self, _strong: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let strong = pop_item!(self, strong, Strong, context);
        let format_1_built = FormatStrong {
            strong: Box::new(strong),
        };
        let format_1_built = Format::Strong(format_1_built);
        // Calling user action here
        self.user_grammar.format(&format_1_built)?;
        self.push(ASTType::Format(format_1_built), context);
        Ok(())
    }

    /// Semantic action for production 76:
    ///
    /// Format: Strikethrough;
    ///
    #[parol_runtime::function_name::named]
    fn format_2(&mut self, _strikethrough: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let strikethrough = pop_item!(self, strikethrough, Strikethrough, context);
        let format_2_built = FormatStrikethrough {
            strikethrough: Box::new(strikethrough),
        };
        let format_2_built = Format::Strikethrough(format_2_built);
        // Calling user action here
        self.user_grammar.format(&format_2_built)?;
        self.push(ASTType::Format(format_2_built), context);
        Ok(())
    }

    /// Semantic action for production 77:
    ///
    /// Format: Quote;
    ///
    #[parol_runtime::function_name::named]
    fn format_3(&mut self, _quote: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let quote = pop_item!(self, quote, Quote, context);
        let format_3_built = FormatQuote {
            quote: Box::new(quote),
        };
        let format_3_built = Format::Quote(format_3_built);
        // Calling user action here
        self.user_grammar.format(&format_3_built)?;
        self.push(ASTType::Format(format_3_built), context);
        Ok(())
    }

    /// Semantic action for production 78:
    ///
    /// Quote: DoubleQuoteToken^ /* Clipped */ QuoteList /* Vec */ DoubleQuoteToken^ /* Clipped */;
    ///
    #[parol_runtime::function_name::named]
    fn quote(
        &mut self,
        _double_quote_token: &ParseTreeType<'t>,
        _quote_list: &ParseTreeType<'t>,
        _double_quote_token0: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        // Ignore clipped member 'double_quote_token0'
        self.pop(context);
        let quote_list = pop_and_reverse_item!(self, quote_list, QuoteList, context);
        // Ignore clipped member 'double_quote_token'
        self.pop(context);
        let quote_built = Quote {
            // Ignore clipped member 'double_quote_token'
            quote_list,
            // Ignore clipped member 'double_quote_token0'
        };
        // Calling user action here
        self.user_grammar.quote(&quote_built)?;
        self.push(ASTType::Quote(quote_built), context);
        Ok(())
    }

    /// Semantic action for production 79:
    ///
    /// QuoteList /* `Vec<T>::Push` */: QuoteListGroup QuoteList;
    ///
    #[parol_runtime::function_name::named]
    fn quote_list_0(
        &mut self,
        _quote_list_group: &ParseTreeType<'t>,
        _quote_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut quote_list = pop_item!(self, quote_list, QuoteList, context);
        let quote_list_group = pop_item!(self, quote_list_group, QuoteListGroup, context);
        let quote_list_0_built = QuoteList {
            quote_list_group: Box::new(quote_list_group),
        };
        // Add an element to the vector
        quote_list.push(quote_list_0_built);
        self.push(ASTType::QuoteList(quote_list), context);
        Ok(())
    }

    /// Semantic action for production 80:
    ///
    /// QuoteListGroup: WordToken;
    ///
    #[parol_runtime::function_name::named]
    fn quote_list_group_0(&mut self, _word_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_token = pop_item!(self, word_token, WordToken, context);
        let quote_list_group_0_built = QuoteListGroupWordToken {
            word_token: Box::new(word_token),
        };
        let quote_list_group_0_built = QuoteListGroup::WordToken(quote_list_group_0_built);
        self.push(ASTType::QuoteListGroup(quote_list_group_0_built), context);
        Ok(())
    }

    /// Semantic action for production 81:
    ///
    /// QuoteListGroup: Emphasis;
    ///
    #[parol_runtime::function_name::named]
    fn quote_list_group_1(&mut self, _emphasis: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let emphasis = pop_item!(self, emphasis, Emphasis, context);
        let quote_list_group_1_built = QuoteListGroupEmphasis {
            emphasis: Box::new(emphasis),
        };
        let quote_list_group_1_built = QuoteListGroup::Emphasis(quote_list_group_1_built);
        self.push(ASTType::QuoteListGroup(quote_list_group_1_built), context);
        Ok(())
    }

    /// Semantic action for production 82:
    ///
    /// QuoteListGroup: Strong;
    ///
    #[parol_runtime::function_name::named]
    fn quote_list_group_2(&mut self, _strong: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let strong = pop_item!(self, strong, Strong, context);
        let quote_list_group_2_built = QuoteListGroupStrong {
            strong: Box::new(strong),
        };
        let quote_list_group_2_built = QuoteListGroup::Strong(quote_list_group_2_built);
        self.push(ASTType::QuoteListGroup(quote_list_group_2_built), context);
        Ok(())
    }

    /// Semantic action for production 83:
    ///
    /// QuoteListGroup: Strikethrough;
    ///
    #[parol_runtime::function_name::named]
    fn quote_list_group_3(&mut self, _strikethrough: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let strikethrough = pop_item!(self, strikethrough, Strikethrough, context);
        let quote_list_group_3_built = QuoteListGroupStrikethrough {
            strikethrough: Box::new(strikethrough),
        };
        let quote_list_group_3_built = QuoteListGroup::Strikethrough(quote_list_group_3_built);
        self.push(ASTType::QuoteListGroup(quote_list_group_3_built), context);
        Ok(())
    }

    /// Semantic action for production 84:
    ///
    /// QuoteList /* `Vec<T>::New` */: ;
    ///
    #[parol_runtime::function_name::named]
    fn quote_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let quote_list_1_built = Vec::new();
        self.push(ASTType::QuoteList(quote_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 85:
    ///
    /// Strikethrough: TildeToken^ /* Clipped */ StrikethroughList /* Vec */ TildeToken^ /* Clipped */;
    ///
    #[parol_runtime::function_name::named]
    fn strikethrough(
        &mut self,
        _tilde_token: &ParseTreeType<'t>,
        _strikethrough_list: &ParseTreeType<'t>,
        _tilde_token0: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        // Ignore clipped member 'tilde_token0'
        self.pop(context);
        let strikethrough_list =
            pop_and_reverse_item!(self, strikethrough_list, StrikethroughList, context);
        // Ignore clipped member 'tilde_token'
        self.pop(context);
        let strikethrough_built = Strikethrough {
            // Ignore clipped member 'tilde_token'
            strikethrough_list,
            // Ignore clipped member 'tilde_token0'
        };
        // Calling user action here
        self.user_grammar.strikethrough(&strikethrough_built)?;
        self.push(ASTType::Strikethrough(strikethrough_built), context);
        Ok(())
    }

    /// Semantic action for production 86:
    ///
    /// StrikethroughList /* `Vec<T>::Push` */: StrikethroughListGroup StrikethroughList;
    ///
    #[parol_runtime::function_name::named]
    fn strikethrough_list_0(
        &mut self,
        _strikethrough_list_group: &ParseTreeType<'t>,
        _strikethrough_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut strikethrough_list =
            pop_item!(self, strikethrough_list, StrikethroughList, context);
        let strikethrough_list_group = pop_item!(
            self,
            strikethrough_list_group,
            StrikethroughListGroup,
            context
        );
        let strikethrough_list_0_built = StrikethroughList {
            strikethrough_list_group: Box::new(strikethrough_list_group),
        };
        // Add an element to the vector
        strikethrough_list.push(strikethrough_list_0_built);
        self.push(ASTType::StrikethroughList(strikethrough_list), context);
        Ok(())
    }

    /// Semantic action for production 87:
    ///
    /// StrikethroughListGroup: WordToken;
    ///
    #[parol_runtime::function_name::named]
    fn strikethrough_list_group_0(&mut self, _word_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_token = pop_item!(self, word_token, WordToken, context);
        let strikethrough_list_group_0_built = StrikethroughListGroupWordToken {
            word_token: Box::new(word_token),
        };
        let strikethrough_list_group_0_built =
            StrikethroughListGroup::WordToken(strikethrough_list_group_0_built);
        self.push(
            ASTType::StrikethroughListGroup(strikethrough_list_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 88:
    ///
    /// StrikethroughListGroup: Emphasis;
    ///
    #[parol_runtime::function_name::named]
    fn strikethrough_list_group_1(&mut self, _emphasis: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let emphasis = pop_item!(self, emphasis, Emphasis, context);
        let strikethrough_list_group_1_built = StrikethroughListGroupEmphasis {
            emphasis: Box::new(emphasis),
        };
        let strikethrough_list_group_1_built =
            StrikethroughListGroup::Emphasis(strikethrough_list_group_1_built);
        self.push(
            ASTType::StrikethroughListGroup(strikethrough_list_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 89:
    ///
    /// StrikethroughListGroup: Strong;
    ///
    #[parol_runtime::function_name::named]
    fn strikethrough_list_group_2(&mut self, _strong: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let strong = pop_item!(self, strong, Strong, context);
        let strikethrough_list_group_2_built = StrikethroughListGroupStrong {
            strong: Box::new(strong),
        };
        let strikethrough_list_group_2_built =
            StrikethroughListGroup::Strong(strikethrough_list_group_2_built);
        self.push(
            ASTType::StrikethroughListGroup(strikethrough_list_group_2_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 90:
    ///
    /// StrikethroughList /* `Vec<T>::New` */: ;
    ///
    #[parol_runtime::function_name::named]
    fn strikethrough_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let strikethrough_list_1_built = Vec::new();
        self.push(
            ASTType::StrikethroughList(strikethrough_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 91:
    ///
    /// Strong: AsteriskToken^ /* Clipped */ StrongList /* Vec */ AsteriskToken^ /* Clipped */;
    ///
    #[parol_runtime::function_name::named]
    fn strong(
        &mut self,
        _asterisk_token: &ParseTreeType<'t>,
        _strong_list: &ParseTreeType<'t>,
        _asterisk_token0: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        // Ignore clipped member 'asterisk_token0'
        self.pop(context);
        let strong_list = pop_and_reverse_item!(self, strong_list, StrongList, context);
        // Ignore clipped member 'asterisk_token'
        self.pop(context);
        let strong_built = Strong {
            // Ignore clipped member 'asterisk_token'
            strong_list,
            // Ignore clipped member 'asterisk_token0'
        };
        // Calling user action here
        self.user_grammar.strong(&strong_built)?;
        self.push(ASTType::Strong(strong_built), context);
        Ok(())
    }

    /// Semantic action for production 92:
    ///
    /// StrongList /* `Vec<T>::Push` */: StrongListGroup StrongList;
    ///
    #[parol_runtime::function_name::named]
    fn strong_list_0(
        &mut self,
        _strong_list_group: &ParseTreeType<'t>,
        _strong_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut strong_list = pop_item!(self, strong_list, StrongList, context);
        let strong_list_group = pop_item!(self, strong_list_group, StrongListGroup, context);
        let strong_list_0_built = StrongList {
            strong_list_group: Box::new(strong_list_group),
        };
        // Add an element to the vector
        strong_list.push(strong_list_0_built);
        self.push(ASTType::StrongList(strong_list), context);
        Ok(())
    }

    /// Semantic action for production 93:
    ///
    /// StrongListGroup: WordToken;
    ///
    #[parol_runtime::function_name::named]
    fn strong_list_group_0(&mut self, _word_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_token = pop_item!(self, word_token, WordToken, context);
        let strong_list_group_0_built = StrongListGroupWordToken {
            word_token: Box::new(word_token),
        };
        let strong_list_group_0_built = StrongListGroup::WordToken(strong_list_group_0_built);
        self.push(ASTType::StrongListGroup(strong_list_group_0_built), context);
        Ok(())
    }

    /// Semantic action for production 94:
    ///
    /// StrongListGroup: Emphasis;
    ///
    #[parol_runtime::function_name::named]
    fn strong_list_group_1(&mut self, _emphasis: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let emphasis = pop_item!(self, emphasis, Emphasis, context);
        let strong_list_group_1_built = StrongListGroupEmphasis {
            emphasis: Box::new(emphasis),
        };
        let strong_list_group_1_built = StrongListGroup::Emphasis(strong_list_group_1_built);
        self.push(ASTType::StrongListGroup(strong_list_group_1_built), context);
        Ok(())
    }

    /// Semantic action for production 95:
    ///
    /// StrongList /* `Vec<T>::New` */: ;
    ///
    #[parol_runtime::function_name::named]
    fn strong_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let strong_list_1_built = Vec::new();
        self.push(ASTType::StrongList(strong_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 96:
    ///
    /// Emphasis: SlashToken^ /* Clipped */ EmphasisList /* Vec */ SlashToken^ /* Clipped */;
    ///
    #[parol_runtime::function_name::named]
    fn emphasis(
        &mut self,
        _slash_token: &ParseTreeType<'t>,
        _emphasis_list: &ParseTreeType<'t>,
        _slash_token0: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        // Ignore clipped member 'slash_token0'
        self.pop(context);
        let emphasis_list = pop_and_reverse_item!(self, emphasis_list, EmphasisList, context);
        // Ignore clipped member 'slash_token'
        self.pop(context);
        let emphasis_built = Emphasis {
            // Ignore clipped member 'slash_token'
            emphasis_list,
            // Ignore clipped member 'slash_token0'
        };
        // Calling user action here
        self.user_grammar.emphasis(&emphasis_built)?;
        self.push(ASTType::Emphasis(emphasis_built), context);
        Ok(())
    }

    /// Semantic action for production 97:
    ///
    /// EmphasisList /* `Vec<T>::Push` */: WordToken EmphasisList;
    ///
    #[parol_runtime::function_name::named]
    fn emphasis_list_0(
        &mut self,
        _word_token: &ParseTreeType<'t>,
        _emphasis_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut emphasis_list = pop_item!(self, emphasis_list, EmphasisList, context);
        let word_token = pop_item!(self, word_token, WordToken, context);
        let emphasis_list_0_built = EmphasisList {
            word_token: Box::new(word_token),
        };
        // Add an element to the vector
        emphasis_list.push(emphasis_list_0_built);
        self.push(ASTType::EmphasisList(emphasis_list), context);
        Ok(())
    }

    /// Semantic action for production 98:
    ///
    /// EmphasisList /* `Vec<T>::New` */: ;
    ///
    #[parol_runtime::function_name::named]
    fn emphasis_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let emphasis_list_1_built = Vec::new();
        self.push(ASTType::EmphasisList(emphasis_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 99:
    ///
    /// RawBlock: BacktickTripleToken^ /* Clipped */ RawBlockOpt /* Option */ NewLine^ /* Clipped */ %push(Raw) RawText %pop() BacktickTripleToken^ /* Clipped */ NewLine^ /* Clipped */;
    ///
    #[parol_runtime::function_name::named]
    fn raw_block(
        &mut self,
        _backtick_triple_token: &ParseTreeType<'t>,
        _raw_block_opt: &ParseTreeType<'t>,
        _new_line: &ParseTreeType<'t>,
        _raw_text: &ParseTreeType<'t>,
        _backtick_triple_token0: &ParseTreeType<'t>,
        _new_line0: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        // Ignore clipped member 'new_line0'
        self.pop(context);
        // Ignore clipped member 'backtick_triple_token0'
        self.pop(context);
        let raw_text = pop_item!(self, raw_text, RawText, context);
        // Ignore clipped member 'new_line'
        self.pop(context);
        let raw_block_opt = pop_item!(self, raw_block_opt, RawBlockOpt, context);
        // Ignore clipped member 'backtick_triple_token'
        self.pop(context);
        let raw_block_built = RawBlock {
            // Ignore clipped member 'backtick_triple_token'
            raw_block_opt,
            // Ignore clipped member 'new_line'
            raw_text: Box::new(raw_text),
            // Ignore clipped member 'backtick_triple_token0'
            // Ignore clipped member 'new_line0'
        };
        // Calling user action here
        self.user_grammar.raw_block(&raw_block_built)?;
        self.push(ASTType::RawBlock(raw_block_built), context);
        Ok(())
    }

    /// Semantic action for production 100:
    ///
    /// RawBlockOpt /* `Option<T>::Some` */: WordToken;
    ///
    #[parol_runtime::function_name::named]
    fn raw_block_opt_0(&mut self, _word_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_token = pop_item!(self, word_token, WordToken, context);
        let raw_block_opt_0_built = RawBlockOpt {
            word_token: Box::new(word_token),
        };
        self.push(
            ASTType::RawBlockOpt(Some(Box::new(raw_block_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 101:
    ///
    /// RawBlockOpt /* `Option<T>::None` */: ;
    ///
    #[parol_runtime::function_name::named]
    fn raw_block_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::RawBlockOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 102:
    ///
    /// RawText: <Raw>/([^`]|\n)+/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn raw_text(&mut self, raw_text: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let raw_text = raw_text
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let raw_text_built = RawText { raw_text };
        // Calling user action here
        self.user_grammar.raw_text(&raw_text_built)?;
        self.push(ASTType::RawText(raw_text_built), context);
        Ok(())
    }

    /// Semantic action for production 103:
    ///
    /// CodeBlock: HashToken^ /* Clipped */ %push(Code) Expr NewLine^ /* Clipped */ %pop();
    ///
    #[parol_runtime::function_name::named]
    fn code_block(
        &mut self,
        _hash_token: &ParseTreeType<'t>,
        _expr: &ParseTreeType<'t>,
        _new_line: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        // Ignore clipped member 'new_line'
        self.pop(context);
        let expr = pop_item!(self, expr, Expr, context);
        // Ignore clipped member 'hash_token'
        self.pop(context);
        let code_block_built = CodeBlock {
            // Ignore clipped member 'hash_token'
            expr: Box::new(expr),
            // Ignore clipped member 'new_line'
        };
        // Calling user action here
        self.user_grammar.code_block(&code_block_built)?;
        self.push(ASTType::CodeBlock(code_block_built), context);
        Ok(())
    }

    /// Semantic action for production 104:
    ///
    /// Expr: Let;
    ///
    #[parol_runtime::function_name::named]
    fn expr_0(&mut self, _let: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#let = pop_item!(self, r#let, Let, context);
        let expr_0_built = ExprLet {
            r#let: Box::new(r#let),
        };
        let expr_0_built = Expr::Let(expr_0_built);
        // Calling user action here
        self.user_grammar.expr(&expr_0_built)?;
        self.push(ASTType::Expr(expr_0_built), context);
        Ok(())
    }

    /// Semantic action for production 105:
    ///
    /// Expr: Makro;
    ///
    #[parol_runtime::function_name::named]
    fn expr_1(&mut self, _makro: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let makro = pop_item!(self, makro, Makro, context);
        let expr_1_built = ExprMakro {
            makro: Box::new(makro),
        };
        let expr_1_built = Expr::Makro(expr_1_built);
        // Calling user action here
        self.user_grammar.expr(&expr_1_built)?;
        self.push(ASTType::Expr(expr_1_built), context);
        Ok(())
    }

    /// Semantic action for production 106:
    ///
    /// Expr: ControlExpr;
    ///
    #[parol_runtime::function_name::named]
    fn expr_2(&mut self, _control_expr: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let control_expr = pop_item!(self, control_expr, ControlExpr, context);
        let expr_2_built = ExprControlExpr {
            control_expr: Box::new(control_expr),
        };
        let expr_2_built = Expr::ControlExpr(expr_2_built);
        // Calling user action here
        self.user_grammar.expr(&expr_2_built)?;
        self.push(ASTType::Expr(expr_2_built), context);
        Ok(())
    }

    /// Semantic action for production 107:
    ///
    /// Expr: ValueExpr;
    ///
    #[parol_runtime::function_name::named]
    fn expr_3(&mut self, _value_expr: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let value_expr = pop_item!(self, value_expr, ValueExpr, context);
        let expr_3_built = ExprValueExpr {
            value_expr: Box::new(value_expr),
        };
        let expr_3_built = Expr::ValueExpr(expr_3_built);
        // Calling user action here
        self.user_grammar.expr(&expr_3_built)?;
        self.push(ASTType::Expr(expr_3_built), context);
        Ok(())
    }

    /// Semantic action for production 108:
    ///
    /// Expr: ListExpr;
    ///
    #[parol_runtime::function_name::named]
    fn expr_4(&mut self, _list_expr: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let list_expr = pop_item!(self, list_expr, ListExpr, context);
        let expr_4_built = ExprListExpr {
            list_expr: Box::new(list_expr),
        };
        let expr_4_built = Expr::ListExpr(expr_4_built);
        // Calling user action here
        self.user_grammar.expr(&expr_4_built)?;
        self.push(ASTType::Expr(expr_4_built), context);
        Ok(())
    }

    /// Semantic action for production 109:
    ///
    /// ListExpr: LeftBraceToken^ /* Clipped */ NewLine^ /* Clipped */ Expr NewLine^ /* Clipped */ ListExprList /* Vec */ RightBraceToken^ /* Clipped */;
    ///
    #[parol_runtime::function_name::named]
    fn list_expr(
        &mut self,
        _left_brace_token: &ParseTreeType<'t>,
        _new_line: &ParseTreeType<'t>,
        _expr: &ParseTreeType<'t>,
        _new_line0: &ParseTreeType<'t>,
        _list_expr_list: &ParseTreeType<'t>,
        _right_brace_token: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        // Ignore clipped member 'right_brace_token'
        self.pop(context);
        let list_expr_list = pop_and_reverse_item!(self, list_expr_list, ListExprList, context);
        // Ignore clipped member 'new_line0'
        self.pop(context);
        let expr = pop_item!(self, expr, Expr, context);
        // Ignore clipped member 'new_line'
        self.pop(context);
        // Ignore clipped member 'left_brace_token'
        self.pop(context);
        let list_expr_built = ListExpr {
            // Ignore clipped member 'left_brace_token'
            // Ignore clipped member 'new_line'
            expr: Box::new(expr),
            // Ignore clipped member 'new_line0'
            list_expr_list,
            // Ignore clipped member 'right_brace_token'
        };
        // Calling user action here
        self.user_grammar.list_expr(&list_expr_built)?;
        self.push(ASTType::ListExpr(list_expr_built), context);
        Ok(())
    }

    /// Semantic action for production 110:
    ///
    /// ListExprList /* `Vec<T>::Push` */: Expr NewLine^ /* Clipped */ ListExprList;
    ///
    #[parol_runtime::function_name::named]
    fn list_expr_list_0(
        &mut self,
        _expr: &ParseTreeType<'t>,
        _new_line: &ParseTreeType<'t>,
        _list_expr_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut list_expr_list = pop_item!(self, list_expr_list, ListExprList, context);
        // Ignore clipped member 'new_line'
        self.pop(context);
        let expr = pop_item!(self, expr, Expr, context);
        let list_expr_list_0_built = ListExprList {
            // Ignore clipped member 'new_line'
            expr: Box::new(expr),
        };
        // Add an element to the vector
        list_expr_list.push(list_expr_list_0_built);
        self.push(ASTType::ListExprList(list_expr_list), context);
        Ok(())
    }

    /// Semantic action for production 111:
    ///
    /// ListExprList /* `Vec<T>::New` */: ;
    ///
    #[parol_runtime::function_name::named]
    fn list_expr_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let list_expr_list_1_built = Vec::new();
        self.push(ASTType::ListExprList(list_expr_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 112:
    ///
    /// ControlExpr: IfElse;
    ///
    #[parol_runtime::function_name::named]
    fn control_expr_0(&mut self, _if_else: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let if_else = pop_item!(self, if_else, IfElse, context);
        let control_expr_0_built = ControlExprIfElse {
            if_else: Box::new(if_else),
        };
        let control_expr_0_built = ControlExpr::IfElse(control_expr_0_built);
        // Calling user action here
        self.user_grammar.control_expr(&control_expr_0_built)?;
        self.push(ASTType::ControlExpr(control_expr_0_built), context);
        Ok(())
    }

    /// Semantic action for production 113:
    ///
    /// ControlExpr: For;
    ///
    #[parol_runtime::function_name::named]
    fn control_expr_1(&mut self, _for: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#for = pop_item!(self, r#for, For, context);
        let control_expr_1_built = ControlExprFor {
            r#for: Box::new(r#for),
        };
        let control_expr_1_built = ControlExpr::For(control_expr_1_built);
        // Calling user action here
        self.user_grammar.control_expr(&control_expr_1_built)?;
        self.push(ASTType::ControlExpr(control_expr_1_built), context);
        Ok(())
    }

    /// Semantic action for production 114:
    ///
    /// ValueExpr: Disjunction;
    ///
    #[parol_runtime::function_name::named]
    fn value_expr_0(&mut self, _disjunction: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let disjunction = pop_item!(self, disjunction, Disjunction, context);
        let value_expr_0_built = ValueExprDisjunction {
            disjunction: Box::new(disjunction),
        };
        let value_expr_0_built = ValueExpr::Disjunction(value_expr_0_built);
        // Calling user action here
        self.user_grammar.value_expr(&value_expr_0_built)?;
        self.push(ASTType::ValueExpr(value_expr_0_built), context);
        Ok(())
    }

    /// Semantic action for production 115:
    ///
    /// ValueExpr: Content;
    ///
    #[parol_runtime::function_name::named]
    fn value_expr_1(&mut self, _content: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let content = pop_item!(self, content, Content, context);
        let value_expr_1_built = ValueExprContent {
            content: Box::new(content),
        };
        let value_expr_1_built = ValueExpr::Content(value_expr_1_built);
        // Calling user action here
        self.user_grammar.value_expr(&value_expr_1_built)?;
        self.push(ASTType::ValueExpr(value_expr_1_built), context);
        Ok(())
    }

    /// Semantic action for production 116:
    ///
    /// Let: KwLet^ /* Clipped */ IdentifierToken EquToken^ /* Clipped */ Expr;
    ///
    #[parol_runtime::function_name::named]
    fn r#let(
        &mut self,
        _kw_let: &ParseTreeType<'t>,
        _identifier_token: &ParseTreeType<'t>,
        _equ_token: &ParseTreeType<'t>,
        _expr: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expr = pop_item!(self, expr, Expr, context);
        // Ignore clipped member 'equ_token'
        self.pop(context);
        let identifier_token = pop_item!(self, identifier_token, IdentifierToken, context);
        // Ignore clipped member 'kw_let'
        self.pop(context);
        let r#let_built = Let {
            // Ignore clipped member 'kw_let'
            identifier_token: Box::new(identifier_token),
            // Ignore clipped member 'equ_token'
            expr: Box::new(expr),
        };
        // Calling user action here
        self.user_grammar.r#let(&r#let_built)?;
        self.push(ASTType::Let(r#let_built), context);
        Ok(())
    }

    /// Semantic action for production 117:
    ///
    /// IdentList: IdentifierToken IdentListList /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn ident_list(
        &mut self,
        _identifier_token: &ParseTreeType<'t>,
        _ident_list_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ident_list_list = pop_and_reverse_item!(self, ident_list_list, IdentListList, context);
        let identifier_token = pop_item!(self, identifier_token, IdentifierToken, context);
        let ident_list_built = IdentList {
            identifier_token: Box::new(identifier_token),
            ident_list_list,
        };
        // Calling user action here
        self.user_grammar.ident_list(&ident_list_built)?;
        self.push(ASTType::IdentList(ident_list_built), context);
        Ok(())
    }

    /// Semantic action for production 118:
    ///
    /// IdentListList /* `Vec<T>::Push` */: CommaToken^ /* Clipped */ IdentifierToken IdentListList;
    ///
    #[parol_runtime::function_name::named]
    fn ident_list_list_0(
        &mut self,
        _comma_token: &ParseTreeType<'t>,
        _identifier_token: &ParseTreeType<'t>,
        _ident_list_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut ident_list_list = pop_item!(self, ident_list_list, IdentListList, context);
        let identifier_token = pop_item!(self, identifier_token, IdentifierToken, context);
        // Ignore clipped member 'comma_token'
        self.pop(context);
        let ident_list_list_0_built = IdentListList {
            identifier_token: Box::new(identifier_token),
            // Ignore clipped member 'comma_token'
        };
        // Add an element to the vector
        ident_list_list.push(ident_list_list_0_built);
        self.push(ASTType::IdentListList(ident_list_list), context);
        Ok(())
    }

    /// Semantic action for production 119:
    ///
    /// IdentListList /* `Vec<T>::New` */: ;
    ///
    #[parol_runtime::function_name::named]
    fn ident_list_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ident_list_list_1_built = Vec::new();
        self.push(ASTType::IdentListList(ident_list_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 120:
    ///
    /// Makro: KwMakro^ /* Clipped */ IdentifierToken LeftParenToken^ /* Clipped */ MakroOpt /* Option */ RightParenToken^ /* Clipped */ EquToken^ /* Clipped */ Expr;
    ///
    #[parol_runtime::function_name::named]
    fn makro(
        &mut self,
        _kw_makro: &ParseTreeType<'t>,
        _identifier_token: &ParseTreeType<'t>,
        _left_paren_token: &ParseTreeType<'t>,
        _makro_opt: &ParseTreeType<'t>,
        _right_paren_token: &ParseTreeType<'t>,
        _equ_token: &ParseTreeType<'t>,
        _expr: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expr = pop_item!(self, expr, Expr, context);
        // Ignore clipped member 'equ_token'
        self.pop(context);
        // Ignore clipped member 'right_paren_token'
        self.pop(context);
        let makro_opt = pop_item!(self, makro_opt, MakroOpt, context);
        // Ignore clipped member 'left_paren_token'
        self.pop(context);
        let identifier_token = pop_item!(self, identifier_token, IdentifierToken, context);
        // Ignore clipped member 'kw_makro'
        self.pop(context);
        let makro_built = Makro {
            // Ignore clipped member 'kw_makro'
            identifier_token: Box::new(identifier_token),
            // Ignore clipped member 'left_paren_token'
            makro_opt,
            // Ignore clipped member 'right_paren_token'
            // Ignore clipped member 'equ_token'
            expr: Box::new(expr),
        };
        // Calling user action here
        self.user_grammar.makro(&makro_built)?;
        self.push(ASTType::Makro(makro_built), context);
        Ok(())
    }

    /// Semantic action for production 121:
    ///
    /// MakroOpt /* `Option<T>::Some` */: IdentList;
    ///
    #[parol_runtime::function_name::named]
    fn makro_opt_0(&mut self, _ident_list: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ident_list = pop_item!(self, ident_list, IdentList, context);
        let makro_opt_0_built = MakroOpt {
            ident_list: Box::new(ident_list),
        };
        self.push(
            ASTType::MakroOpt(Some(Box::new(makro_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 122:
    ///
    /// MakroOpt /* `Option<T>::None` */: ;
    ///
    #[parol_runtime::function_name::named]
    fn makro_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::MakroOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 123:
    ///
    /// Content: LeftBracketToken^ /* Clipped */ ContentTail;
    ///
    #[parol_runtime::function_name::named]
    fn content(
        &mut self,
        _left_bracket_token: &ParseTreeType<'t>,
        _content_tail: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let content_tail = pop_item!(self, content_tail, ContentTail, context);
        // Ignore clipped member 'left_bracket_token'
        self.pop(context);
        let content_built = Content {
            // Ignore clipped member 'left_bracket_token'
            content_tail: Box::new(content_tail),
        };
        // Calling user action here
        self.user_grammar.content(&content_built)?;
        self.push(ASTType::Content(content_built), context);
        Ok(())
    }

    /// Semantic action for production 124:
    ///
    /// ContentTail: %push(INITIAL) ContentTailGroup %pop() RightBracketToken^ /* Clipped */;
    ///
    #[parol_runtime::function_name::named]
    fn content_tail(
        &mut self,
        _content_tail_group: &ParseTreeType<'t>,
        _right_bracket_token: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        // Ignore clipped member 'right_bracket_token'
        self.pop(context);
        let content_tail_group = pop_item!(self, content_tail_group, ContentTailGroup, context);
        let content_tail_built = ContentTail {
            content_tail_group: Box::new(content_tail_group),
            // Ignore clipped member 'right_bracket_token'
        };
        // Calling user action here
        self.user_grammar.content_tail(&content_tail_built)?;
        self.push(ASTType::ContentTail(content_tail_built), context);
        Ok(())
    }

    /// Semantic action for production 125:
    ///
    /// ContentTailGroup: NewLine^ /* Clipped */ Block;
    ///
    #[parol_runtime::function_name::named]
    fn content_tail_group_0(
        &mut self,
        _new_line: &ParseTreeType<'t>,
        _block: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let block = pop_item!(self, block, Block, context);
        // Ignore clipped member 'new_line'
        self.pop(context);
        let content_tail_group_0_built = ContentTailGroupNewLineBlock {
            // Ignore clipped member 'new_line'
            block: Box::new(block),
        };
        let content_tail_group_0_built = ContentTailGroup::NewLineBlock(content_tail_group_0_built);
        self.push(
            ASTType::ContentTailGroup(content_tail_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 126:
    ///
    /// ContentTailGroup: Elements;
    ///
    #[parol_runtime::function_name::named]
    fn content_tail_group_1(&mut self, _elements: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let elements = pop_item!(self, elements, Elements, context);
        let content_tail_group_1_built = ContentTailGroupElements {
            elements: Box::new(elements),
        };
        let content_tail_group_1_built = ContentTailGroup::Elements(content_tail_group_1_built);
        self.push(
            ASTType::ContentTailGroup(content_tail_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 127:
    ///
    /// IfElse: KwIf Disjunction IfElseGroup KwElse IfElseGroup0;
    ///
    #[parol_runtime::function_name::named]
    fn if_else(
        &mut self,
        _kw_if: &ParseTreeType<'t>,
        _disjunction: &ParseTreeType<'t>,
        _if_else_group: &ParseTreeType<'t>,
        _kw_else: &ParseTreeType<'t>,
        _if_else_group0: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let if_else_group0 = pop_item!(self, if_else_group0, IfElseGroup0, context);
        let kw_else = pop_item!(self, kw_else, KwElse, context);
        let if_else_group = pop_item!(self, if_else_group, IfElseGroup, context);
        let disjunction = pop_item!(self, disjunction, Disjunction, context);
        let kw_if = pop_item!(self, kw_if, KwIf, context);
        let if_else_built = IfElse {
            kw_if: Box::new(kw_if),
            disjunction: Box::new(disjunction),
            if_else_group: Box::new(if_else_group),
            kw_else: Box::new(kw_else),
            if_else_group0: Box::new(if_else_group0),
        };
        // Calling user action here
        self.user_grammar.if_else(&if_else_built)?;
        self.push(ASTType::IfElse(if_else_built), context);
        Ok(())
    }

    /// Semantic action for production 128:
    ///
    /// IfElseGroup0: ListExpr;
    ///
    #[parol_runtime::function_name::named]
    fn if_else_group0_0(&mut self, _list_expr: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let list_expr = pop_item!(self, list_expr, ListExpr, context);
        let if_else_group0_0_built = IfElseGroup0ListExpr {
            list_expr: Box::new(list_expr),
        };
        let if_else_group0_0_built = IfElseGroup0::ListExpr(if_else_group0_0_built);
        self.push(ASTType::IfElseGroup0(if_else_group0_0_built), context);
        Ok(())
    }

    /// Semantic action for production 129:
    ///
    /// IfElseGroup0: Content;
    ///
    #[parol_runtime::function_name::named]
    fn if_else_group0_1(&mut self, _content: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let content = pop_item!(self, content, Content, context);
        let if_else_group0_1_built = IfElseGroup0Content {
            content: Box::new(content),
        };
        let if_else_group0_1_built = IfElseGroup0::Content(if_else_group0_1_built);
        self.push(ASTType::IfElseGroup0(if_else_group0_1_built), context);
        Ok(())
    }

    /// Semantic action for production 130:
    ///
    /// IfElseGroup0: IfElse;
    ///
    #[parol_runtime::function_name::named]
    fn if_else_group0_2(&mut self, _if_else: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let if_else = pop_item!(self, if_else, IfElse, context);
        let if_else_group0_2_built = IfElseGroup0IfElse {
            if_else: Box::new(if_else),
        };
        let if_else_group0_2_built = IfElseGroup0::IfElse(if_else_group0_2_built);
        self.push(ASTType::IfElseGroup0(if_else_group0_2_built), context);
        Ok(())
    }

    /// Semantic action for production 131:
    ///
    /// IfElseGroup: ListExpr;
    ///
    #[parol_runtime::function_name::named]
    fn if_else_group_0(&mut self, _list_expr: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let list_expr = pop_item!(self, list_expr, ListExpr, context);
        let if_else_group_0_built = IfElseGroupListExpr {
            list_expr: Box::new(list_expr),
        };
        let if_else_group_0_built = IfElseGroup::ListExpr(if_else_group_0_built);
        self.push(ASTType::IfElseGroup(if_else_group_0_built), context);
        Ok(())
    }

    /// Semantic action for production 132:
    ///
    /// IfElseGroup: Content;
    ///
    #[parol_runtime::function_name::named]
    fn if_else_group_1(&mut self, _content: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let content = pop_item!(self, content, Content, context);
        let if_else_group_1_built = IfElseGroupContent {
            content: Box::new(content),
        };
        let if_else_group_1_built = IfElseGroup::Content(if_else_group_1_built);
        self.push(ASTType::IfElseGroup(if_else_group_1_built), context);
        Ok(())
    }

    /// Semantic action for production 133:
    ///
    /// Iterable: Access;
    ///
    #[parol_runtime::function_name::named]
    fn iterable_0(&mut self, _access: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let access = pop_item!(self, access, Access, context);
        let iterable_0_built = IterableAccess {
            access: Box::new(access),
        };
        let iterable_0_built = Iterable::Access(iterable_0_built);
        // Calling user action here
        self.user_grammar.iterable(&iterable_0_built)?;
        self.push(ASTType::Iterable(iterable_0_built), context);
        Ok(())
    }

    /// Semantic action for production 134:
    ///
    /// Iterable: String;
    ///
    #[parol_runtime::function_name::named]
    fn iterable_1(&mut self, _string: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let string = pop_item!(self, string, String, context);
        let iterable_1_built = IterableString {
            string: Box::new(string),
        };
        let iterable_1_built = Iterable::String(iterable_1_built);
        // Calling user action here
        self.user_grammar.iterable(&iterable_1_built)?;
        self.push(ASTType::Iterable(iterable_1_built), context);
        Ok(())
    }

    /// Semantic action for production 135:
    ///
    /// Iterable: DigitsToken;
    ///
    #[parol_runtime::function_name::named]
    fn iterable_2(&mut self, _digits_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let digits_token = pop_item!(self, digits_token, DigitsToken, context);
        let iterable_2_built = IterableDigitsToken {
            digits_token: Box::new(digits_token),
        };
        let iterable_2_built = Iterable::DigitsToken(iterable_2_built);
        // Calling user action here
        self.user_grammar.iterable(&iterable_2_built)?;
        self.push(ASTType::Iterable(iterable_2_built), context);
        Ok(())
    }

    /// Semantic action for production 136:
    ///
    /// For: KwFor^ /* Clipped */ IdentifierToken KwIn^ /* Clipped */ Iterable ForGroup;
    ///
    #[parol_runtime::function_name::named]
    fn r#for(
        &mut self,
        _kw_for: &ParseTreeType<'t>,
        _identifier_token: &ParseTreeType<'t>,
        _kw_in: &ParseTreeType<'t>,
        _iterable: &ParseTreeType<'t>,
        _for_group: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let for_group = pop_item!(self, for_group, ForGroup, context);
        let iterable = pop_item!(self, iterable, Iterable, context);
        // Ignore clipped member 'kw_in'
        self.pop(context);
        let identifier_token = pop_item!(self, identifier_token, IdentifierToken, context);
        // Ignore clipped member 'kw_for'
        self.pop(context);
        let r#for_built = For {
            // Ignore clipped member 'kw_for'
            identifier_token: Box::new(identifier_token),
            // Ignore clipped member 'kw_in'
            iterable: Box::new(iterable),
            for_group: Box::new(for_group),
        };
        // Calling user action here
        self.user_grammar.r#for(&r#for_built)?;
        self.push(ASTType::For(r#for_built), context);
        Ok(())
    }

    /// Semantic action for production 137:
    ///
    /// ForGroup: ListExpr;
    ///
    #[parol_runtime::function_name::named]
    fn for_group_0(&mut self, _list_expr: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let list_expr = pop_item!(self, list_expr, ListExpr, context);
        let for_group_0_built = ForGroupListExpr {
            list_expr: Box::new(list_expr),
        };
        let for_group_0_built = ForGroup::ListExpr(for_group_0_built);
        self.push(ASTType::ForGroup(for_group_0_built), context);
        Ok(())
    }

    /// Semantic action for production 138:
    ///
    /// ForGroup: Content;
    ///
    #[parol_runtime::function_name::named]
    fn for_group_1(&mut self, _content: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let content = pop_item!(self, content, Content, context);
        let for_group_1_built = ForGroupContent {
            content: Box::new(content),
        };
        let for_group_1_built = ForGroup::Content(for_group_1_built);
        self.push(ASTType::ForGroup(for_group_1_built), context);
        Ok(())
    }

    /// Semantic action for production 139:
    ///
    /// Disjunction: Conjunction DisjunctionList /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn disjunction(
        &mut self,
        _conjunction: &ParseTreeType<'t>,
        _disjunction_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let disjunction_list =
            pop_and_reverse_item!(self, disjunction_list, DisjunctionList, context);
        let conjunction = pop_item!(self, conjunction, Conjunction, context);
        let disjunction_built = Disjunction {
            conjunction: Box::new(conjunction),
            disjunction_list,
        };
        // Calling user action here
        self.user_grammar.disjunction(&disjunction_built)?;
        self.push(ASTType::Disjunction(disjunction_built), context);
        Ok(())
    }

    /// Semantic action for production 140:
    ///
    /// DisjunctionList /* `Vec<T>::Push` */: PipeDoubleToken Conjunction DisjunctionList;
    ///
    #[parol_runtime::function_name::named]
    fn disjunction_list_0(
        &mut self,
        _pipe_double_token: &ParseTreeType<'t>,
        _conjunction: &ParseTreeType<'t>,
        _disjunction_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut disjunction_list = pop_item!(self, disjunction_list, DisjunctionList, context);
        let conjunction = pop_item!(self, conjunction, Conjunction, context);
        let pipe_double_token = pop_item!(self, pipe_double_token, PipeDoubleToken, context);
        let disjunction_list_0_built = DisjunctionList {
            conjunction: Box::new(conjunction),
            pipe_double_token: Box::new(pipe_double_token),
        };
        // Add an element to the vector
        disjunction_list.push(disjunction_list_0_built);
        self.push(ASTType::DisjunctionList(disjunction_list), context);
        Ok(())
    }

    /// Semantic action for production 141:
    ///
    /// DisjunctionList /* `Vec<T>::New` */: ;
    ///
    #[parol_runtime::function_name::named]
    fn disjunction_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let disjunction_list_1_built = Vec::new();
        self.push(ASTType::DisjunctionList(disjunction_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 142:
    ///
    /// Conjunction: Negation ConjunctionList /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn conjunction(
        &mut self,
        _negation: &ParseTreeType<'t>,
        _conjunction_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let conjunction_list =
            pop_and_reverse_item!(self, conjunction_list, ConjunctionList, context);
        let negation = pop_item!(self, negation, Negation, context);
        let conjunction_built = Conjunction {
            negation: Box::new(negation),
            conjunction_list,
        };
        // Calling user action here
        self.user_grammar.conjunction(&conjunction_built)?;
        self.push(ASTType::Conjunction(conjunction_built), context);
        Ok(())
    }

    /// Semantic action for production 143:
    ///
    /// ConjunctionList /* `Vec<T>::Push` */: AmperDoubleToken Negation ConjunctionList;
    ///
    #[parol_runtime::function_name::named]
    fn conjunction_list_0(
        &mut self,
        _amper_double_token: &ParseTreeType<'t>,
        _negation: &ParseTreeType<'t>,
        _conjunction_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut conjunction_list = pop_item!(self, conjunction_list, ConjunctionList, context);
        let negation = pop_item!(self, negation, Negation, context);
        let amper_double_token = pop_item!(self, amper_double_token, AmperDoubleToken, context);
        let conjunction_list_0_built = ConjunctionList {
            negation: Box::new(negation),
            amper_double_token: Box::new(amper_double_token),
        };
        // Add an element to the vector
        conjunction_list.push(conjunction_list_0_built);
        self.push(ASTType::ConjunctionList(conjunction_list), context);
        Ok(())
    }

    /// Semantic action for production 144:
    ///
    /// ConjunctionList /* `Vec<T>::New` */: ;
    ///
    #[parol_runtime::function_name::named]
    fn conjunction_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let conjunction_list_1_built = Vec::new();
        self.push(ASTType::ConjunctionList(conjunction_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 145:
    ///
    /// Negation: NegationOpt /* Option */ Relation;
    ///
    #[parol_runtime::function_name::named]
    fn negation(
        &mut self,
        _negation_opt: &ParseTreeType<'t>,
        _relation: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let relation = pop_item!(self, relation, Relation, context);
        let negation_opt = pop_item!(self, negation_opt, NegationOpt, context);
        let negation_built = Negation {
            negation_opt,
            relation: Box::new(relation),
        };
        // Calling user action here
        self.user_grammar.negation(&negation_built)?;
        self.push(ASTType::Negation(negation_built), context);
        Ok(())
    }

    /// Semantic action for production 146:
    ///
    /// NegationOpt /* `Option<T>::Some` */: ExclamToken;
    ///
    #[parol_runtime::function_name::named]
    fn negation_opt_0(&mut self, _exclam_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let exclam_token = pop_item!(self, exclam_token, ExclamToken, context);
        let negation_opt_0_built = NegationOpt {
            exclam_token: Box::new(exclam_token),
        };
        self.push(
            ASTType::NegationOpt(Some(Box::new(negation_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 147:
    ///
    /// NegationOpt /* `Option<T>::None` */: ;
    ///
    #[parol_runtime::function_name::named]
    fn negation_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::NegationOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 148:
    ///
    /// Relation: Summation RelationOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn relation_0(
        &mut self,
        _summation: &ParseTreeType<'t>,
        _relation_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let relation_opt = pop_item!(self, relation_opt, RelationOpt, context);
        let summation = pop_item!(self, summation, Summation, context);
        let relation_0_built = RelationSummationRelationOpt {
            summation: Box::new(summation),
            relation_opt,
        };
        let relation_0_built = Relation::SummationRelationOpt(relation_0_built);
        // Calling user action here
        self.user_grammar.relation(&relation_0_built)?;
        self.push(ASTType::Relation(relation_0_built), context);
        Ok(())
    }

    /// Semantic action for production 149:
    ///
    /// RelationOpt /* `Option<T>::Some` */: RelationOptGroup Summation;
    ///
    #[parol_runtime::function_name::named]
    fn relation_opt_0(
        &mut self,
        _relation_opt_group: &ParseTreeType<'t>,
        _summation: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let summation = pop_item!(self, summation, Summation, context);
        let relation_opt_group = pop_item!(self, relation_opt_group, RelationOptGroup, context);
        let relation_opt_0_built = RelationOpt {
            relation_opt_group: Box::new(relation_opt_group),
            summation: Box::new(summation),
        };
        self.push(
            ASTType::RelationOpt(Some(Box::new(relation_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 150:
    ///
    /// RelationOptGroup: EquDoubleToken;
    ///
    #[parol_runtime::function_name::named]
    fn relation_opt_group_0(&mut self, _equ_double_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let equ_double_token = pop_item!(self, equ_double_token, EquDoubleToken, context);
        let relation_opt_group_0_built = RelationOptGroupEquDoubleToken {
            equ_double_token: Box::new(equ_double_token),
        };
        let relation_opt_group_0_built =
            RelationOptGroup::EquDoubleToken(relation_opt_group_0_built);
        self.push(
            ASTType::RelationOptGroup(relation_opt_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 151:
    ///
    /// RelationOptGroup: ExclamEquToken;
    ///
    #[parol_runtime::function_name::named]
    fn relation_opt_group_1(&mut self, _exclam_equ_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let exclam_equ_token = pop_item!(self, exclam_equ_token, ExclamEquToken, context);
        let relation_opt_group_1_built = RelationOptGroupExclamEquToken {
            exclam_equ_token: Box::new(exclam_equ_token),
        };
        let relation_opt_group_1_built =
            RelationOptGroup::ExclamEquToken(relation_opt_group_1_built);
        self.push(
            ASTType::RelationOptGroup(relation_opt_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 152:
    ///
    /// RelationOptGroup: LeftAngleToken;
    ///
    #[parol_runtime::function_name::named]
    fn relation_opt_group_2(&mut self, _left_angle_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let left_angle_token = pop_item!(self, left_angle_token, LeftAngleToken, context);
        let relation_opt_group_2_built = RelationOptGroupLeftAngleToken {
            left_angle_token: Box::new(left_angle_token),
        };
        let relation_opt_group_2_built =
            RelationOptGroup::LeftAngleToken(relation_opt_group_2_built);
        self.push(
            ASTType::RelationOptGroup(relation_opt_group_2_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 153:
    ///
    /// RelationOptGroup: LeftAngleEquToken;
    ///
    #[parol_runtime::function_name::named]
    fn relation_opt_group_3(&mut self, _left_angle_equ_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let left_angle_equ_token =
            pop_item!(self, left_angle_equ_token, LeftAngleEquToken, context);
        let relation_opt_group_3_built = RelationOptGroupLeftAngleEquToken {
            left_angle_equ_token: Box::new(left_angle_equ_token),
        };
        let relation_opt_group_3_built =
            RelationOptGroup::LeftAngleEquToken(relation_opt_group_3_built);
        self.push(
            ASTType::RelationOptGroup(relation_opt_group_3_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 154:
    ///
    /// RelationOptGroup: RightAngleToken;
    ///
    #[parol_runtime::function_name::named]
    fn relation_opt_group_4(&mut self, _right_angle_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let right_angle_token = pop_item!(self, right_angle_token, RightAngleToken, context);
        let relation_opt_group_4_built = RelationOptGroupRightAngleToken {
            right_angle_token: Box::new(right_angle_token),
        };
        let relation_opt_group_4_built =
            RelationOptGroup::RightAngleToken(relation_opt_group_4_built);
        self.push(
            ASTType::RelationOptGroup(relation_opt_group_4_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 155:
    ///
    /// RelationOptGroup: RightAngleEquToken;
    ///
    #[parol_runtime::function_name::named]
    fn relation_opt_group_5(&mut self, _right_angle_equ_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let right_angle_equ_token =
            pop_item!(self, right_angle_equ_token, RightAngleEquToken, context);
        let relation_opt_group_5_built = RelationOptGroupRightAngleEquToken {
            right_angle_equ_token: Box::new(right_angle_equ_token),
        };
        let relation_opt_group_5_built =
            RelationOptGroup::RightAngleEquToken(relation_opt_group_5_built);
        self.push(
            ASTType::RelationOptGroup(relation_opt_group_5_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 156:
    ///
    /// RelationOpt /* `Option<T>::None` */: ;
    ///
    #[parol_runtime::function_name::named]
    fn relation_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::RelationOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 157:
    ///
    /// Summation: Multiplication SummationList /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn summation(
        &mut self,
        _multiplication: &ParseTreeType<'t>,
        _summation_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let summation_list = pop_and_reverse_item!(self, summation_list, SummationList, context);
        let multiplication = pop_item!(self, multiplication, Multiplication, context);
        let summation_built = Summation {
            multiplication: Box::new(multiplication),
            summation_list,
        };
        // Calling user action here
        self.user_grammar.summation(&summation_built)?;
        self.push(ASTType::Summation(summation_built), context);
        Ok(())
    }

    /// Semantic action for production 158:
    ///
    /// SummationList /* `Vec<T>::Push` */: SummationListGroup Multiplication SummationList;
    ///
    #[parol_runtime::function_name::named]
    fn summation_list_0(
        &mut self,
        _summation_list_group: &ParseTreeType<'t>,
        _multiplication: &ParseTreeType<'t>,
        _summation_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut summation_list = pop_item!(self, summation_list, SummationList, context);
        let multiplication = pop_item!(self, multiplication, Multiplication, context);
        let summation_list_group =
            pop_item!(self, summation_list_group, SummationListGroup, context);
        let summation_list_0_built = SummationList {
            multiplication: Box::new(multiplication),
            summation_list_group: Box::new(summation_list_group),
        };
        // Add an element to the vector
        summation_list.push(summation_list_0_built);
        self.push(ASTType::SummationList(summation_list), context);
        Ok(())
    }

    /// Semantic action for production 159:
    ///
    /// SummationListGroup: PlusToken;
    ///
    #[parol_runtime::function_name::named]
    fn summation_list_group_0(&mut self, _plus_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let plus_token = pop_item!(self, plus_token, PlusToken, context);
        let summation_list_group_0_built = SummationListGroupPlusToken {
            plus_token: Box::new(plus_token),
        };
        let summation_list_group_0_built =
            SummationListGroup::PlusToken(summation_list_group_0_built);
        self.push(
            ASTType::SummationListGroup(summation_list_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 160:
    ///
    /// SummationListGroup: MinusToken;
    ///
    #[parol_runtime::function_name::named]
    fn summation_list_group_1(&mut self, _minus_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let minus_token = pop_item!(self, minus_token, MinusToken, context);
        let summation_list_group_1_built = SummationListGroupMinusToken {
            minus_token: Box::new(minus_token),
        };
        let summation_list_group_1_built =
            SummationListGroup::MinusToken(summation_list_group_1_built);
        self.push(
            ASTType::SummationListGroup(summation_list_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 161:
    ///
    /// SummationList /* `Vec<T>::New` */: ;
    ///
    #[parol_runtime::function_name::named]
    fn summation_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let summation_list_1_built = Vec::new();
        self.push(ASTType::SummationList(summation_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 162:
    ///
    /// Multiplication: Factor MultiplicationList /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn multiplication(
        &mut self,
        _factor: &ParseTreeType<'t>,
        _multiplication_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let multiplication_list =
            pop_and_reverse_item!(self, multiplication_list, MultiplicationList, context);
        let factor = pop_item!(self, factor, Factor, context);
        let multiplication_built = Multiplication {
            factor: Box::new(factor),
            multiplication_list,
        };
        // Calling user action here
        self.user_grammar.multiplication(&multiplication_built)?;
        self.push(ASTType::Multiplication(multiplication_built), context);
        Ok(())
    }

    /// Semantic action for production 163:
    ///
    /// MultiplicationList /* `Vec<T>::Push` */: MultiplicationListGroup Factor MultiplicationList;
    ///
    #[parol_runtime::function_name::named]
    fn multiplication_list_0(
        &mut self,
        _multiplication_list_group: &ParseTreeType<'t>,
        _factor: &ParseTreeType<'t>,
        _multiplication_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut multiplication_list =
            pop_item!(self, multiplication_list, MultiplicationList, context);
        let factor = pop_item!(self, factor, Factor, context);
        let multiplication_list_group = pop_item!(
            self,
            multiplication_list_group,
            MultiplicationListGroup,
            context
        );
        let multiplication_list_0_built = MultiplicationList {
            factor: Box::new(factor),
            multiplication_list_group: Box::new(multiplication_list_group),
        };
        // Add an element to the vector
        multiplication_list.push(multiplication_list_0_built);
        self.push(ASTType::MultiplicationList(multiplication_list), context);
        Ok(())
    }

    /// Semantic action for production 164:
    ///
    /// MultiplicationListGroup: SlashToken;
    ///
    #[parol_runtime::function_name::named]
    fn multiplication_list_group_0(&mut self, _slash_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let slash_token = pop_item!(self, slash_token, SlashToken, context);
        let multiplication_list_group_0_built = MultiplicationListGroupSlashToken {
            slash_token: Box::new(slash_token),
        };
        let multiplication_list_group_0_built =
            MultiplicationListGroup::SlashToken(multiplication_list_group_0_built);
        self.push(
            ASTType::MultiplicationListGroup(multiplication_list_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 165:
    ///
    /// MultiplicationListGroup: AsteriskToken;
    ///
    #[parol_runtime::function_name::named]
    fn multiplication_list_group_1(&mut self, _asterisk_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let asterisk_token = pop_item!(self, asterisk_token, AsteriskToken, context);
        let multiplication_list_group_1_built = MultiplicationListGroupAsteriskToken {
            asterisk_token: Box::new(asterisk_token),
        };
        let multiplication_list_group_1_built =
            MultiplicationListGroup::AsteriskToken(multiplication_list_group_1_built);
        self.push(
            ASTType::MultiplicationListGroup(multiplication_list_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 166:
    ///
    /// MultiplicationListGroup: PercentToken;
    ///
    #[parol_runtime::function_name::named]
    fn multiplication_list_group_2(&mut self, _percent_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let percent_token = pop_item!(self, percent_token, PercentToken, context);
        let multiplication_list_group_2_built = MultiplicationListGroupPercentToken {
            percent_token: Box::new(percent_token),
        };
        let multiplication_list_group_2_built =
            MultiplicationListGroup::PercentToken(multiplication_list_group_2_built);
        self.push(
            ASTType::MultiplicationListGroup(multiplication_list_group_2_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 167:
    ///
    /// MultiplicationList /* `Vec<T>::New` */: ;
    ///
    #[parol_runtime::function_name::named]
    fn multiplication_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let multiplication_list_1_built = Vec::new();
        self.push(
            ASTType::MultiplicationList(multiplication_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 168:
    ///
    /// Factor: Primary;
    ///
    #[parol_runtime::function_name::named]
    fn factor(&mut self, _primary: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let primary = pop_item!(self, primary, Primary, context);
        let factor_built = Factor {
            primary: Box::new(primary),
        };
        // Calling user action here
        self.user_grammar.factor(&factor_built)?;
        self.push(ASTType::Factor(factor_built), context);
        Ok(())
    }

    /// Semantic action for production 169:
    ///
    /// Primary: LeftParenToken Disjunction RightParenToken;
    ///
    #[parol_runtime::function_name::named]
    fn primary_0(
        &mut self,
        _left_paren_token: &ParseTreeType<'t>,
        _disjunction: &ParseTreeType<'t>,
        _right_paren_token: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let right_paren_token = pop_item!(self, right_paren_token, RightParenToken, context);
        let disjunction = pop_item!(self, disjunction, Disjunction, context);
        let left_paren_token = pop_item!(self, left_paren_token, LeftParenToken, context);
        let primary_0_built = PrimaryLeftParenTokenDisjunctionRightParenToken {
            left_paren_token: Box::new(left_paren_token),
            disjunction: Box::new(disjunction),
            right_paren_token: Box::new(right_paren_token),
        };
        let primary_0_built = Primary::LeftParenTokenDisjunctionRightParenToken(primary_0_built);
        // Calling user action here
        self.user_grammar.primary(&primary_0_built)?;
        self.push(ASTType::Primary(primary_0_built), context);
        Ok(())
    }

    /// Semantic action for production 170:
    ///
    /// Primary: Value;
    ///
    #[parol_runtime::function_name::named]
    fn primary_1(&mut self, _value: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let value = pop_item!(self, value, Value, context);
        let primary_1_built = PrimaryValue {
            value: Box::new(value),
        };
        let primary_1_built = Primary::Value(primary_1_built);
        // Calling user action here
        self.user_grammar.primary(&primary_1_built)?;
        self.push(ASTType::Primary(primary_1_built), context);
        Ok(())
    }

    /// Semantic action for production 171:
    ///
    /// Value: Access;
    ///
    #[parol_runtime::function_name::named]
    fn value_0(&mut self, _access: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let access = pop_item!(self, access, Access, context);
        let value_0_built = ValueAccess {
            access: Box::new(access),
        };
        let value_0_built = Value::Access(value_0_built);
        // Calling user action here
        self.user_grammar.value(&value_0_built)?;
        self.push(ASTType::Value(value_0_built), context);
        Ok(())
    }

    /// Semantic action for production 172:
    ///
    /// Value: String;
    ///
    #[parol_runtime::function_name::named]
    fn value_1(&mut self, _string: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let string = pop_item!(self, string, String, context);
        let value_1_built = ValueString {
            string: Box::new(string),
        };
        let value_1_built = Value::String(value_1_built);
        // Calling user action here
        self.user_grammar.value(&value_1_built)?;
        self.push(ASTType::Value(value_1_built), context);
        Ok(())
    }

    /// Semantic action for production 173:
    ///
    /// Value: Number;
    ///
    #[parol_runtime::function_name::named]
    fn value_2(&mut self, _number: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let number = pop_item!(self, number, Number, context);
        let value_2_built = ValueNumber {
            number: Box::new(number),
        };
        let value_2_built = Value::Number(value_2_built);
        // Calling user action here
        self.user_grammar.value(&value_2_built)?;
        self.push(ASTType::Value(value_2_built), context);
        Ok(())
    }

    /// Semantic action for production 174:
    ///
    /// Value: Bool;
    ///
    #[parol_runtime::function_name::named]
    fn value_3(&mut self, _bool: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bool = pop_item!(self, bool, Bool, context);
        let value_3_built = ValueBool {
            bool: Box::new(bool),
        };
        let value_3_built = Value::Bool(value_3_built);
        // Calling user action here
        self.user_grammar.value(&value_3_built)?;
        self.push(ASTType::Value(value_3_built), context);
        Ok(())
    }

    /// Semantic action for production 175:
    ///
    /// Arg: IdentifierToken ArgOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn arg_0(
        &mut self,
        _identifier_token: &ParseTreeType<'t>,
        _arg_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let arg_opt = pop_item!(self, arg_opt, ArgOpt, context);
        let identifier_token = pop_item!(self, identifier_token, IdentifierToken, context);
        let arg_0_built = ArgIdentifierTokenArgOpt {
            identifier_token: Box::new(identifier_token),
            arg_opt,
        };
        let arg_0_built = Arg::IdentifierTokenArgOpt(arg_0_built);
        // Calling user action here
        self.user_grammar.arg(&arg_0_built)?;
        self.push(ASTType::Arg(arg_0_built), context);
        Ok(())
    }

    /// Semantic action for production 176:
    ///
    /// Arg: String;
    ///
    #[parol_runtime::function_name::named]
    fn arg_1(&mut self, _string: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let string = pop_item!(self, string, String, context);
        let arg_1_built = ArgString {
            string: Box::new(string),
        };
        let arg_1_built = Arg::String(arg_1_built);
        // Calling user action here
        self.user_grammar.arg(&arg_1_built)?;
        self.push(ASTType::Arg(arg_1_built), context);
        Ok(())
    }

    /// Semantic action for production 177:
    ///
    /// Arg: Number;
    ///
    #[parol_runtime::function_name::named]
    fn arg_2(&mut self, _number: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let number = pop_item!(self, number, Number, context);
        let arg_2_built = ArgNumber {
            number: Box::new(number),
        };
        let arg_2_built = Arg::Number(arg_2_built);
        // Calling user action here
        self.user_grammar.arg(&arg_2_built)?;
        self.push(ASTType::Arg(arg_2_built), context);
        Ok(())
    }

    /// Semantic action for production 178:
    ///
    /// Arg: Bool;
    ///
    #[parol_runtime::function_name::named]
    fn arg_3(&mut self, _bool: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bool = pop_item!(self, bool, Bool, context);
        let arg_3_built = ArgBool {
            bool: Box::new(bool),
        };
        let arg_3_built = Arg::Bool(arg_3_built);
        // Calling user action here
        self.user_grammar.arg(&arg_3_built)?;
        self.push(ASTType::Arg(arg_3_built), context);
        Ok(())
    }

    /// Semantic action for production 179:
    ///
    /// ArgOpt /* `Option<T>::Some` */: ArgOptGroup;
    ///
    #[parol_runtime::function_name::named]
    fn arg_opt_0(&mut self, _arg_opt_group: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let arg_opt_group = pop_item!(self, arg_opt_group, ArgOptGroup, context);
        let arg_opt_0_built = ArgOpt {
            arg_opt_group: Box::new(arg_opt_group),
        };
        self.push(ASTType::ArgOpt(Some(Box::new(arg_opt_0_built))), context);
        Ok(())
    }

    /// Semantic action for production 180:
    ///
    /// ArgOptGroup: ColonToken Value;
    ///
    #[parol_runtime::function_name::named]
    fn arg_opt_group_0(
        &mut self,
        _colon_token: &ParseTreeType<'t>,
        _value: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let value = pop_item!(self, value, Value, context);
        let colon_token = pop_item!(self, colon_token, ColonToken, context);
        let arg_opt_group_0_built = ArgOptGroupColonTokenValue {
            colon_token: Box::new(colon_token),
            value: Box::new(value),
        };
        let arg_opt_group_0_built = ArgOptGroup::ColonTokenValue(arg_opt_group_0_built);
        self.push(ASTType::ArgOptGroup(arg_opt_group_0_built), context);
        Ok(())
    }

    /// Semantic action for production 181:
    ///
    /// ArgOptGroup: Call;
    ///
    #[parol_runtime::function_name::named]
    fn arg_opt_group_1(&mut self, _call: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let call = pop_item!(self, call, Call, context);
        let arg_opt_group_1_built = ArgOptGroupCall {
            call: Box::new(call),
        };
        let arg_opt_group_1_built = ArgOptGroup::Call(arg_opt_group_1_built);
        self.push(ASTType::ArgOptGroup(arg_opt_group_1_built), context);
        Ok(())
    }

    /// Semantic action for production 182:
    ///
    /// ArgOpt /* `Option<T>::None` */: ;
    ///
    #[parol_runtime::function_name::named]
    fn arg_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ArgOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 183:
    ///
    /// Args: Arg ArgsList /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn args(&mut self, _arg: &ParseTreeType<'t>, _args_list: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let args_list = pop_and_reverse_item!(self, args_list, ArgsList, context);
        let arg = pop_item!(self, arg, Arg, context);
        let args_built = Args {
            arg: Box::new(arg),
            args_list,
        };
        // Calling user action here
        self.user_grammar.args(&args_built)?;
        self.push(ASTType::Args(args_built), context);
        Ok(())
    }

    /// Semantic action for production 184:
    ///
    /// ArgsList /* `Vec<T>::Push` */: CommaToken^ /* Clipped */ Arg ArgsList;
    ///
    #[parol_runtime::function_name::named]
    fn args_list_0(
        &mut self,
        _comma_token: &ParseTreeType<'t>,
        _arg: &ParseTreeType<'t>,
        _args_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut args_list = pop_item!(self, args_list, ArgsList, context);
        let arg = pop_item!(self, arg, Arg, context);
        // Ignore clipped member 'comma_token'
        self.pop(context);
        let args_list_0_built = ArgsList {
            arg: Box::new(arg),
            // Ignore clipped member 'comma_token'
        };
        // Add an element to the vector
        args_list.push(args_list_0_built);
        self.push(ASTType::ArgsList(args_list), context);
        Ok(())
    }

    /// Semantic action for production 185:
    ///
    /// ArgsList /* `Vec<T>::New` */: ;
    ///
    #[parol_runtime::function_name::named]
    fn args_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let args_list_1_built = Vec::new();
        self.push(ASTType::ArgsList(args_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 186:
    ///
    /// Access: IdentifierToken AccessOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn access(
        &mut self,
        _identifier_token: &ParseTreeType<'t>,
        _access_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let access_opt = pop_item!(self, access_opt, AccessOpt, context);
        let identifier_token = pop_item!(self, identifier_token, IdentifierToken, context);
        let access_built = Access {
            identifier_token: Box::new(identifier_token),
            access_opt,
        };
        // Calling user action here
        self.user_grammar.access(&access_built)?;
        self.push(ASTType::Access(access_built), context);
        Ok(())
    }

    /// Semantic action for production 187:
    ///
    /// AccessOpt /* `Option<T>::Some` */: Call;
    ///
    #[parol_runtime::function_name::named]
    fn access_opt_0(&mut self, _call: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let call = pop_item!(self, call, Call, context);
        let access_opt_0_built = AccessOpt {
            call: Box::new(call),
        };
        self.push(
            ASTType::AccessOpt(Some(Box::new(access_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 188:
    ///
    /// AccessOpt /* `Option<T>::None` */: ;
    ///
    #[parol_runtime::function_name::named]
    fn access_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::AccessOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 189:
    ///
    /// Call: LeftParenToken^ /* Clipped */ CallOpt /* Option */ CallGroup;
    ///
    #[parol_runtime::function_name::named]
    fn call(
        &mut self,
        _left_paren_token: &ParseTreeType<'t>,
        _call_opt: &ParseTreeType<'t>,
        _call_group: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let call_group = pop_item!(self, call_group, CallGroup, context);
        let call_opt = pop_item!(self, call_opt, CallOpt, context);
        // Ignore clipped member 'left_paren_token'
        self.pop(context);
        let call_built = Call {
            // Ignore clipped member 'left_paren_token'
            call_opt,
            call_group: Box::new(call_group),
        };
        // Calling user action here
        self.user_grammar.call(&call_built)?;
        self.push(ASTType::Call(call_built), context);
        Ok(())
    }

    /// Semantic action for production 190:
    ///
    /// CallGroup: RightParenToken^ /* Clipped */;
    ///
    #[parol_runtime::function_name::named]
    fn call_group_0(&mut self, _right_paren_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        // Ignore clipped member 'right_paren_token'
        self.pop(context);
        let call_group_0_built = CallGroupRightParenToken {
        // Ignore clipped member 'right_paren_token'
        };
        let call_group_0_built = CallGroup::RightParenToken(call_group_0_built);
        self.push(ASTType::CallGroup(call_group_0_built), context);
        Ok(())
    }

    /// Semantic action for production 191:
    ///
    /// CallGroup: RightParenLeftBracketToken^ /* Clipped */ ContentTail;
    ///
    #[parol_runtime::function_name::named]
    fn call_group_1(
        &mut self,
        _right_paren_left_bracket_token: &ParseTreeType<'t>,
        _content_tail: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let content_tail = pop_item!(self, content_tail, ContentTail, context);
        // Ignore clipped member 'right_paren_left_bracket_token'
        self.pop(context);
        let call_group_1_built = CallGroupRightParenLeftBracketTokenContentTail {
            // Ignore clipped member 'right_paren_left_bracket_token'
            content_tail: Box::new(content_tail),
        };
        let call_group_1_built =
            CallGroup::RightParenLeftBracketTokenContentTail(call_group_1_built);
        self.push(ASTType::CallGroup(call_group_1_built), context);
        Ok(())
    }

    /// Semantic action for production 192:
    ///
    /// CallOpt /* `Option<T>::Some` */: Args;
    ///
    #[parol_runtime::function_name::named]
    fn call_opt_0(&mut self, _args: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let args = pop_item!(self, args, Args, context);
        let call_opt_0_built = CallOpt {
            args: Box::new(args),
        };
        self.push(ASTType::CallOpt(Some(Box::new(call_opt_0_built))), context);
        Ok(())
    }

    /// Semantic action for production 193:
    ///
    /// CallOpt /* `Option<T>::None` */: ;
    ///
    #[parol_runtime::function_name::named]
    fn call_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::CallOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 194:
    ///
    /// KwMakro: <Code>'makro';
    ///
    #[parol_runtime::function_name::named]
    fn kw_makro(&mut self, kw_makro: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let kw_makro = kw_makro.token()?.clone();
        let kw_makro_built = KwMakro { kw_makro };
        // Calling user action here
        self.user_grammar.kw_makro(&kw_makro_built)?;
        self.push(ASTType::KwMakro(kw_makro_built), context);
        Ok(())
    }

    /// Semantic action for production 195:
    ///
    /// KwFor: <Code>'for';
    ///
    #[parol_runtime::function_name::named]
    fn kw_for(&mut self, kw_for: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let kw_for = kw_for.token()?.clone();
        let kw_for_built = KwFor { kw_for };
        // Calling user action here
        self.user_grammar.kw_for(&kw_for_built)?;
        self.push(ASTType::KwFor(kw_for_built), context);
        Ok(())
    }

    /// Semantic action for production 196:
    ///
    /// KwIn: <Code>'in';
    ///
    #[parol_runtime::function_name::named]
    fn kw_in(&mut self, kw_in: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let kw_in = kw_in.token()?.clone();
        let kw_in_built = KwIn { kw_in };
        // Calling user action here
        self.user_grammar.kw_in(&kw_in_built)?;
        self.push(ASTType::KwIn(kw_in_built), context);
        Ok(())
    }

    /// Semantic action for production 197:
    ///
    /// KwIf: <Code>'if';
    ///
    #[parol_runtime::function_name::named]
    fn kw_if(&mut self, kw_if: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let kw_if = kw_if.token()?.clone();
        let kw_if_built = KwIf { kw_if };
        // Calling user action here
        self.user_grammar.kw_if(&kw_if_built)?;
        self.push(ASTType::KwIf(kw_if_built), context);
        Ok(())
    }

    /// Semantic action for production 198:
    ///
    /// KwElse: <Code>'else';
    ///
    #[parol_runtime::function_name::named]
    fn kw_else(&mut self, kw_else: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let kw_else = kw_else.token()?.clone();
        let kw_else_built = KwElse { kw_else };
        // Calling user action here
        self.user_grammar.kw_else(&kw_else_built)?;
        self.push(ASTType::KwElse(kw_else_built), context);
        Ok(())
    }

    /// Semantic action for production 199:
    ///
    /// KwLet: <Code>'let';
    ///
    #[parol_runtime::function_name::named]
    fn kw_let(&mut self, kw_let: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let kw_let = kw_let.token()?.clone();
        let kw_let_built = KwLet { kw_let };
        // Calling user action here
        self.user_grammar.kw_let(&kw_let_built)?;
        self.push(ASTType::KwLet(kw_let_built), context);
        Ok(())
    }

    /// Semantic action for production 200:
    ///
    /// KwTrue: <Code>'true';
    ///
    #[parol_runtime::function_name::named]
    fn kw_true(&mut self, kw_true: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let kw_true = kw_true.token()?.clone();
        let kw_true_built = KwTrue { kw_true };
        // Calling user action here
        self.user_grammar.kw_true(&kw_true_built)?;
        self.push(ASTType::KwTrue(kw_true_built), context);
        Ok(())
    }

    /// Semantic action for production 201:
    ///
    /// KwFalse: <Code>'false';
    ///
    #[parol_runtime::function_name::named]
    fn kw_false(&mut self, kw_false: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let kw_false = kw_false.token()?.clone();
        let kw_false_built = KwFalse { kw_false };
        // Calling user action here
        self.user_grammar.kw_false(&kw_false_built)?;
        self.push(ASTType::KwFalse(kw_false_built), context);
        Ok(())
    }

    /// Semantic action for production 202:
    ///
    /// Bool: KwTrue;
    ///
    #[parol_runtime::function_name::named]
    fn bool_0(&mut self, _kw_true: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let kw_true = pop_item!(self, kw_true, KwTrue, context);
        let bool_0_built = BoolKwTrue {
            kw_true: Box::new(kw_true),
        };
        let bool_0_built = Bool::KwTrue(bool_0_built);
        // Calling user action here
        self.user_grammar.bool(&bool_0_built)?;
        self.push(ASTType::Bool(bool_0_built), context);
        Ok(())
    }

    /// Semantic action for production 203:
    ///
    /// Bool: KwFalse;
    ///
    #[parol_runtime::function_name::named]
    fn bool_1(&mut self, _kw_false: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let kw_false = pop_item!(self, kw_false, KwFalse, context);
        let bool_1_built = BoolKwFalse {
            kw_false: Box::new(kw_false),
        };
        let bool_1_built = Bool::KwFalse(bool_1_built);
        // Calling user action here
        self.user_grammar.bool(&bool_1_built)?;
        self.push(ASTType::Bool(bool_1_built), context);
        Ok(())
    }

    /// Semantic action for production 204:
    ///
    /// Number: DigitsToken NumberOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn number(
        &mut self,
        _digits_token: &ParseTreeType<'t>,
        _number_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let number_opt = pop_item!(self, number_opt, NumberOpt, context);
        let digits_token = pop_item!(self, digits_token, DigitsToken, context);
        let number_built = Number {
            digits_token: Box::new(digits_token),
            number_opt,
        };
        // Calling user action here
        self.user_grammar.number(&number_built)?;
        self.push(ASTType::Number(number_built), context);
        Ok(())
    }

    /// Semantic action for production 205:
    ///
    /// NumberOpt /* `Option<T>::Some` */: DotToken DigitsToken;
    ///
    #[parol_runtime::function_name::named]
    fn number_opt_0(
        &mut self,
        _dot_token: &ParseTreeType<'t>,
        _digits_token: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let digits_token = pop_item!(self, digits_token, DigitsToken, context);
        let dot_token = pop_item!(self, dot_token, DotToken, context);
        let number_opt_0_built = NumberOpt {
            dot_token: Box::new(dot_token),
            digits_token: Box::new(digits_token),
        };
        self.push(
            ASTType::NumberOpt(Some(Box::new(number_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 206:
    ///
    /// NumberOpt /* `Option<T>::None` */: ;
    ///
    #[parol_runtime::function_name::named]
    fn number_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::NumberOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 207:
    ///
    /// MathBlock: SigilToken %push(Math) Formular %pop() SigilToken;
    ///
    #[parol_runtime::function_name::named]
    fn math_block(
        &mut self,
        _sigil_token: &ParseTreeType<'t>,
        _formular: &ParseTreeType<'t>,
        _sigil_token0: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let sigil_token0 = pop_item!(self, sigil_token0, SigilToken, context);
        let formular = pop_item!(self, formular, Formular, context);
        let sigil_token = pop_item!(self, sigil_token, SigilToken, context);
        let math_block_built = MathBlock {
            sigil_token: Box::new(sigil_token),
            formular: Box::new(formular),
            sigil_token0: Box::new(sigil_token0),
        };
        // Calling user action here
        self.user_grammar.math_block(&math_block_built)?;
        self.push(ASTType::MathBlock(math_block_built), context);
        Ok(())
    }

    /// Semantic action for production 208:
    ///
    /// Formular: Symbol;
    ///
    #[parol_runtime::function_name::named]
    fn formular(&mut self, _symbol: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let symbol = pop_item!(self, symbol, Symbol, context);
        let formular_built = Formular {
            symbol: Box::new(symbol),
        };
        // Calling user action here
        self.user_grammar.formular(&formular_built)?;
        self.push(ASTType::Formular(formular_built), context);
        Ok(())
    }

    /// Semantic action for production 209:
    ///
    /// Symbol: Greek;
    ///
    #[parol_runtime::function_name::named]
    fn symbol_0(&mut self, _greek: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let greek = pop_item!(self, greek, Greek, context);
        let symbol_0_built = SymbolGreek {
            greek: Box::new(greek),
        };
        let symbol_0_built = Symbol::Greek(symbol_0_built);
        // Calling user action here
        self.user_grammar.symbol(&symbol_0_built)?;
        self.push(ASTType::Symbol(symbol_0_built), context);
        Ok(())
    }

    /// Semantic action for production 210:
    ///
    /// Symbol: Variable;
    ///
    #[parol_runtime::function_name::named]
    fn symbol_1(&mut self, _variable: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let variable = pop_item!(self, variable, Variable, context);
        let symbol_1_built = SymbolVariable {
            variable: Box::new(variable),
        };
        let symbol_1_built = Symbol::Variable(symbol_1_built);
        // Calling user action here
        self.user_grammar.symbol(&symbol_1_built)?;
        self.push(ASTType::Symbol(symbol_1_built), context);
        Ok(())
    }

    /// Semantic action for production 211:
    ///
    /// Symbol: DoubleStruck;
    ///
    #[parol_runtime::function_name::named]
    fn symbol_2(&mut self, _double_struck: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let double_struck = pop_item!(self, double_struck, DoubleStruck, context);
        let symbol_2_built = SymbolDoubleStruck {
            double_struck: Box::new(double_struck),
        };
        let symbol_2_built = Symbol::DoubleStruck(symbol_2_built);
        // Calling user action here
        self.user_grammar.symbol(&symbol_2_built)?;
        self.push(ASTType::Symbol(symbol_2_built), context);
        Ok(())
    }

    /// Semantic action for production 212:
    ///
    /// Symbol: Operation;
    ///
    #[parol_runtime::function_name::named]
    fn symbol_3(&mut self, _operation: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operation = pop_item!(self, operation, Operation, context);
        let symbol_3_built = SymbolOperation {
            operation: Box::new(operation),
        };
        let symbol_3_built = Symbol::Operation(symbol_3_built);
        // Calling user action here
        self.user_grammar.symbol(&symbol_3_built)?;
        self.push(ASTType::Symbol(symbol_3_built), context);
        Ok(())
    }

    /// Semantic action for production 213:
    ///
    /// Alpha: <Math>'Alpha';
    ///
    #[parol_runtime::function_name::named]
    fn alpha_0(&mut self, alpha: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let alpha = alpha.token()?.clone();
        let alpha_0_built = AlphaAlpha { alpha };
        let alpha_0_built = Alpha::Alpha(alpha_0_built);
        // Calling user action here
        self.user_grammar.alpha(&alpha_0_built)?;
        self.push(ASTType::Alpha(alpha_0_built), context);
        Ok(())
    }

    /// Semantic action for production 214:
    ///
    /// Alpha: <Math>'alpha';
    ///
    #[parol_runtime::function_name::named]
    fn alpha_1(&mut self, alpha: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let alpha = alpha.token()?.clone();
        let alpha_1_built = AlphaAlpha0 { alpha };
        let alpha_1_built = Alpha::Alpha0(alpha_1_built);
        // Calling user action here
        self.user_grammar.alpha(&alpha_1_built)?;
        self.push(ASTType::Alpha(alpha_1_built), context);
        Ok(())
    }

    /// Semantic action for production 215:
    ///
    /// Beta: <Math>'Beta';
    ///
    #[parol_runtime::function_name::named]
    fn beta_0(&mut self, beta: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let beta = beta.token()?.clone();
        let beta_0_built = BetaBeta { beta };
        let beta_0_built = Beta::Beta(beta_0_built);
        // Calling user action here
        self.user_grammar.beta(&beta_0_built)?;
        self.push(ASTType::Beta(beta_0_built), context);
        Ok(())
    }

    /// Semantic action for production 216:
    ///
    /// Beta: <Math>'beta';
    ///
    #[parol_runtime::function_name::named]
    fn beta_1(&mut self, beta: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let beta = beta.token()?.clone();
        let beta_1_built = BetaBeta0 { beta };
        let beta_1_built = Beta::Beta0(beta_1_built);
        // Calling user action here
        self.user_grammar.beta(&beta_1_built)?;
        self.push(ASTType::Beta(beta_1_built), context);
        Ok(())
    }

    /// Semantic action for production 217:
    ///
    /// Gamma: <Math>'Gamma';
    ///
    #[parol_runtime::function_name::named]
    fn gamma_0(&mut self, gamma: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let gamma = gamma.token()?.clone();
        let gamma_0_built = GammaGamma { gamma };
        let gamma_0_built = Gamma::Gamma(gamma_0_built);
        // Calling user action here
        self.user_grammar.gamma(&gamma_0_built)?;
        self.push(ASTType::Gamma(gamma_0_built), context);
        Ok(())
    }

    /// Semantic action for production 218:
    ///
    /// Gamma: <Math>'gamma';
    ///
    #[parol_runtime::function_name::named]
    fn gamma_1(&mut self, gamma: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let gamma = gamma.token()?.clone();
        let gamma_1_built = GammaGamma0 { gamma };
        let gamma_1_built = Gamma::Gamma0(gamma_1_built);
        // Calling user action here
        self.user_grammar.gamma(&gamma_1_built)?;
        self.push(ASTType::Gamma(gamma_1_built), context);
        Ok(())
    }

    /// Semantic action for production 219:
    ///
    /// Delta: <Math>'Delta';
    ///
    #[parol_runtime::function_name::named]
    fn delta_0(&mut self, delta: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let delta = delta.token()?.clone();
        let delta_0_built = DeltaDelta { delta };
        let delta_0_built = Delta::Delta(delta_0_built);
        // Calling user action here
        self.user_grammar.delta(&delta_0_built)?;
        self.push(ASTType::Delta(delta_0_built), context);
        Ok(())
    }

    /// Semantic action for production 220:
    ///
    /// Delta: <Math>'delta';
    ///
    #[parol_runtime::function_name::named]
    fn delta_1(&mut self, delta: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let delta = delta.token()?.clone();
        let delta_1_built = DeltaDelta0 { delta };
        let delta_1_built = Delta::Delta0(delta_1_built);
        // Calling user action here
        self.user_grammar.delta(&delta_1_built)?;
        self.push(ASTType::Delta(delta_1_built), context);
        Ok(())
    }

    /// Semantic action for production 221:
    ///
    /// Epsilon: <Math>'Epsilon';
    ///
    #[parol_runtime::function_name::named]
    fn epsilon_0(&mut self, epsilon: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let epsilon = epsilon.token()?.clone();
        let epsilon_0_built = EpsilonEpsilon { epsilon };
        let epsilon_0_built = Epsilon::Epsilon(epsilon_0_built);
        // Calling user action here
        self.user_grammar.epsilon(&epsilon_0_built)?;
        self.push(ASTType::Epsilon(epsilon_0_built), context);
        Ok(())
    }

    /// Semantic action for production 222:
    ///
    /// Epsilon: <Math>'epsilon';
    ///
    #[parol_runtime::function_name::named]
    fn epsilon_1(&mut self, epsilon: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let epsilon = epsilon.token()?.clone();
        let epsilon_1_built = EpsilonEpsilon0 { epsilon };
        let epsilon_1_built = Epsilon::Epsilon0(epsilon_1_built);
        // Calling user action here
        self.user_grammar.epsilon(&epsilon_1_built)?;
        self.push(ASTType::Epsilon(epsilon_1_built), context);
        Ok(())
    }

    /// Semantic action for production 223:
    ///
    /// Zeta: <Math>'Zeta';
    ///
    #[parol_runtime::function_name::named]
    fn zeta_0(&mut self, zeta: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let zeta = zeta.token()?.clone();
        let zeta_0_built = ZetaZeta { zeta };
        let zeta_0_built = Zeta::Zeta(zeta_0_built);
        // Calling user action here
        self.user_grammar.zeta(&zeta_0_built)?;
        self.push(ASTType::Zeta(zeta_0_built), context);
        Ok(())
    }

    /// Semantic action for production 224:
    ///
    /// Zeta: <Math>'zeta';
    ///
    #[parol_runtime::function_name::named]
    fn zeta_1(&mut self, zeta: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let zeta = zeta.token()?.clone();
        let zeta_1_built = ZetaZeta0 { zeta };
        let zeta_1_built = Zeta::Zeta0(zeta_1_built);
        // Calling user action here
        self.user_grammar.zeta(&zeta_1_built)?;
        self.push(ASTType::Zeta(zeta_1_built), context);
        Ok(())
    }

    /// Semantic action for production 225:
    ///
    /// Eta: <Math>'Eta';
    ///
    #[parol_runtime::function_name::named]
    fn eta_0(&mut self, eta: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let eta = eta.token()?.clone();
        let eta_0_built = EtaEta { eta };
        let eta_0_built = Eta::Eta(eta_0_built);
        // Calling user action here
        self.user_grammar.eta(&eta_0_built)?;
        self.push(ASTType::Eta(eta_0_built), context);
        Ok(())
    }

    /// Semantic action for production 226:
    ///
    /// Eta: <Math>'eta';
    ///
    #[parol_runtime::function_name::named]
    fn eta_1(&mut self, eta: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let eta = eta.token()?.clone();
        let eta_1_built = EtaEta0 { eta };
        let eta_1_built = Eta::Eta0(eta_1_built);
        // Calling user action here
        self.user_grammar.eta(&eta_1_built)?;
        self.push(ASTType::Eta(eta_1_built), context);
        Ok(())
    }

    /// Semantic action for production 227:
    ///
    /// Theta: <Math>'Theta';
    ///
    #[parol_runtime::function_name::named]
    fn theta_0(&mut self, theta: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let theta = theta.token()?.clone();
        let theta_0_built = ThetaTheta { theta };
        let theta_0_built = Theta::Theta(theta_0_built);
        // Calling user action here
        self.user_grammar.theta(&theta_0_built)?;
        self.push(ASTType::Theta(theta_0_built), context);
        Ok(())
    }

    /// Semantic action for production 228:
    ///
    /// Theta: <Math>'theta';
    ///
    #[parol_runtime::function_name::named]
    fn theta_1(&mut self, theta: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let theta = theta.token()?.clone();
        let theta_1_built = ThetaTheta0 { theta };
        let theta_1_built = Theta::Theta0(theta_1_built);
        // Calling user action here
        self.user_grammar.theta(&theta_1_built)?;
        self.push(ASTType::Theta(theta_1_built), context);
        Ok(())
    }

    /// Semantic action for production 229:
    ///
    /// Iota: <Math>'Iota';
    ///
    #[parol_runtime::function_name::named]
    fn iota_0(&mut self, iota: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let iota = iota.token()?.clone();
        let iota_0_built = IotaIota { iota };
        let iota_0_built = Iota::Iota(iota_0_built);
        // Calling user action here
        self.user_grammar.iota(&iota_0_built)?;
        self.push(ASTType::Iota(iota_0_built), context);
        Ok(())
    }

    /// Semantic action for production 230:
    ///
    /// Iota: <Math>'iota';
    ///
    #[parol_runtime::function_name::named]
    fn iota_1(&mut self, iota: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let iota = iota.token()?.clone();
        let iota_1_built = IotaIota0 { iota };
        let iota_1_built = Iota::Iota0(iota_1_built);
        // Calling user action here
        self.user_grammar.iota(&iota_1_built)?;
        self.push(ASTType::Iota(iota_1_built), context);
        Ok(())
    }

    /// Semantic action for production 231:
    ///
    /// Kappa: <Math>'Kappa';
    ///
    #[parol_runtime::function_name::named]
    fn kappa_0(&mut self, kappa: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let kappa = kappa.token()?.clone();
        let kappa_0_built = KappaKappa { kappa };
        let kappa_0_built = Kappa::Kappa(kappa_0_built);
        // Calling user action here
        self.user_grammar.kappa(&kappa_0_built)?;
        self.push(ASTType::Kappa(kappa_0_built), context);
        Ok(())
    }

    /// Semantic action for production 232:
    ///
    /// Kappa: <Math>'kappa';
    ///
    #[parol_runtime::function_name::named]
    fn kappa_1(&mut self, kappa: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let kappa = kappa.token()?.clone();
        let kappa_1_built = KappaKappa0 { kappa };
        let kappa_1_built = Kappa::Kappa0(kappa_1_built);
        // Calling user action here
        self.user_grammar.kappa(&kappa_1_built)?;
        self.push(ASTType::Kappa(kappa_1_built), context);
        Ok(())
    }

    /// Semantic action for production 233:
    ///
    /// Lambda: <Math>'Lambda';
    ///
    #[parol_runtime::function_name::named]
    fn lambda_0(&mut self, lambda: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let lambda = lambda.token()?.clone();
        let lambda_0_built = LambdaLambda { lambda };
        let lambda_0_built = Lambda::Lambda(lambda_0_built);
        // Calling user action here
        self.user_grammar.lambda(&lambda_0_built)?;
        self.push(ASTType::Lambda(lambda_0_built), context);
        Ok(())
    }

    /// Semantic action for production 234:
    ///
    /// Lambda: <Math>'lambda';
    ///
    #[parol_runtime::function_name::named]
    fn lambda_1(&mut self, lambda: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let lambda = lambda.token()?.clone();
        let lambda_1_built = LambdaLambda0 { lambda };
        let lambda_1_built = Lambda::Lambda0(lambda_1_built);
        // Calling user action here
        self.user_grammar.lambda(&lambda_1_built)?;
        self.push(ASTType::Lambda(lambda_1_built), context);
        Ok(())
    }

    /// Semantic action for production 235:
    ///
    /// Mu: <Math>'Mu';
    ///
    #[parol_runtime::function_name::named]
    fn mu_0(&mut self, mu: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mu = mu.token()?.clone();
        let mu_0_built = MuMu { mu };
        let mu_0_built = Mu::Mu(mu_0_built);
        // Calling user action here
        self.user_grammar.mu(&mu_0_built)?;
        self.push(ASTType::Mu(mu_0_built), context);
        Ok(())
    }

    /// Semantic action for production 236:
    ///
    /// Mu: <Math>'mu';
    ///
    #[parol_runtime::function_name::named]
    fn mu_1(&mut self, mu: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mu = mu.token()?.clone();
        let mu_1_built = MuMu0 { mu };
        let mu_1_built = Mu::Mu0(mu_1_built);
        // Calling user action here
        self.user_grammar.mu(&mu_1_built)?;
        self.push(ASTType::Mu(mu_1_built), context);
        Ok(())
    }

    /// Semantic action for production 237:
    ///
    /// Nu: <Math>'Nu';
    ///
    #[parol_runtime::function_name::named]
    fn nu_0(&mut self, nu: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let nu = nu.token()?.clone();
        let nu_0_built = NuNu { nu };
        let nu_0_built = Nu::Nu(nu_0_built);
        // Calling user action here
        self.user_grammar.nu(&nu_0_built)?;
        self.push(ASTType::Nu(nu_0_built), context);
        Ok(())
    }

    /// Semantic action for production 238:
    ///
    /// Nu: <Math>'nu';
    ///
    #[parol_runtime::function_name::named]
    fn nu_1(&mut self, nu: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let nu = nu.token()?.clone();
        let nu_1_built = NuNu0 { nu };
        let nu_1_built = Nu::Nu0(nu_1_built);
        // Calling user action here
        self.user_grammar.nu(&nu_1_built)?;
        self.push(ASTType::Nu(nu_1_built), context);
        Ok(())
    }

    /// Semantic action for production 239:
    ///
    /// Xi: <Math>'Xi';
    ///
    #[parol_runtime::function_name::named]
    fn xi_0(&mut self, xi: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let xi = xi.token()?.clone();
        let xi_0_built = XiXi { xi };
        let xi_0_built = Xi::Xi(xi_0_built);
        // Calling user action here
        self.user_grammar.xi(&xi_0_built)?;
        self.push(ASTType::Xi(xi_0_built), context);
        Ok(())
    }

    /// Semantic action for production 240:
    ///
    /// Xi: <Math>'xi';
    ///
    #[parol_runtime::function_name::named]
    fn xi_1(&mut self, xi: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let xi = xi.token()?.clone();
        let xi_1_built = XiXi0 { xi };
        let xi_1_built = Xi::Xi0(xi_1_built);
        // Calling user action here
        self.user_grammar.xi(&xi_1_built)?;
        self.push(ASTType::Xi(xi_1_built), context);
        Ok(())
    }

    /// Semantic action for production 241:
    ///
    /// Omicron: <Math>'Omicron';
    ///
    #[parol_runtime::function_name::named]
    fn omicron_0(&mut self, omicron: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let omicron = omicron.token()?.clone();
        let omicron_0_built = OmicronOmicron { omicron };
        let omicron_0_built = Omicron::Omicron(omicron_0_built);
        // Calling user action here
        self.user_grammar.omicron(&omicron_0_built)?;
        self.push(ASTType::Omicron(omicron_0_built), context);
        Ok(())
    }

    /// Semantic action for production 242:
    ///
    /// Omicron: <Math>'omicron';
    ///
    #[parol_runtime::function_name::named]
    fn omicron_1(&mut self, omicron: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let omicron = omicron.token()?.clone();
        let omicron_1_built = OmicronOmicron0 { omicron };
        let omicron_1_built = Omicron::Omicron0(omicron_1_built);
        // Calling user action here
        self.user_grammar.omicron(&omicron_1_built)?;
        self.push(ASTType::Omicron(omicron_1_built), context);
        Ok(())
    }

    /// Semantic action for production 243:
    ///
    /// Pi: <Math>'Pi';
    ///
    #[parol_runtime::function_name::named]
    fn pi_0(&mut self, pi: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let pi = pi.token()?.clone();
        let pi_0_built = PiPi { pi };
        let pi_0_built = Pi::Pi(pi_0_built);
        // Calling user action here
        self.user_grammar.pi(&pi_0_built)?;
        self.push(ASTType::Pi(pi_0_built), context);
        Ok(())
    }

    /// Semantic action for production 244:
    ///
    /// Pi: <Math>'pi';
    ///
    #[parol_runtime::function_name::named]
    fn pi_1(&mut self, pi: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let pi = pi.token()?.clone();
        let pi_1_built = PiPi0 { pi };
        let pi_1_built = Pi::Pi0(pi_1_built);
        // Calling user action here
        self.user_grammar.pi(&pi_1_built)?;
        self.push(ASTType::Pi(pi_1_built), context);
        Ok(())
    }

    /// Semantic action for production 245:
    ///
    /// Pi: <Math>'product';
    ///
    #[parol_runtime::function_name::named]
    fn pi_2(&mut self, product: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let product = product.token()?.clone();
        let pi_2_built = PiProduct { product };
        let pi_2_built = Pi::Product(pi_2_built);
        // Calling user action here
        self.user_grammar.pi(&pi_2_built)?;
        self.push(ASTType::Pi(pi_2_built), context);
        Ok(())
    }

    /// Semantic action for production 246:
    ///
    /// Rho: <Math>'Rho';
    ///
    #[parol_runtime::function_name::named]
    fn rho_0(&mut self, rho: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let rho = rho.token()?.clone();
        let rho_0_built = RhoRho { rho };
        let rho_0_built = Rho::Rho(rho_0_built);
        // Calling user action here
        self.user_grammar.rho(&rho_0_built)?;
        self.push(ASTType::Rho(rho_0_built), context);
        Ok(())
    }

    /// Semantic action for production 247:
    ///
    /// Rho: <Math>'rho';
    ///
    #[parol_runtime::function_name::named]
    fn rho_1(&mut self, rho: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let rho = rho.token()?.clone();
        let rho_1_built = RhoRho0 { rho };
        let rho_1_built = Rho::Rho0(rho_1_built);
        // Calling user action here
        self.user_grammar.rho(&rho_1_built)?;
        self.push(ASTType::Rho(rho_1_built), context);
        Ok(())
    }

    /// Semantic action for production 248:
    ///
    /// Sigma: <Math>'Sigma';
    ///
    #[parol_runtime::function_name::named]
    fn sigma_0(&mut self, sigma: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let sigma = sigma.token()?.clone();
        let sigma_0_built = SigmaSigma { sigma };
        let sigma_0_built = Sigma::Sigma(sigma_0_built);
        // Calling user action here
        self.user_grammar.sigma(&sigma_0_built)?;
        self.push(ASTType::Sigma(sigma_0_built), context);
        Ok(())
    }

    /// Semantic action for production 249:
    ///
    /// Sigma: <Math>'sigma';
    ///
    #[parol_runtime::function_name::named]
    fn sigma_1(&mut self, sigma: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let sigma = sigma.token()?.clone();
        let sigma_1_built = SigmaSigma0 { sigma };
        let sigma_1_built = Sigma::Sigma0(sigma_1_built);
        // Calling user action here
        self.user_grammar.sigma(&sigma_1_built)?;
        self.push(ASTType::Sigma(sigma_1_built), context);
        Ok(())
    }

    /// Semantic action for production 250:
    ///
    /// Sigma: <Math>'sum';
    ///
    #[parol_runtime::function_name::named]
    fn sigma_2(&mut self, sum: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let sum = sum.token()?.clone();
        let sigma_2_built = SigmaSum { sum };
        let sigma_2_built = Sigma::Sum(sigma_2_built);
        // Calling user action here
        self.user_grammar.sigma(&sigma_2_built)?;
        self.push(ASTType::Sigma(sigma_2_built), context);
        Ok(())
    }

    /// Semantic action for production 251:
    ///
    /// Tau: <Math>'Tau';
    ///
    #[parol_runtime::function_name::named]
    fn tau_0(&mut self, tau: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let tau = tau.token()?.clone();
        let tau_0_built = TauTau { tau };
        let tau_0_built = Tau::Tau(tau_0_built);
        // Calling user action here
        self.user_grammar.tau(&tau_0_built)?;
        self.push(ASTType::Tau(tau_0_built), context);
        Ok(())
    }

    /// Semantic action for production 252:
    ///
    /// Tau: <Math>'tau';
    ///
    #[parol_runtime::function_name::named]
    fn tau_1(&mut self, tau: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let tau = tau.token()?.clone();
        let tau_1_built = TauTau0 { tau };
        let tau_1_built = Tau::Tau0(tau_1_built);
        // Calling user action here
        self.user_grammar.tau(&tau_1_built)?;
        self.push(ASTType::Tau(tau_1_built), context);
        Ok(())
    }

    /// Semantic action for production 253:
    ///
    /// Upsilon: <Math>'Upsilon';
    ///
    #[parol_runtime::function_name::named]
    fn upsilon_0(&mut self, upsilon: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let upsilon = upsilon.token()?.clone();
        let upsilon_0_built = UpsilonUpsilon { upsilon };
        let upsilon_0_built = Upsilon::Upsilon(upsilon_0_built);
        // Calling user action here
        self.user_grammar.upsilon(&upsilon_0_built)?;
        self.push(ASTType::Upsilon(upsilon_0_built), context);
        Ok(())
    }

    /// Semantic action for production 254:
    ///
    /// Upsilon: <Math>'upsilon';
    ///
    #[parol_runtime::function_name::named]
    fn upsilon_1(&mut self, upsilon: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let upsilon = upsilon.token()?.clone();
        let upsilon_1_built = UpsilonUpsilon0 { upsilon };
        let upsilon_1_built = Upsilon::Upsilon0(upsilon_1_built);
        // Calling user action here
        self.user_grammar.upsilon(&upsilon_1_built)?;
        self.push(ASTType::Upsilon(upsilon_1_built), context);
        Ok(())
    }

    /// Semantic action for production 255:
    ///
    /// Phi: <Math>'Phi';
    ///
    #[parol_runtime::function_name::named]
    fn phi_0(&mut self, phi: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let phi = phi.token()?.clone();
        let phi_0_built = PhiPhi { phi };
        let phi_0_built = Phi::Phi(phi_0_built);
        // Calling user action here
        self.user_grammar.phi(&phi_0_built)?;
        self.push(ASTType::Phi(phi_0_built), context);
        Ok(())
    }

    /// Semantic action for production 256:
    ///
    /// Phi: <Math>'phi';
    ///
    #[parol_runtime::function_name::named]
    fn phi_1(&mut self, phi: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let phi = phi.token()?.clone();
        let phi_1_built = PhiPhi0 { phi };
        let phi_1_built = Phi::Phi0(phi_1_built);
        // Calling user action here
        self.user_grammar.phi(&phi_1_built)?;
        self.push(ASTType::Phi(phi_1_built), context);
        Ok(())
    }

    /// Semantic action for production 257:
    ///
    /// Chi: <Math>'Chi';
    ///
    #[parol_runtime::function_name::named]
    fn chi_0(&mut self, chi: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let chi = chi.token()?.clone();
        let chi_0_built = ChiChi { chi };
        let chi_0_built = Chi::Chi(chi_0_built);
        // Calling user action here
        self.user_grammar.chi(&chi_0_built)?;
        self.push(ASTType::Chi(chi_0_built), context);
        Ok(())
    }

    /// Semantic action for production 258:
    ///
    /// Chi: <Math>'chi';
    ///
    #[parol_runtime::function_name::named]
    fn chi_1(&mut self, chi: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let chi = chi.token()?.clone();
        let chi_1_built = ChiChi0 { chi };
        let chi_1_built = Chi::Chi0(chi_1_built);
        // Calling user action here
        self.user_grammar.chi(&chi_1_built)?;
        self.push(ASTType::Chi(chi_1_built), context);
        Ok(())
    }

    /// Semantic action for production 259:
    ///
    /// Psi: <Math>'Psi';
    ///
    #[parol_runtime::function_name::named]
    fn psi_0(&mut self, psi: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let psi = psi.token()?.clone();
        let psi_0_built = PsiPsi { psi };
        let psi_0_built = Psi::Psi(psi_0_built);
        // Calling user action here
        self.user_grammar.psi(&psi_0_built)?;
        self.push(ASTType::Psi(psi_0_built), context);
        Ok(())
    }

    /// Semantic action for production 260:
    ///
    /// Psi: <Math>'psi';
    ///
    #[parol_runtime::function_name::named]
    fn psi_1(&mut self, psi: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let psi = psi.token()?.clone();
        let psi_1_built = PsiPsi0 { psi };
        let psi_1_built = Psi::Psi0(psi_1_built);
        // Calling user action here
        self.user_grammar.psi(&psi_1_built)?;
        self.push(ASTType::Psi(psi_1_built), context);
        Ok(())
    }

    /// Semantic action for production 261:
    ///
    /// Omega: <Math>'Omega';
    ///
    #[parol_runtime::function_name::named]
    fn omega_0(&mut self, omega: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let omega = omega.token()?.clone();
        let omega_0_built = OmegaOmega { omega };
        let omega_0_built = Omega::Omega(omega_0_built);
        // Calling user action here
        self.user_grammar.omega(&omega_0_built)?;
        self.push(ASTType::Omega(omega_0_built), context);
        Ok(())
    }

    /// Semantic action for production 262:
    ///
    /// Omega: <Math>'omega';
    ///
    #[parol_runtime::function_name::named]
    fn omega_1(&mut self, omega: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let omega = omega.token()?.clone();
        let omega_1_built = OmegaOmega0 { omega };
        let omega_1_built = Omega::Omega0(omega_1_built);
        // Calling user action here
        self.user_grammar.omega(&omega_1_built)?;
        self.push(ASTType::Omega(omega_1_built), context);
        Ok(())
    }

    /// Semantic action for production 263:
    ///
    /// Greek: Alpha;
    ///
    #[parol_runtime::function_name::named]
    fn greek_0(&mut self, _alpha: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let alpha = pop_item!(self, alpha, Alpha, context);
        let greek_0_built = GreekAlpha {
            alpha: Box::new(alpha),
        };
        let greek_0_built = Greek::Alpha(greek_0_built);
        // Calling user action here
        self.user_grammar.greek(&greek_0_built)?;
        self.push(ASTType::Greek(greek_0_built), context);
        Ok(())
    }

    /// Semantic action for production 264:
    ///
    /// Greek: Beta;
    ///
    #[parol_runtime::function_name::named]
    fn greek_1(&mut self, _beta: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let beta = pop_item!(self, beta, Beta, context);
        let greek_1_built = GreekBeta {
            beta: Box::new(beta),
        };
        let greek_1_built = Greek::Beta(greek_1_built);
        // Calling user action here
        self.user_grammar.greek(&greek_1_built)?;
        self.push(ASTType::Greek(greek_1_built), context);
        Ok(())
    }

    /// Semantic action for production 265:
    ///
    /// Greek: Gamma;
    ///
    #[parol_runtime::function_name::named]
    fn greek_2(&mut self, _gamma: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let gamma = pop_item!(self, gamma, Gamma, context);
        let greek_2_built = GreekGamma {
            gamma: Box::new(gamma),
        };
        let greek_2_built = Greek::Gamma(greek_2_built);
        // Calling user action here
        self.user_grammar.greek(&greek_2_built)?;
        self.push(ASTType::Greek(greek_2_built), context);
        Ok(())
    }

    /// Semantic action for production 266:
    ///
    /// Greek: Delta;
    ///
    #[parol_runtime::function_name::named]
    fn greek_3(&mut self, _delta: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let delta = pop_item!(self, delta, Delta, context);
        let greek_3_built = GreekDelta {
            delta: Box::new(delta),
        };
        let greek_3_built = Greek::Delta(greek_3_built);
        // Calling user action here
        self.user_grammar.greek(&greek_3_built)?;
        self.push(ASTType::Greek(greek_3_built), context);
        Ok(())
    }

    /// Semantic action for production 267:
    ///
    /// Greek: Epsilon;
    ///
    #[parol_runtime::function_name::named]
    fn greek_4(&mut self, _epsilon: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let epsilon = pop_item!(self, epsilon, Epsilon, context);
        let greek_4_built = GreekEpsilon {
            epsilon: Box::new(epsilon),
        };
        let greek_4_built = Greek::Epsilon(greek_4_built);
        // Calling user action here
        self.user_grammar.greek(&greek_4_built)?;
        self.push(ASTType::Greek(greek_4_built), context);
        Ok(())
    }

    /// Semantic action for production 268:
    ///
    /// Greek: Zeta;
    ///
    #[parol_runtime::function_name::named]
    fn greek_5(&mut self, _zeta: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let zeta = pop_item!(self, zeta, Zeta, context);
        let greek_5_built = GreekZeta {
            zeta: Box::new(zeta),
        };
        let greek_5_built = Greek::Zeta(greek_5_built);
        // Calling user action here
        self.user_grammar.greek(&greek_5_built)?;
        self.push(ASTType::Greek(greek_5_built), context);
        Ok(())
    }

    /// Semantic action for production 269:
    ///
    /// Greek: Eta;
    ///
    #[parol_runtime::function_name::named]
    fn greek_6(&mut self, _eta: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let eta = pop_item!(self, eta, Eta, context);
        let greek_6_built = GreekEta { eta: Box::new(eta) };
        let greek_6_built = Greek::Eta(greek_6_built);
        // Calling user action here
        self.user_grammar.greek(&greek_6_built)?;
        self.push(ASTType::Greek(greek_6_built), context);
        Ok(())
    }

    /// Semantic action for production 270:
    ///
    /// Greek: Theta;
    ///
    #[parol_runtime::function_name::named]
    fn greek_7(&mut self, _theta: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let theta = pop_item!(self, theta, Theta, context);
        let greek_7_built = GreekTheta {
            theta: Box::new(theta),
        };
        let greek_7_built = Greek::Theta(greek_7_built);
        // Calling user action here
        self.user_grammar.greek(&greek_7_built)?;
        self.push(ASTType::Greek(greek_7_built), context);
        Ok(())
    }

    /// Semantic action for production 271:
    ///
    /// Greek: Iota;
    ///
    #[parol_runtime::function_name::named]
    fn greek_8(&mut self, _iota: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let iota = pop_item!(self, iota, Iota, context);
        let greek_8_built = GreekIota {
            iota: Box::new(iota),
        };
        let greek_8_built = Greek::Iota(greek_8_built);
        // Calling user action here
        self.user_grammar.greek(&greek_8_built)?;
        self.push(ASTType::Greek(greek_8_built), context);
        Ok(())
    }

    /// Semantic action for production 272:
    ///
    /// Greek: Kappa;
    ///
    #[parol_runtime::function_name::named]
    fn greek_9(&mut self, _kappa: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let kappa = pop_item!(self, kappa, Kappa, context);
        let greek_9_built = GreekKappa {
            kappa: Box::new(kappa),
        };
        let greek_9_built = Greek::Kappa(greek_9_built);
        // Calling user action here
        self.user_grammar.greek(&greek_9_built)?;
        self.push(ASTType::Greek(greek_9_built), context);
        Ok(())
    }

    /// Semantic action for production 273:
    ///
    /// Greek: Lambda;
    ///
    #[parol_runtime::function_name::named]
    fn greek_10(&mut self, _lambda: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let lambda = pop_item!(self, lambda, Lambda, context);
        let greek_10_built = GreekLambda {
            lambda: Box::new(lambda),
        };
        let greek_10_built = Greek::Lambda(greek_10_built);
        // Calling user action here
        self.user_grammar.greek(&greek_10_built)?;
        self.push(ASTType::Greek(greek_10_built), context);
        Ok(())
    }

    /// Semantic action for production 274:
    ///
    /// Greek: Mu;
    ///
    #[parol_runtime::function_name::named]
    fn greek_11(&mut self, _mu: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mu = pop_item!(self, mu, Mu, context);
        let greek_11_built = GreekMu { mu: Box::new(mu) };
        let greek_11_built = Greek::Mu(greek_11_built);
        // Calling user action here
        self.user_grammar.greek(&greek_11_built)?;
        self.push(ASTType::Greek(greek_11_built), context);
        Ok(())
    }

    /// Semantic action for production 275:
    ///
    /// Greek: Nu;
    ///
    #[parol_runtime::function_name::named]
    fn greek_12(&mut self, _nu: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let nu = pop_item!(self, nu, Nu, context);
        let greek_12_built = GreekNu { nu: Box::new(nu) };
        let greek_12_built = Greek::Nu(greek_12_built);
        // Calling user action here
        self.user_grammar.greek(&greek_12_built)?;
        self.push(ASTType::Greek(greek_12_built), context);
        Ok(())
    }

    /// Semantic action for production 276:
    ///
    /// Greek: Xi;
    ///
    #[parol_runtime::function_name::named]
    fn greek_13(&mut self, _xi: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let xi = pop_item!(self, xi, Xi, context);
        let greek_13_built = GreekXi { xi: Box::new(xi) };
        let greek_13_built = Greek::Xi(greek_13_built);
        // Calling user action here
        self.user_grammar.greek(&greek_13_built)?;
        self.push(ASTType::Greek(greek_13_built), context);
        Ok(())
    }

    /// Semantic action for production 277:
    ///
    /// Greek: Omicron;
    ///
    #[parol_runtime::function_name::named]
    fn greek_14(&mut self, _omicron: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let omicron = pop_item!(self, omicron, Omicron, context);
        let greek_14_built = GreekOmicron {
            omicron: Box::new(omicron),
        };
        let greek_14_built = Greek::Omicron(greek_14_built);
        // Calling user action here
        self.user_grammar.greek(&greek_14_built)?;
        self.push(ASTType::Greek(greek_14_built), context);
        Ok(())
    }

    /// Semantic action for production 278:
    ///
    /// Greek: Pi;
    ///
    #[parol_runtime::function_name::named]
    fn greek_15(&mut self, _pi: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let pi = pop_item!(self, pi, Pi, context);
        let greek_15_built = GreekPi { pi: Box::new(pi) };
        let greek_15_built = Greek::Pi(greek_15_built);
        // Calling user action here
        self.user_grammar.greek(&greek_15_built)?;
        self.push(ASTType::Greek(greek_15_built), context);
        Ok(())
    }

    /// Semantic action for production 279:
    ///
    /// Greek: Rho;
    ///
    #[parol_runtime::function_name::named]
    fn greek_16(&mut self, _rho: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let rho = pop_item!(self, rho, Rho, context);
        let greek_16_built = GreekRho { rho: Box::new(rho) };
        let greek_16_built = Greek::Rho(greek_16_built);
        // Calling user action here
        self.user_grammar.greek(&greek_16_built)?;
        self.push(ASTType::Greek(greek_16_built), context);
        Ok(())
    }

    /// Semantic action for production 280:
    ///
    /// Greek: Sigma;
    ///
    #[parol_runtime::function_name::named]
    fn greek_17(&mut self, _sigma: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let sigma = pop_item!(self, sigma, Sigma, context);
        let greek_17_built = GreekSigma {
            sigma: Box::new(sigma),
        };
        let greek_17_built = Greek::Sigma(greek_17_built);
        // Calling user action here
        self.user_grammar.greek(&greek_17_built)?;
        self.push(ASTType::Greek(greek_17_built), context);
        Ok(())
    }

    /// Semantic action for production 281:
    ///
    /// Greek: Tau;
    ///
    #[parol_runtime::function_name::named]
    fn greek_18(&mut self, _tau: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let tau = pop_item!(self, tau, Tau, context);
        let greek_18_built = GreekTau { tau: Box::new(tau) };
        let greek_18_built = Greek::Tau(greek_18_built);
        // Calling user action here
        self.user_grammar.greek(&greek_18_built)?;
        self.push(ASTType::Greek(greek_18_built), context);
        Ok(())
    }

    /// Semantic action for production 282:
    ///
    /// Greek: Upsilon;
    ///
    #[parol_runtime::function_name::named]
    fn greek_19(&mut self, _upsilon: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let upsilon = pop_item!(self, upsilon, Upsilon, context);
        let greek_19_built = GreekUpsilon {
            upsilon: Box::new(upsilon),
        };
        let greek_19_built = Greek::Upsilon(greek_19_built);
        // Calling user action here
        self.user_grammar.greek(&greek_19_built)?;
        self.push(ASTType::Greek(greek_19_built), context);
        Ok(())
    }

    /// Semantic action for production 283:
    ///
    /// Greek: Phi;
    ///
    #[parol_runtime::function_name::named]
    fn greek_20(&mut self, _phi: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let phi = pop_item!(self, phi, Phi, context);
        let greek_20_built = GreekPhi { phi: Box::new(phi) };
        let greek_20_built = Greek::Phi(greek_20_built);
        // Calling user action here
        self.user_grammar.greek(&greek_20_built)?;
        self.push(ASTType::Greek(greek_20_built), context);
        Ok(())
    }

    /// Semantic action for production 284:
    ///
    /// Greek: Chi;
    ///
    #[parol_runtime::function_name::named]
    fn greek_21(&mut self, _chi: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let chi = pop_item!(self, chi, Chi, context);
        let greek_21_built = GreekChi { chi: Box::new(chi) };
        let greek_21_built = Greek::Chi(greek_21_built);
        // Calling user action here
        self.user_grammar.greek(&greek_21_built)?;
        self.push(ASTType::Greek(greek_21_built), context);
        Ok(())
    }

    /// Semantic action for production 285:
    ///
    /// Greek: Psi;
    ///
    #[parol_runtime::function_name::named]
    fn greek_22(&mut self, _psi: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let psi = pop_item!(self, psi, Psi, context);
        let greek_22_built = GreekPsi { psi: Box::new(psi) };
        let greek_22_built = Greek::Psi(greek_22_built);
        // Calling user action here
        self.user_grammar.greek(&greek_22_built)?;
        self.push(ASTType::Greek(greek_22_built), context);
        Ok(())
    }

    /// Semantic action for production 286:
    ///
    /// Greek: Omega;
    ///
    #[parol_runtime::function_name::named]
    fn greek_23(&mut self, _omega: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let omega = pop_item!(self, omega, Omega, context);
        let greek_23_built = GreekOmega {
            omega: Box::new(omega),
        };
        let greek_23_built = Greek::Omega(greek_23_built);
        // Calling user action here
        self.user_grammar.greek(&greek_23_built)?;
        self.push(ASTType::Greek(greek_23_built), context);
        Ok(())
    }

    /// Semantic action for production 287:
    ///
    /// DoubleStruck: <Math>'AA';
    ///
    #[parol_runtime::function_name::named]
    fn double_struck_0(&mut self, a_a: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let a_a = a_a.token()?.clone();
        let double_struck_0_built = DoubleStruckAA { a_a };
        let double_struck_0_built = DoubleStruck::AA(double_struck_0_built);
        // Calling user action here
        self.user_grammar.double_struck(&double_struck_0_built)?;
        self.push(ASTType::DoubleStruck(double_struck_0_built), context);
        Ok(())
    }

    /// Semantic action for production 288:
    ///
    /// DoubleStruck: <Math>'BB';
    ///
    #[parol_runtime::function_name::named]
    fn double_struck_1(&mut self, b_b: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let b_b = b_b.token()?.clone();
        let double_struck_1_built = DoubleStruckBB { b_b };
        let double_struck_1_built = DoubleStruck::BB(double_struck_1_built);
        // Calling user action here
        self.user_grammar.double_struck(&double_struck_1_built)?;
        self.push(ASTType::DoubleStruck(double_struck_1_built), context);
        Ok(())
    }

    /// Semantic action for production 289:
    ///
    /// DoubleStruck: <Math>'CC';
    ///
    #[parol_runtime::function_name::named]
    fn double_struck_2(&mut self, c_c: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let c_c = c_c.token()?.clone();
        let double_struck_2_built = DoubleStruckCC { c_c };
        let double_struck_2_built = DoubleStruck::CC(double_struck_2_built);
        // Calling user action here
        self.user_grammar.double_struck(&double_struck_2_built)?;
        self.push(ASTType::DoubleStruck(double_struck_2_built), context);
        Ok(())
    }

    /// Semantic action for production 290:
    ///
    /// DoubleStruck: <Math>'DD';
    ///
    #[parol_runtime::function_name::named]
    fn double_struck_3(&mut self, d_d: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let d_d = d_d.token()?.clone();
        let double_struck_3_built = DoubleStruckDD { d_d };
        let double_struck_3_built = DoubleStruck::DD(double_struck_3_built);
        // Calling user action here
        self.user_grammar.double_struck(&double_struck_3_built)?;
        self.push(ASTType::DoubleStruck(double_struck_3_built), context);
        Ok(())
    }

    /// Semantic action for production 291:
    ///
    /// DoubleStruck: <Math>'EE';
    ///
    #[parol_runtime::function_name::named]
    fn double_struck_4(&mut self, e_e: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let e_e = e_e.token()?.clone();
        let double_struck_4_built = DoubleStruckEE { e_e };
        let double_struck_4_built = DoubleStruck::EE(double_struck_4_built);
        // Calling user action here
        self.user_grammar.double_struck(&double_struck_4_built)?;
        self.push(ASTType::DoubleStruck(double_struck_4_built), context);
        Ok(())
    }

    /// Semantic action for production 292:
    ///
    /// DoubleStruck: <Math>'FF';
    ///
    #[parol_runtime::function_name::named]
    fn double_struck_5(&mut self, f_f: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let f_f = f_f.token()?.clone();
        let double_struck_5_built = DoubleStruckFF { f_f };
        let double_struck_5_built = DoubleStruck::FF(double_struck_5_built);
        // Calling user action here
        self.user_grammar.double_struck(&double_struck_5_built)?;
        self.push(ASTType::DoubleStruck(double_struck_5_built), context);
        Ok(())
    }

    /// Semantic action for production 293:
    ///
    /// DoubleStruck: <Math>'GG';
    ///
    #[parol_runtime::function_name::named]
    fn double_struck_6(&mut self, g_g: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let g_g = g_g.token()?.clone();
        let double_struck_6_built = DoubleStruckGG { g_g };
        let double_struck_6_built = DoubleStruck::GG(double_struck_6_built);
        // Calling user action here
        self.user_grammar.double_struck(&double_struck_6_built)?;
        self.push(ASTType::DoubleStruck(double_struck_6_built), context);
        Ok(())
    }

    /// Semantic action for production 294:
    ///
    /// DoubleStruck: <Math>'HH';
    ///
    #[parol_runtime::function_name::named]
    fn double_struck_7(&mut self, h_h: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let h_h = h_h.token()?.clone();
        let double_struck_7_built = DoubleStruckHH { h_h };
        let double_struck_7_built = DoubleStruck::HH(double_struck_7_built);
        // Calling user action here
        self.user_grammar.double_struck(&double_struck_7_built)?;
        self.push(ASTType::DoubleStruck(double_struck_7_built), context);
        Ok(())
    }

    /// Semantic action for production 295:
    ///
    /// DoubleStruck: <Math>'II';
    ///
    #[parol_runtime::function_name::named]
    fn double_struck_8(&mut self, i_i: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let i_i = i_i.token()?.clone();
        let double_struck_8_built = DoubleStruckII { i_i };
        let double_struck_8_built = DoubleStruck::II(double_struck_8_built);
        // Calling user action here
        self.user_grammar.double_struck(&double_struck_8_built)?;
        self.push(ASTType::DoubleStruck(double_struck_8_built), context);
        Ok(())
    }

    /// Semantic action for production 296:
    ///
    /// DoubleStruck: <Math>'JJ';
    ///
    #[parol_runtime::function_name::named]
    fn double_struck_9(&mut self, j_j: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let j_j = j_j.token()?.clone();
        let double_struck_9_built = DoubleStruckJJ { j_j };
        let double_struck_9_built = DoubleStruck::JJ(double_struck_9_built);
        // Calling user action here
        self.user_grammar.double_struck(&double_struck_9_built)?;
        self.push(ASTType::DoubleStruck(double_struck_9_built), context);
        Ok(())
    }

    /// Semantic action for production 297:
    ///
    /// DoubleStruck: <Math>'KK';
    ///
    #[parol_runtime::function_name::named]
    fn double_struck_10(&mut self, k_k: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let k_k = k_k.token()?.clone();
        let double_struck_10_built = DoubleStruckKK { k_k };
        let double_struck_10_built = DoubleStruck::KK(double_struck_10_built);
        // Calling user action here
        self.user_grammar.double_struck(&double_struck_10_built)?;
        self.push(ASTType::DoubleStruck(double_struck_10_built), context);
        Ok(())
    }

    /// Semantic action for production 298:
    ///
    /// DoubleStruck: <Math>'LL';
    ///
    #[parol_runtime::function_name::named]
    fn double_struck_11(&mut self, l_l: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_l = l_l.token()?.clone();
        let double_struck_11_built = DoubleStruckLL { l_l };
        let double_struck_11_built = DoubleStruck::LL(double_struck_11_built);
        // Calling user action here
        self.user_grammar.double_struck(&double_struck_11_built)?;
        self.push(ASTType::DoubleStruck(double_struck_11_built), context);
        Ok(())
    }

    /// Semantic action for production 299:
    ///
    /// DoubleStruck: <Math>'MM';
    ///
    #[parol_runtime::function_name::named]
    fn double_struck_12(&mut self, m_m: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let m_m = m_m.token()?.clone();
        let double_struck_12_built = DoubleStruckMM { m_m };
        let double_struck_12_built = DoubleStruck::MM(double_struck_12_built);
        // Calling user action here
        self.user_grammar.double_struck(&double_struck_12_built)?;
        self.push(ASTType::DoubleStruck(double_struck_12_built), context);
        Ok(())
    }

    /// Semantic action for production 300:
    ///
    /// DoubleStruck: <Math>'NN';
    ///
    #[parol_runtime::function_name::named]
    fn double_struck_13(&mut self, n_n: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let n_n = n_n.token()?.clone();
        let double_struck_13_built = DoubleStruckNN { n_n };
        let double_struck_13_built = DoubleStruck::NN(double_struck_13_built);
        // Calling user action here
        self.user_grammar.double_struck(&double_struck_13_built)?;
        self.push(ASTType::DoubleStruck(double_struck_13_built), context);
        Ok(())
    }

    /// Semantic action for production 301:
    ///
    /// DoubleStruck: <Math>'OO';
    ///
    #[parol_runtime::function_name::named]
    fn double_struck_14(&mut self, o_o: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let o_o = o_o.token()?.clone();
        let double_struck_14_built = DoubleStruckOO { o_o };
        let double_struck_14_built = DoubleStruck::OO(double_struck_14_built);
        // Calling user action here
        self.user_grammar.double_struck(&double_struck_14_built)?;
        self.push(ASTType::DoubleStruck(double_struck_14_built), context);
        Ok(())
    }

    /// Semantic action for production 302:
    ///
    /// DoubleStruck: <Math>'PP';
    ///
    #[parol_runtime::function_name::named]
    fn double_struck_15(&mut self, p_p: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let p_p = p_p.token()?.clone();
        let double_struck_15_built = DoubleStruckPP { p_p };
        let double_struck_15_built = DoubleStruck::PP(double_struck_15_built);
        // Calling user action here
        self.user_grammar.double_struck(&double_struck_15_built)?;
        self.push(ASTType::DoubleStruck(double_struck_15_built), context);
        Ok(())
    }

    /// Semantic action for production 303:
    ///
    /// DoubleStruck: <Math>'QQ';
    ///
    #[parol_runtime::function_name::named]
    fn double_struck_16(&mut self, q_q: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let q_q = q_q.token()?.clone();
        let double_struck_16_built = DoubleStruckQQ { q_q };
        let double_struck_16_built = DoubleStruck::QQ(double_struck_16_built);
        // Calling user action here
        self.user_grammar.double_struck(&double_struck_16_built)?;
        self.push(ASTType::DoubleStruck(double_struck_16_built), context);
        Ok(())
    }

    /// Semantic action for production 304:
    ///
    /// DoubleStruck: <Math>'RR';
    ///
    #[parol_runtime::function_name::named]
    fn double_struck_17(&mut self, r_r: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_r = r_r.token()?.clone();
        let double_struck_17_built = DoubleStruckRR { r_r };
        let double_struck_17_built = DoubleStruck::RR(double_struck_17_built);
        // Calling user action here
        self.user_grammar.double_struck(&double_struck_17_built)?;
        self.push(ASTType::DoubleStruck(double_struck_17_built), context);
        Ok(())
    }

    /// Semantic action for production 305:
    ///
    /// DoubleStruck: <Math>'SS';
    ///
    #[parol_runtime::function_name::named]
    fn double_struck_18(&mut self, s_s: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let s_s = s_s.token()?.clone();
        let double_struck_18_built = DoubleStruckSS { s_s };
        let double_struck_18_built = DoubleStruck::SS(double_struck_18_built);
        // Calling user action here
        self.user_grammar.double_struck(&double_struck_18_built)?;
        self.push(ASTType::DoubleStruck(double_struck_18_built), context);
        Ok(())
    }

    /// Semantic action for production 306:
    ///
    /// DoubleStruck: <Math>'TT';
    ///
    #[parol_runtime::function_name::named]
    fn double_struck_19(&mut self, t_t: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let t_t = t_t.token()?.clone();
        let double_struck_19_built = DoubleStruckTT { t_t };
        let double_struck_19_built = DoubleStruck::TT(double_struck_19_built);
        // Calling user action here
        self.user_grammar.double_struck(&double_struck_19_built)?;
        self.push(ASTType::DoubleStruck(double_struck_19_built), context);
        Ok(())
    }

    /// Semantic action for production 307:
    ///
    /// DoubleStruck: <Math>'UU';
    ///
    #[parol_runtime::function_name::named]
    fn double_struck_20(&mut self, u_u: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let u_u = u_u.token()?.clone();
        let double_struck_20_built = DoubleStruckUU { u_u };
        let double_struck_20_built = DoubleStruck::UU(double_struck_20_built);
        // Calling user action here
        self.user_grammar.double_struck(&double_struck_20_built)?;
        self.push(ASTType::DoubleStruck(double_struck_20_built), context);
        Ok(())
    }

    /// Semantic action for production 308:
    ///
    /// DoubleStruck: <Math>'VV';
    ///
    #[parol_runtime::function_name::named]
    fn double_struck_21(&mut self, v_v: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let v_v = v_v.token()?.clone();
        let double_struck_21_built = DoubleStruckVV { v_v };
        let double_struck_21_built = DoubleStruck::VV(double_struck_21_built);
        // Calling user action here
        self.user_grammar.double_struck(&double_struck_21_built)?;
        self.push(ASTType::DoubleStruck(double_struck_21_built), context);
        Ok(())
    }

    /// Semantic action for production 309:
    ///
    /// DoubleStruck: <Math>'WW';
    ///
    #[parol_runtime::function_name::named]
    fn double_struck_22(&mut self, w_w: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let w_w = w_w.token()?.clone();
        let double_struck_22_built = DoubleStruckWW { w_w };
        let double_struck_22_built = DoubleStruck::WW(double_struck_22_built);
        // Calling user action here
        self.user_grammar.double_struck(&double_struck_22_built)?;
        self.push(ASTType::DoubleStruck(double_struck_22_built), context);
        Ok(())
    }

    /// Semantic action for production 310:
    ///
    /// DoubleStruck: <Math>'XX';
    ///
    #[parol_runtime::function_name::named]
    fn double_struck_23(&mut self, x_x: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let x_x = x_x.token()?.clone();
        let double_struck_23_built = DoubleStruckXX { x_x };
        let double_struck_23_built = DoubleStruck::XX(double_struck_23_built);
        // Calling user action here
        self.user_grammar.double_struck(&double_struck_23_built)?;
        self.push(ASTType::DoubleStruck(double_struck_23_built), context);
        Ok(())
    }

    /// Semantic action for production 311:
    ///
    /// DoubleStruck: <Math>'YY';
    ///
    #[parol_runtime::function_name::named]
    fn double_struck_24(&mut self, y_y: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let y_y = y_y.token()?.clone();
        let double_struck_24_built = DoubleStruckYY { y_y };
        let double_struck_24_built = DoubleStruck::YY(double_struck_24_built);
        // Calling user action here
        self.user_grammar.double_struck(&double_struck_24_built)?;
        self.push(ASTType::DoubleStruck(double_struck_24_built), context);
        Ok(())
    }

    /// Semantic action for production 312:
    ///
    /// DoubleStruck: <Math>'ZZ';
    ///
    #[parol_runtime::function_name::named]
    fn double_struck_25(&mut self, z_z: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let z_z = z_z.token()?.clone();
        let double_struck_25_built = DoubleStruckZZ { z_z };
        let double_struck_25_built = DoubleStruck::ZZ(double_struck_25_built);
        // Calling user action here
        self.user_grammar.double_struck(&double_struck_25_built)?;
        self.push(ASTType::DoubleStruck(double_struck_25_built), context);
        Ok(())
    }

    /// Semantic action for production 313:
    ///
    /// Not: <Math>'not';
    ///
    #[parol_runtime::function_name::named]
    fn not(&mut self, not: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let not = not.token()?.clone();
        let not_built = Not { not };
        // Calling user action here
        self.user_grammar.not(&not_built)?;
        self.push(ASTType::Not(not_built), context);
        Ok(())
    }

    /// Semantic action for production 314:
    ///
    /// And: <Math>'and';
    ///
    #[parol_runtime::function_name::named]
    fn and(&mut self, and: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let and = and.token()?.clone();
        let and_built = And { and };
        // Calling user action here
        self.user_grammar.and(&and_built)?;
        self.push(ASTType::And(and_built), context);
        Ok(())
    }

    /// Semantic action for production 315:
    ///
    /// Or: <Math>'or';
    ///
    #[parol_runtime::function_name::named]
    fn or(&mut self, or: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let or = or.token()?.clone();
        let or_built = Or { or };
        // Calling user action here
        self.user_grammar.or(&or_built)?;
        self.push(ASTType::Or(or_built), context);
        Ok(())
    }

    /// Semantic action for production 316:
    ///
    /// ForAll: <Math>'forall';
    ///
    #[parol_runtime::function_name::named]
    fn for_all(&mut self, for_all: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let for_all = for_all.token()?.clone();
        let for_all_built = ForAll { for_all };
        // Calling user action here
        self.user_grammar.for_all(&for_all_built)?;
        self.push(ASTType::ForAll(for_all_built), context);
        Ok(())
    }

    /// Semantic action for production 317:
    ///
    /// Exists: <Math>'exists';
    ///
    #[parol_runtime::function_name::named]
    fn exists(&mut self, exists: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let exists = exists.token()?.clone();
        let exists_built = Exists { exists };
        // Calling user action here
        self.user_grammar.exists(&exists_built)?;
        self.push(ASTType::Exists(exists_built), context);
        Ok(())
    }

    /// Semantic action for production 318:
    ///
    /// Left: <Math>'left';
    ///
    #[parol_runtime::function_name::named]
    fn left(&mut self, left: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let left = left.token()?.clone();
        let left_built = Left { left };
        // Calling user action here
        self.user_grammar.left(&left_built)?;
        self.push(ASTType::Left(left_built), context);
        Ok(())
    }

    /// Semantic action for production 319:
    ///
    /// Right: <Math>'right';
    ///
    #[parol_runtime::function_name::named]
    fn right(&mut self, right: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let right = right.token()?.clone();
        let right_built = Right { right };
        // Calling user action here
        self.user_grammar.right(&right_built)?;
        self.push(ASTType::Right(right_built), context);
        Ok(())
    }

    /// Semantic action for production 320:
    ///
    /// Top: <Math>'top';
    ///
    #[parol_runtime::function_name::named]
    fn top(&mut self, top: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let top = top.token()?.clone();
        let top_built = Top { top };
        // Calling user action here
        self.user_grammar.top(&top_built)?;
        self.push(ASTType::Top(top_built), context);
        Ok(())
    }

    /// Semantic action for production 321:
    ///
    /// Bot: <Math>'bot';
    ///
    #[parol_runtime::function_name::named]
    fn bot(&mut self, bot: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bot = bot.token()?.clone();
        let bot_built = Bot { bot };
        // Calling user action here
        self.user_grammar.bot(&bot_built)?;
        self.push(ASTType::Bot(bot_built), context);
        Ok(())
    }

    /// Semantic action for production 322:
    ///
    /// Tack: <Math>'tack' TackOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn tack(&mut self, tack: &ParseTreeType<'t>, _tack_opt: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let tack = tack.token()?.clone();
        let tack_opt = pop_item!(self, tack_opt, TackOpt, context);
        let tack_built = Tack { tack, tack_opt };
        // Calling user action here
        self.user_grammar.tack(&tack_built)?;
        self.push(ASTType::Tack(tack_built), context);
        Ok(())
    }

    /// Semantic action for production 323:
    ///
    /// TackOpt /* `Option<T>::Some` */: DotToken TackOptGroup;
    ///
    #[parol_runtime::function_name::named]
    fn tack_opt_0(
        &mut self,
        _dot_token: &ParseTreeType<'t>,
        _tack_opt_group: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let tack_opt_group = pop_item!(self, tack_opt_group, TackOptGroup, context);
        let dot_token = pop_item!(self, dot_token, DotToken, context);
        let tack_opt_0_built = TackOpt {
            dot_token: Box::new(dot_token),
            tack_opt_group: Box::new(tack_opt_group),
        };
        self.push(ASTType::TackOpt(Some(Box::new(tack_opt_0_built))), context);
        Ok(())
    }

    /// Semantic action for production 324:
    ///
    /// TackOptGroup: Left;
    ///
    #[parol_runtime::function_name::named]
    fn tack_opt_group_0(&mut self, _left: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let left = pop_item!(self, left, Left, context);
        let tack_opt_group_0_built = TackOptGroupLeft {
            left: Box::new(left),
        };
        let tack_opt_group_0_built = TackOptGroup::Left(tack_opt_group_0_built);
        self.push(ASTType::TackOptGroup(tack_opt_group_0_built), context);
        Ok(())
    }

    /// Semantic action for production 325:
    ///
    /// TackOptGroup: Right;
    ///
    #[parol_runtime::function_name::named]
    fn tack_opt_group_1(&mut self, _right: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let right = pop_item!(self, right, Right, context);
        let tack_opt_group_1_built = TackOptGroupRight {
            right: Box::new(right),
        };
        let tack_opt_group_1_built = TackOptGroup::Right(tack_opt_group_1_built);
        self.push(ASTType::TackOptGroup(tack_opt_group_1_built), context);
        Ok(())
    }

    /// Semantic action for production 326:
    ///
    /// TackOptGroup: Top;
    ///
    #[parol_runtime::function_name::named]
    fn tack_opt_group_2(&mut self, _top: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let top = pop_item!(self, top, Top, context);
        let tack_opt_group_2_built = TackOptGroupTop { top: Box::new(top) };
        let tack_opt_group_2_built = TackOptGroup::Top(tack_opt_group_2_built);
        self.push(ASTType::TackOptGroup(tack_opt_group_2_built), context);
        Ok(())
    }

    /// Semantic action for production 327:
    ///
    /// TackOptGroup: Bot;
    ///
    #[parol_runtime::function_name::named]
    fn tack_opt_group_3(&mut self, _bot: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bot = pop_item!(self, bot, Bot, context);
        let tack_opt_group_3_built = TackOptGroupBot { bot: Box::new(bot) };
        let tack_opt_group_3_built = TackOptGroup::Bot(tack_opt_group_3_built);
        self.push(ASTType::TackOptGroup(tack_opt_group_3_built), context);
        Ok(())
    }

    /// Semantic action for production 328:
    ///
    /// TackOpt /* `Option<T>::None` */: ;
    ///
    #[parol_runtime::function_name::named]
    fn tack_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::TackOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 329:
    ///
    /// Logical: And;
    ///
    #[parol_runtime::function_name::named]
    fn logical_0(&mut self, _and: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let and = pop_item!(self, and, And, context);
        let logical_0_built = LogicalAnd { and: Box::new(and) };
        let logical_0_built = Logical::And(logical_0_built);
        // Calling user action here
        self.user_grammar.logical(&logical_0_built)?;
        self.push(ASTType::Logical(logical_0_built), context);
        Ok(())
    }

    /// Semantic action for production 330:
    ///
    /// Logical: Or;
    ///
    #[parol_runtime::function_name::named]
    fn logical_1(&mut self, _or: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let or = pop_item!(self, or, Or, context);
        let logical_1_built = LogicalOr { or: Box::new(or) };
        let logical_1_built = Logical::Or(logical_1_built);
        // Calling user action here
        self.user_grammar.logical(&logical_1_built)?;
        self.push(ASTType::Logical(logical_1_built), context);
        Ok(())
    }

    /// Semantic action for production 331:
    ///
    /// Logical: Not;
    ///
    #[parol_runtime::function_name::named]
    fn logical_2(&mut self, _not: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let not = pop_item!(self, not, Not, context);
        let logical_2_built = LogicalNot { not: Box::new(not) };
        let logical_2_built = Logical::Not(logical_2_built);
        // Calling user action here
        self.user_grammar.logical(&logical_2_built)?;
        self.push(ASTType::Logical(logical_2_built), context);
        Ok(())
    }

    /// Semantic action for production 332:
    ///
    /// Logical: ForAll;
    ///
    #[parol_runtime::function_name::named]
    fn logical_3(&mut self, _for_all: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let for_all = pop_item!(self, for_all, ForAll, context);
        let logical_3_built = LogicalForAll {
            for_all: Box::new(for_all),
        };
        let logical_3_built = Logical::ForAll(logical_3_built);
        // Calling user action here
        self.user_grammar.logical(&logical_3_built)?;
        self.push(ASTType::Logical(logical_3_built), context);
        Ok(())
    }

    /// Semantic action for production 333:
    ///
    /// Logical: Exists;
    ///
    #[parol_runtime::function_name::named]
    fn logical_4(&mut self, _exists: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let exists = pop_item!(self, exists, Exists, context);
        let logical_4_built = LogicalExists {
            exists: Box::new(exists),
        };
        let logical_4_built = Logical::Exists(logical_4_built);
        // Calling user action here
        self.user_grammar.logical(&logical_4_built)?;
        self.push(ASTType::Logical(logical_4_built), context);
        Ok(())
    }

    /// Semantic action for production 334:
    ///
    /// Logical: Tack;
    ///
    #[parol_runtime::function_name::named]
    fn logical_5(&mut self, _tack: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let tack = pop_item!(self, tack, Tack, context);
        let logical_5_built = LogicalTack {
            tack: Box::new(tack),
        };
        let logical_5_built = Logical::Tack(logical_5_built);
        // Calling user action here
        self.user_grammar.logical(&logical_5_built)?;
        self.push(ASTType::Logical(logical_5_built), context);
        Ok(())
    }

    /// Semantic action for production 335:
    ///
    /// Equal: <Math>'eq' EqualOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn equal(&mut self, eq: &ParseTreeType<'t>, _equal_opt: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let eq = eq.token()?.clone();
        let equal_opt = pop_item!(self, equal_opt, EqualOpt, context);
        let equal_built = Equal { eq, equal_opt };
        // Calling user action here
        self.user_grammar.equal(&equal_built)?;
        self.push(ASTType::Equal(equal_built), context);
        Ok(())
    }

    /// Semantic action for production 336:
    ///
    /// EqualOpt /* `Option<T>::Some` */: DotToken Not;
    ///
    #[parol_runtime::function_name::named]
    fn equal_opt_0(
        &mut self,
        _dot_token: &ParseTreeType<'t>,
        _not: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let not = pop_item!(self, not, Not, context);
        let dot_token = pop_item!(self, dot_token, DotToken, context);
        let equal_opt_0_built = EqualOpt {
            dot_token: Box::new(dot_token),
            not: Box::new(not),
        };
        self.push(
            ASTType::EqualOpt(Some(Box::new(equal_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 337:
    ///
    /// EqualOpt /* `Option<T>::None` */: ;
    ///
    #[parol_runtime::function_name::named]
    fn equal_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::EqualOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 338:
    ///
    /// Identical: <Math>'ident' IdenticalOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn identical(
        &mut self,
        ident: &ParseTreeType<'t>,
        _identical_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ident = ident.token()?.clone();
        let identical_opt = pop_item!(self, identical_opt, IdenticalOpt, context);
        let identical_built = Identical {
            ident,
            identical_opt,
        };
        // Calling user action here
        self.user_grammar.identical(&identical_built)?;
        self.push(ASTType::Identical(identical_built), context);
        Ok(())
    }

    /// Semantic action for production 339:
    ///
    /// IdenticalOpt /* `Option<T>::Some` */: DotToken Not;
    ///
    #[parol_runtime::function_name::named]
    fn identical_opt_0(
        &mut self,
        _dot_token: &ParseTreeType<'t>,
        _not: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let not = pop_item!(self, not, Not, context);
        let dot_token = pop_item!(self, dot_token, DotToken, context);
        let identical_opt_0_built = IdenticalOpt {
            dot_token: Box::new(dot_token),
            not: Box::new(not),
        };
        self.push(
            ASTType::IdenticalOpt(Some(Box::new(identical_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 340:
    ///
    /// IdenticalOpt /* `Option<T>::None` */: ;
    ///
    #[parol_runtime::function_name::named]
    fn identical_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::IdenticalOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 341:
    ///
    /// Approx: <Math>'approx' ApproxOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn approx(
        &mut self,
        approx: &ParseTreeType<'t>,
        _approx_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let approx = approx.token()?.clone();
        let approx_opt = pop_item!(self, approx_opt, ApproxOpt, context);
        let approx_built = Approx { approx, approx_opt };
        // Calling user action here
        self.user_grammar.approx(&approx_built)?;
        self.push(ASTType::Approx(approx_built), context);
        Ok(())
    }

    /// Semantic action for production 342:
    ///
    /// ApproxOpt /* `Option<T>::Some` */: DotToken Not;
    ///
    #[parol_runtime::function_name::named]
    fn approx_opt_0(
        &mut self,
        _dot_token: &ParseTreeType<'t>,
        _not: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let not = pop_item!(self, not, Not, context);
        let dot_token = pop_item!(self, dot_token, DotToken, context);
        let approx_opt_0_built = ApproxOpt {
            dot_token: Box::new(dot_token),
            not: Box::new(not),
        };
        self.push(
            ASTType::ApproxOpt(Some(Box::new(approx_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 343:
    ///
    /// ApproxOpt /* `Option<T>::None` */: ;
    ///
    #[parol_runtime::function_name::named]
    fn approx_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ApproxOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 344:
    ///
    /// Prop: <Math>'prop';
    ///
    #[parol_runtime::function_name::named]
    fn prop(&mut self, prop: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let prop = prop.token()?.clone();
        let prop_built = Prop { prop };
        // Calling user action here
        self.user_grammar.prop(&prop_built)?;
        self.push(ASTType::Prop(prop_built), context);
        Ok(())
    }

    /// Semantic action for production 345:
    ///
    /// Less: <Math>'le' LessOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn less(&mut self, le: &ParseTreeType<'t>, _less_opt: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let le = le.token()?.clone();
        let less_opt = pop_item!(self, less_opt, LessOpt, context);
        let less_built = Less { le, less_opt };
        // Calling user action here
        self.user_grammar.less(&less_built)?;
        self.push(ASTType::Less(less_built), context);
        Ok(())
    }

    /// Semantic action for production 346:
    ///
    /// LessOpt /* `Option<T>::Some` */: DotToken Equal;
    ///
    #[parol_runtime::function_name::named]
    fn less_opt_0(
        &mut self,
        _dot_token: &ParseTreeType<'t>,
        _equal: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let equal = pop_item!(self, equal, Equal, context);
        let dot_token = pop_item!(self, dot_token, DotToken, context);
        let less_opt_0_built = LessOpt {
            dot_token: Box::new(dot_token),
            equal: Box::new(equal),
        };
        self.push(ASTType::LessOpt(Some(Box::new(less_opt_0_built))), context);
        Ok(())
    }

    /// Semantic action for production 347:
    ///
    /// LessOpt /* `Option<T>::None` */: ;
    ///
    #[parol_runtime::function_name::named]
    fn less_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::LessOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 348:
    ///
    /// Greater: <Math>'ge' GreaterOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn greater(&mut self, ge: &ParseTreeType<'t>, _greater_opt: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ge = ge.token()?.clone();
        let greater_opt = pop_item!(self, greater_opt, GreaterOpt, context);
        let greater_built = Greater { ge, greater_opt };
        // Calling user action here
        self.user_grammar.greater(&greater_built)?;
        self.push(ASTType::Greater(greater_built), context);
        Ok(())
    }

    /// Semantic action for production 349:
    ///
    /// GreaterOpt /* `Option<T>::Some` */: DotToken Equal;
    ///
    #[parol_runtime::function_name::named]
    fn greater_opt_0(
        &mut self,
        _dot_token: &ParseTreeType<'t>,
        _equal: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let equal = pop_item!(self, equal, Equal, context);
        let dot_token = pop_item!(self, dot_token, DotToken, context);
        let greater_opt_0_built = GreaterOpt {
            dot_token: Box::new(dot_token),
            equal: Box::new(equal),
        };
        self.push(
            ASTType::GreaterOpt(Some(Box::new(greater_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 350:
    ///
    /// GreaterOpt /* `Option<T>::None` */: ;
    ///
    #[parol_runtime::function_name::named]
    fn greater_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::GreaterOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 351:
    ///
    /// In: <Math>'in' InOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn r#in(&mut self, kw_in: &ParseTreeType<'t>, _in_opt: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let kw_in = kw_in.token()?.clone();
        let in_opt = pop_item!(self, in_opt, InOpt, context);
        let r#in_built = In { kw_in, in_opt };
        // Calling user action here
        self.user_grammar.r#in(&r#in_built)?;
        self.push(ASTType::In(r#in_built), context);
        Ok(())
    }

    /// Semantic action for production 352:
    ///
    /// InOpt /* `Option<T>::Some` */: DotToken Not;
    ///
    #[parol_runtime::function_name::named]
    fn in_opt_0(&mut self, _dot_token: &ParseTreeType<'t>, _not: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let not = pop_item!(self, not, Not, context);
        let dot_token = pop_item!(self, dot_token, DotToken, context);
        let in_opt_0_built = InOpt {
            dot_token: Box::new(dot_token),
            not: Box::new(not),
        };
        self.push(ASTType::InOpt(Some(Box::new(in_opt_0_built))), context);
        Ok(())
    }

    /// Semantic action for production 353:
    ///
    /// InOpt /* `Option<T>::None` */: ;
    ///
    #[parol_runtime::function_name::named]
    fn in_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::InOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 354:
    ///
    /// Subset: <Math>'subset' SubsetOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn subset(
        &mut self,
        subset: &ParseTreeType<'t>,
        _subset_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let subset = subset.token()?.clone();
        let subset_opt = pop_item!(self, subset_opt, SubsetOpt, context);
        let subset_built = Subset { subset, subset_opt };
        // Calling user action here
        self.user_grammar.subset(&subset_built)?;
        self.push(ASTType::Subset(subset_built), context);
        Ok(())
    }

    /// Semantic action for production 355:
    ///
    /// SubsetOpt /* `Option<T>::Some` */: DotToken SubsetOptGroup;
    ///
    #[parol_runtime::function_name::named]
    fn subset_opt_0(
        &mut self,
        _dot_token: &ParseTreeType<'t>,
        _subset_opt_group: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let subset_opt_group = pop_item!(self, subset_opt_group, SubsetOptGroup, context);
        let dot_token = pop_item!(self, dot_token, DotToken, context);
        let subset_opt_0_built = SubsetOpt {
            dot_token: Box::new(dot_token),
            subset_opt_group: Box::new(subset_opt_group),
        };
        self.push(
            ASTType::SubsetOpt(Some(Box::new(subset_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 356:
    ///
    /// SubsetOptGroup: Not;
    ///
    #[parol_runtime::function_name::named]
    fn subset_opt_group_0(&mut self, _not: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let not = pop_item!(self, not, Not, context);
        let subset_opt_group_0_built = SubsetOptGroupNot { not: Box::new(not) };
        let subset_opt_group_0_built = SubsetOptGroup::Not(subset_opt_group_0_built);
        self.push(ASTType::SubsetOptGroup(subset_opt_group_0_built), context);
        Ok(())
    }

    /// Semantic action for production 357:
    ///
    /// SubsetOptGroup: Equal;
    ///
    #[parol_runtime::function_name::named]
    fn subset_opt_group_1(&mut self, _equal: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let equal = pop_item!(self, equal, Equal, context);
        let subset_opt_group_1_built = SubsetOptGroupEqual {
            equal: Box::new(equal),
        };
        let subset_opt_group_1_built = SubsetOptGroup::Equal(subset_opt_group_1_built);
        self.push(ASTType::SubsetOptGroup(subset_opt_group_1_built), context);
        Ok(())
    }

    /// Semantic action for production 358:
    ///
    /// SubsetOpt /* `Option<T>::None` */: ;
    ///
    #[parol_runtime::function_name::named]
    fn subset_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::SubsetOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 359:
    ///
    /// Supset: <Math>'supset' SupsetOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn supset(
        &mut self,
        supset: &ParseTreeType<'t>,
        _supset_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let supset = supset.token()?.clone();
        let supset_opt = pop_item!(self, supset_opt, SupsetOpt, context);
        let supset_built = Supset { supset, supset_opt };
        // Calling user action here
        self.user_grammar.supset(&supset_built)?;
        self.push(ASTType::Supset(supset_built), context);
        Ok(())
    }

    /// Semantic action for production 360:
    ///
    /// SupsetOpt /* `Option<T>::Some` */: DotToken SupsetOptGroup;
    ///
    #[parol_runtime::function_name::named]
    fn supset_opt_0(
        &mut self,
        _dot_token: &ParseTreeType<'t>,
        _supset_opt_group: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let supset_opt_group = pop_item!(self, supset_opt_group, SupsetOptGroup, context);
        let dot_token = pop_item!(self, dot_token, DotToken, context);
        let supset_opt_0_built = SupsetOpt {
            dot_token: Box::new(dot_token),
            supset_opt_group: Box::new(supset_opt_group),
        };
        self.push(
            ASTType::SupsetOpt(Some(Box::new(supset_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 361:
    ///
    /// SupsetOptGroup: Not;
    ///
    #[parol_runtime::function_name::named]
    fn supset_opt_group_0(&mut self, _not: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let not = pop_item!(self, not, Not, context);
        let supset_opt_group_0_built = SupsetOptGroupNot { not: Box::new(not) };
        let supset_opt_group_0_built = SupsetOptGroup::Not(supset_opt_group_0_built);
        self.push(ASTType::SupsetOptGroup(supset_opt_group_0_built), context);
        Ok(())
    }

    /// Semantic action for production 362:
    ///
    /// SupsetOptGroup: Equal;
    ///
    #[parol_runtime::function_name::named]
    fn supset_opt_group_1(&mut self, _equal: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let equal = pop_item!(self, equal, Equal, context);
        let supset_opt_group_1_built = SupsetOptGroupEqual {
            equal: Box::new(equal),
        };
        let supset_opt_group_1_built = SupsetOptGroup::Equal(supset_opt_group_1_built);
        self.push(ASTType::SupsetOptGroup(supset_opt_group_1_built), context);
        Ok(())
    }

    /// Semantic action for production 363:
    ///
    /// SupsetOpt /* `Option<T>::None` */: ;
    ///
    #[parol_runtime::function_name::named]
    fn supset_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::SupsetOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 364:
    ///
    /// Relation: Equal;
    ///
    #[parol_runtime::function_name::named]
    fn relation_1(&mut self, _equal: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let equal = pop_item!(self, equal, Equal, context);
        let relation_1_built = RelationEqual {
            equal: Box::new(equal),
        };
        let relation_1_built = Relation::Equal(relation_1_built);
        // Calling user action here
        self.user_grammar.relation(&relation_1_built)?;
        self.push(ASTType::Relation(relation_1_built), context);
        Ok(())
    }

    /// Semantic action for production 365:
    ///
    /// Relation: Identical;
    ///
    #[parol_runtime::function_name::named]
    fn relation_2(&mut self, _identical: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let identical = pop_item!(self, identical, Identical, context);
        let relation_2_built = RelationIdentical {
            identical: Box::new(identical),
        };
        let relation_2_built = Relation::Identical(relation_2_built);
        // Calling user action here
        self.user_grammar.relation(&relation_2_built)?;
        self.push(ASTType::Relation(relation_2_built), context);
        Ok(())
    }

    /// Semantic action for production 366:
    ///
    /// Relation: Approx;
    ///
    #[parol_runtime::function_name::named]
    fn relation_3(&mut self, _approx: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let approx = pop_item!(self, approx, Approx, context);
        let relation_3_built = RelationApprox {
            approx: Box::new(approx),
        };
        let relation_3_built = Relation::Approx(relation_3_built);
        // Calling user action here
        self.user_grammar.relation(&relation_3_built)?;
        self.push(ASTType::Relation(relation_3_built), context);
        Ok(())
    }

    /// Semantic action for production 367:
    ///
    /// Relation: Prop;
    ///
    #[parol_runtime::function_name::named]
    fn relation_4(&mut self, _prop: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let prop = pop_item!(self, prop, Prop, context);
        let relation_4_built = RelationProp {
            prop: Box::new(prop),
        };
        let relation_4_built = Relation::Prop(relation_4_built);
        // Calling user action here
        self.user_grammar.relation(&relation_4_built)?;
        self.push(ASTType::Relation(relation_4_built), context);
        Ok(())
    }

    /// Semantic action for production 368:
    ///
    /// Relation: Less;
    ///
    #[parol_runtime::function_name::named]
    fn relation_5(&mut self, _less: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let less = pop_item!(self, less, Less, context);
        let relation_5_built = RelationLess {
            less: Box::new(less),
        };
        let relation_5_built = Relation::Less(relation_5_built);
        // Calling user action here
        self.user_grammar.relation(&relation_5_built)?;
        self.push(ASTType::Relation(relation_5_built), context);
        Ok(())
    }

    /// Semantic action for production 369:
    ///
    /// Relation: Greater;
    ///
    #[parol_runtime::function_name::named]
    fn relation_6(&mut self, _greater: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let greater = pop_item!(self, greater, Greater, context);
        let relation_6_built = RelationGreater {
            greater: Box::new(greater),
        };
        let relation_6_built = Relation::Greater(relation_6_built);
        // Calling user action here
        self.user_grammar.relation(&relation_6_built)?;
        self.push(ASTType::Relation(relation_6_built), context);
        Ok(())
    }

    /// Semantic action for production 370:
    ///
    /// Relation: In;
    ///
    #[parol_runtime::function_name::named]
    fn relation_7(&mut self, _in: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#in = pop_item!(self, r#in, In, context);
        let relation_7_built = RelationIn {
            r#in: Box::new(r#in),
        };
        let relation_7_built = Relation::In(relation_7_built);
        // Calling user action here
        self.user_grammar.relation(&relation_7_built)?;
        self.push(ASTType::Relation(relation_7_built), context);
        Ok(())
    }

    /// Semantic action for production 371:
    ///
    /// Relation: Subset;
    ///
    #[parol_runtime::function_name::named]
    fn relation_8(&mut self, _subset: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let subset = pop_item!(self, subset, Subset, context);
        let relation_8_built = RelationSubset {
            subset: Box::new(subset),
        };
        let relation_8_built = Relation::Subset(relation_8_built);
        // Calling user action here
        self.user_grammar.relation(&relation_8_built)?;
        self.push(ASTType::Relation(relation_8_built), context);
        Ok(())
    }

    /// Semantic action for production 372:
    ///
    /// Relation: Supset;
    ///
    #[parol_runtime::function_name::named]
    fn relation_9(&mut self, _supset: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let supset = pop_item!(self, supset, Supset, context);
        let relation_9_built = RelationSupset {
            supset: Box::new(supset),
        };
        let relation_9_built = Relation::Supset(relation_9_built);
        // Calling user action here
        self.user_grammar.relation(&relation_9_built)?;
        self.push(ASTType::Relation(relation_9_built), context);
        Ok(())
    }

    /// Semantic action for production 373:
    ///
    /// Variable: <Math>/[a-zA-Z]/;
    ///
    #[parol_runtime::function_name::named]
    fn variable(&mut self, variable: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let variable = variable.token()?.clone();
        let variable_built = Variable { variable };
        // Calling user action here
        self.user_grammar.variable(&variable_built)?;
        self.push(ASTType::Variable(variable_built), context);
        Ok(())
    }

    /// Semantic action for production 374:
    ///
    /// Attach: UnderscoreToken;
    ///
    #[parol_runtime::function_name::named]
    fn attach_0(&mut self, _underscore_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let underscore_token = pop_item!(self, underscore_token, UnderscoreToken, context);
        let attach_0_built = AttachUnderscoreToken {
            underscore_token: Box::new(underscore_token),
        };
        let attach_0_built = Attach::UnderscoreToken(attach_0_built);
        // Calling user action here
        self.user_grammar.attach(&attach_0_built)?;
        self.push(ASTType::Attach(attach_0_built), context);
        Ok(())
    }

    /// Semantic action for production 375:
    ///
    /// Attach: CaretToken;
    ///
    #[parol_runtime::function_name::named]
    fn attach_1(&mut self, _caret_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let caret_token = pop_item!(self, caret_token, CaretToken, context);
        let attach_1_built = AttachCaretToken {
            caret_token: Box::new(caret_token),
        };
        let attach_1_built = Attach::CaretToken(attach_1_built);
        // Calling user action here
        self.user_grammar.attach(&attach_1_built)?;
        self.push(ASTType::Attach(attach_1_built), context);
        Ok(())
    }

    /// Semantic action for production 376:
    ///
    /// Plus: <Math>'plus';
    ///
    #[parol_runtime::function_name::named]
    fn plus_0(&mut self, plus: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let plus = plus.token()?.clone();
        let plus_0_built = PlusPlus { plus };
        let plus_0_built = Plus::Plus(plus_0_built);
        // Calling user action here
        self.user_grammar.plus(&plus_0_built)?;
        self.push(ASTType::Plus(plus_0_built), context);
        Ok(())
    }

    /// Semantic action for production 377:
    ///
    /// Plus: PlusToken;
    ///
    #[parol_runtime::function_name::named]
    fn plus_1(&mut self, _plus_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let plus_token = pop_item!(self, plus_token, PlusToken, context);
        let plus_1_built = PlusPlusToken {
            plus_token: Box::new(plus_token),
        };
        let plus_1_built = Plus::PlusToken(plus_1_built);
        // Calling user action here
        self.user_grammar.plus(&plus_1_built)?;
        self.push(ASTType::Plus(plus_1_built), context);
        Ok(())
    }

    /// Semantic action for production 378:
    ///
    /// Minus: <Math>'minus';
    ///
    #[parol_runtime::function_name::named]
    fn minus_0(&mut self, minus: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let minus = minus.token()?.clone();
        let minus_0_built = MinusMinus { minus };
        let minus_0_built = Minus::Minus(minus_0_built);
        // Calling user action here
        self.user_grammar.minus(&minus_0_built)?;
        self.push(ASTType::Minus(minus_0_built), context);
        Ok(())
    }

    /// Semantic action for production 379:
    ///
    /// Minus: MinusToken;
    ///
    #[parol_runtime::function_name::named]
    fn minus_1(&mut self, _minus_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let minus_token = pop_item!(self, minus_token, MinusToken, context);
        let minus_1_built = MinusMinusToken {
            minus_token: Box::new(minus_token),
        };
        let minus_1_built = Minus::MinusToken(minus_1_built);
        // Calling user action here
        self.user_grammar.minus(&minus_1_built)?;
        self.push(ASTType::Minus(minus_1_built), context);
        Ok(())
    }

    /// Semantic action for production 380:
    ///
    /// Frac: <Math>'frac';
    ///
    #[parol_runtime::function_name::named]
    fn frac_0(&mut self, frac: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let frac = frac.token()?.clone();
        let frac_0_built = FracFrac { frac };
        let frac_0_built = Frac::Frac(frac_0_built);
        // Calling user action here
        self.user_grammar.frac(&frac_0_built)?;
        self.push(ASTType::Frac(frac_0_built), context);
        Ok(())
    }

    /// Semantic action for production 381:
    ///
    /// Frac: SlashToken;
    ///
    #[parol_runtime::function_name::named]
    fn frac_1(&mut self, _slash_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let slash_token = pop_item!(self, slash_token, SlashToken, context);
        let frac_1_built = FracSlashToken {
            slash_token: Box::new(slash_token),
        };
        let frac_1_built = Frac::SlashToken(frac_1_built);
        // Calling user action here
        self.user_grammar.frac(&frac_1_built)?;
        self.push(ASTType::Frac(frac_1_built), context);
        Ok(())
    }

    /// Semantic action for production 382:
    ///
    /// Times: <Math>'times';
    ///
    #[parol_runtime::function_name::named]
    fn times_0(&mut self, times: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let times = times.token()?.clone();
        let times_0_built = TimesTimes { times };
        let times_0_built = Times::Times(times_0_built);
        // Calling user action here
        self.user_grammar.times(&times_0_built)?;
        self.push(ASTType::Times(times_0_built), context);
        Ok(())
    }

    /// Semantic action for production 383:
    ///
    /// Times: AsteriskToken;
    ///
    #[parol_runtime::function_name::named]
    fn times_1(&mut self, _asterisk_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let asterisk_token = pop_item!(self, asterisk_token, AsteriskToken, context);
        let times_1_built = TimesAsteriskToken {
            asterisk_token: Box::new(asterisk_token),
        };
        let times_1_built = Times::AsteriskToken(times_1_built);
        // Calling user action here
        self.user_grammar.times(&times_1_built)?;
        self.push(ASTType::Times(times_1_built), context);
        Ok(())
    }

    /// Semantic action for production 384:
    ///
    /// Operation: Logical;
    ///
    #[parol_runtime::function_name::named]
    fn operation_0(&mut self, _logical: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let logical = pop_item!(self, logical, Logical, context);
        let operation_0_built = OperationLogical {
            logical: Box::new(logical),
        };
        let operation_0_built = Operation::Logical(operation_0_built);
        // Calling user action here
        self.user_grammar.operation(&operation_0_built)?;
        self.push(ASTType::Operation(operation_0_built), context);
        Ok(())
    }

    /// Semantic action for production 385:
    ///
    /// Operation: Relation;
    ///
    #[parol_runtime::function_name::named]
    fn operation_1(&mut self, _relation: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let relation = pop_item!(self, relation, Relation, context);
        let operation_1_built = OperationRelation {
            relation: Box::new(relation),
        };
        let operation_1_built = Operation::Relation(operation_1_built);
        // Calling user action here
        self.user_grammar.operation(&operation_1_built)?;
        self.push(ASTType::Operation(operation_1_built), context);
        Ok(())
    }

    /// Semantic action for production 386:
    ///
    /// Operation: Attach;
    ///
    #[parol_runtime::function_name::named]
    fn operation_2(&mut self, _attach: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let attach = pop_item!(self, attach, Attach, context);
        let operation_2_built = OperationAttach {
            attach: Box::new(attach),
        };
        let operation_2_built = Operation::Attach(operation_2_built);
        // Calling user action here
        self.user_grammar.operation(&operation_2_built)?;
        self.push(ASTType::Operation(operation_2_built), context);
        Ok(())
    }

    /// Semantic action for production 387:
    ///
    /// Operation: Plus;
    ///
    #[parol_runtime::function_name::named]
    fn operation_3(&mut self, _plus: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let plus = pop_item!(self, plus, Plus, context);
        let operation_3_built = OperationPlus {
            plus: Box::new(plus),
        };
        let operation_3_built = Operation::Plus(operation_3_built);
        // Calling user action here
        self.user_grammar.operation(&operation_3_built)?;
        self.push(ASTType::Operation(operation_3_built), context);
        Ok(())
    }

    /// Semantic action for production 388:
    ///
    /// Operation: Minus;
    ///
    #[parol_runtime::function_name::named]
    fn operation_4(&mut self, _minus: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let minus = pop_item!(self, minus, Minus, context);
        let operation_4_built = OperationMinus {
            minus: Box::new(minus),
        };
        let operation_4_built = Operation::Minus(operation_4_built);
        // Calling user action here
        self.user_grammar.operation(&operation_4_built)?;
        self.push(ASTType::Operation(operation_4_built), context);
        Ok(())
    }

    /// Semantic action for production 389:
    ///
    /// Operation: Frac;
    ///
    #[parol_runtime::function_name::named]
    fn operation_5(&mut self, _frac: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let frac = pop_item!(self, frac, Frac, context);
        let operation_5_built = OperationFrac {
            frac: Box::new(frac),
        };
        let operation_5_built = Operation::Frac(operation_5_built);
        // Calling user action here
        self.user_grammar.operation(&operation_5_built)?;
        self.push(ASTType::Operation(operation_5_built), context);
        Ok(())
    }

    /// Semantic action for production 390:
    ///
    /// Operation: Times;
    ///
    #[parol_runtime::function_name::named]
    fn operation_6(&mut self, _times: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let times = pop_item!(self, times, Times, context);
        let operation_6_built = OperationTimes {
            times: Box::new(times),
        };
        let operation_6_built = Operation::Times(operation_6_built);
        // Calling user action here
        self.user_grammar.operation(&operation_6_built)?;
        self.push(ASTType::Operation(operation_6_built), context);
        Ok(())
    }

    /// Semantic action for production 391:
    ///
    /// EquDoubleToken: <Code>'==';
    ///
    #[parol_runtime::function_name::named]
    fn equ_double_token(&mut self, equ_double_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let equ_double_token = equ_double_token.token()?.clone();
        let equ_double_token_built = EquDoubleToken { equ_double_token };
        // Calling user action here
        self.user_grammar
            .equ_double_token(&equ_double_token_built)?;
        self.push(ASTType::EquDoubleToken(equ_double_token_built), context);
        Ok(())
    }

    /// Semantic action for production 392:
    ///
    /// EquToken: <INITIAL, Code>'=';
    ///
    #[parol_runtime::function_name::named]
    fn equ_token(&mut self, equ_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let equ_token = equ_token.token()?.clone();
        let equ_token_built = EquToken { equ_token };
        // Calling user action here
        self.user_grammar.equ_token(&equ_token_built)?;
        self.push(ASTType::EquToken(equ_token_built), context);
        Ok(())
    }

    /// Semantic action for production 393:
    ///
    /// PlusToken: <INITIAL, Code, Math>'+';
    ///
    #[parol_runtime::function_name::named]
    fn plus_token(&mut self, plus_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let plus_token = plus_token.token()?.clone();
        let plus_token_built = PlusToken { plus_token };
        // Calling user action here
        self.user_grammar.plus_token(&plus_token_built)?;
        self.push(ASTType::PlusToken(plus_token_built), context);
        Ok(())
    }

    /// Semantic action for production 394:
    ///
    /// MinusToken: <INITIAL, Code, Math>'-';
    ///
    #[parol_runtime::function_name::named]
    fn minus_token(&mut self, minus_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let minus_token = minus_token.token()?.clone();
        let minus_token_built = MinusToken { minus_token };
        // Calling user action here
        self.user_grammar.minus_token(&minus_token_built)?;
        self.push(ASTType::MinusToken(minus_token_built), context);
        Ok(())
    }

    /// Semantic action for production 395:
    ///
    /// SlashToken: <INITIAL, Code, Math>'/';
    ///
    #[parol_runtime::function_name::named]
    fn slash_token(&mut self, slash_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let slash_token = slash_token.token()?.clone();
        let slash_token_built = SlashToken { slash_token };
        // Calling user action here
        self.user_grammar.slash_token(&slash_token_built)?;
        self.push(ASTType::SlashToken(slash_token_built), context);
        Ok(())
    }

    /// Semantic action for production 396:
    ///
    /// BackslashToken: <INITIAL, Code, Math>/\\/;
    ///
    #[parol_runtime::function_name::named]
    fn backslash_token(&mut self, backslash_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let backslash_token = backslash_token.token()?.clone();
        let backslash_token_built = BackslashToken { backslash_token };
        // Calling user action here
        self.user_grammar.backslash_token(&backslash_token_built)?;
        self.push(ASTType::BackslashToken(backslash_token_built), context);
        Ok(())
    }

    /// Semantic action for production 397:
    ///
    /// AsteriskToken: <INITIAL, Code, Math>'*';
    ///
    #[parol_runtime::function_name::named]
    fn asterisk_token(&mut self, asterisk_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let asterisk_token = asterisk_token.token()?.clone();
        let asterisk_token_built = AsteriskToken { asterisk_token };
        // Calling user action here
        self.user_grammar.asterisk_token(&asterisk_token_built)?;
        self.push(ASTType::AsteriskToken(asterisk_token_built), context);
        Ok(())
    }

    /// Semantic action for production 398:
    ///
    /// PercentToken: <Code>'%';
    ///
    #[parol_runtime::function_name::named]
    fn percent_token(&mut self, percent_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let percent_token = percent_token.token()?.clone();
        let percent_token_built = PercentToken { percent_token };
        // Calling user action here
        self.user_grammar.percent_token(&percent_token_built)?;
        self.push(ASTType::PercentToken(percent_token_built), context);
        Ok(())
    }

    /// Semantic action for production 399:
    ///
    /// PipeDoubleToken: <Code>'||';
    ///
    #[parol_runtime::function_name::named]
    fn pipe_double_token(&mut self, pipe_double_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let pipe_double_token = pipe_double_token.token()?.clone();
        let pipe_double_token_built = PipeDoubleToken { pipe_double_token };
        // Calling user action here
        self.user_grammar
            .pipe_double_token(&pipe_double_token_built)?;
        self.push(ASTType::PipeDoubleToken(pipe_double_token_built), context);
        Ok(())
    }

    /// Semantic action for production 400:
    ///
    /// PipeToken: '|';
    ///
    #[parol_runtime::function_name::named]
    fn pipe_token(&mut self, pipe_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let pipe_token = pipe_token.token()?.clone();
        let pipe_token_built = PipeToken { pipe_token };
        // Calling user action here
        self.user_grammar.pipe_token(&pipe_token_built)?;
        self.push(ASTType::PipeToken(pipe_token_built), context);
        Ok(())
    }

    /// Semantic action for production 401:
    ///
    /// UnderscoreDoubleToken: '__';
    ///
    #[parol_runtime::function_name::named]
    fn underscore_double_token(
        &mut self,
        underscore_double_token: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let underscore_double_token = underscore_double_token.token()?.clone();
        let underscore_double_token_built = UnderscoreDoubleToken {
            underscore_double_token,
        };
        // Calling user action here
        self.user_grammar
            .underscore_double_token(&underscore_double_token_built)?;
        self.push(
            ASTType::UnderscoreDoubleToken(underscore_double_token_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 402:
    ///
    /// UnderscoreToken: <INITIAL, Math>'_';
    ///
    #[parol_runtime::function_name::named]
    fn underscore_token(&mut self, underscore_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let underscore_token = underscore_token.token()?.clone();
        let underscore_token_built = UnderscoreToken { underscore_token };
        // Calling user action here
        self.user_grammar
            .underscore_token(&underscore_token_built)?;
        self.push(ASTType::UnderscoreToken(underscore_token_built), context);
        Ok(())
    }

    /// Semantic action for production 403:
    ///
    /// CaretToken: <INITIAL, Math>'^';
    ///
    #[parol_runtime::function_name::named]
    fn caret_token(&mut self, caret_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let caret_token = caret_token.token()?.clone();
        let caret_token_built = CaretToken { caret_token };
        // Calling user action here
        self.user_grammar.caret_token(&caret_token_built)?;
        self.push(ASTType::CaretToken(caret_token_built), context);
        Ok(())
    }

    /// Semantic action for production 404:
    ///
    /// BacktickTripleToken: <INITIAL, Raw>'```';
    ///
    #[parol_runtime::function_name::named]
    fn backtick_triple_token(&mut self, backtick_triple_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let backtick_triple_token = backtick_triple_token.token()?.clone();
        let backtick_triple_token_built = BacktickTripleToken {
            backtick_triple_token,
        };
        // Calling user action here
        self.user_grammar
            .backtick_triple_token(&backtick_triple_token_built)?;
        self.push(
            ASTType::BacktickTripleToken(backtick_triple_token_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 405:
    ///
    /// BacktickToken: <INITIAL, Monospace>'`';
    ///
    #[parol_runtime::function_name::named]
    fn backtick_token(&mut self, backtick_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let backtick_token = backtick_token.token()?.clone();
        let backtick_token_built = BacktickToken { backtick_token };
        // Calling user action here
        self.user_grammar.backtick_token(&backtick_token_built)?;
        self.push(ASTType::BacktickToken(backtick_token_built), context);
        Ok(())
    }

    /// Semantic action for production 406:
    ///
    /// TildeToken: '~';
    ///
    #[parol_runtime::function_name::named]
    fn tilde_token(&mut self, tilde_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let tilde_token = tilde_token.token()?.clone();
        let tilde_token_built = TildeToken { tilde_token };
        // Calling user action here
        self.user_grammar.tilde_token(&tilde_token_built)?;
        self.push(ASTType::TildeToken(tilde_token_built), context);
        Ok(())
    }

    /// Semantic action for production 407:
    ///
    /// HashToken: '#';
    ///
    #[parol_runtime::function_name::named]
    fn hash_token(&mut self, hash_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let hash_token = hash_token.token()?.clone();
        let hash_token_built = HashToken { hash_token };
        // Calling user action here
        self.user_grammar.hash_token(&hash_token_built)?;
        self.push(ASTType::HashToken(hash_token_built), context);
        Ok(())
    }

    /// Semantic action for production 408:
    ///
    /// SigilToken: '$';
    ///
    #[parol_runtime::function_name::named]
    fn sigil_token(&mut self, sigil_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let sigil_token = sigil_token.token()?.clone();
        let sigil_token_built = SigilToken { sigil_token };
        // Calling user action here
        self.user_grammar.sigil_token(&sigil_token_built)?;
        self.push(ASTType::SigilToken(sigil_token_built), context);
        Ok(())
    }

    /// Semantic action for production 409:
    ///
    /// AtToken: '@';
    ///
    #[parol_runtime::function_name::named]
    fn at_token(&mut self, at_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let at_token = at_token.token()?.clone();
        let at_token_built = AtToken { at_token };
        // Calling user action here
        self.user_grammar.at_token(&at_token_built)?;
        self.push(ASTType::AtToken(at_token_built), context);
        Ok(())
    }

    /// Semantic action for production 410:
    ///
    /// CommaToken: <Code>',';
    ///
    #[parol_runtime::function_name::named]
    fn comma_token(&mut self, comma_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma_token = comma_token.token()?.clone();
        let comma_token_built = CommaToken { comma_token };
        // Calling user action here
        self.user_grammar.comma_token(&comma_token_built)?;
        self.push(ASTType::CommaToken(comma_token_built), context);
        Ok(())
    }

    /// Semantic action for production 411:
    ///
    /// DotToken: <Code, Math>'.';
    ///
    #[parol_runtime::function_name::named]
    fn dot_token(&mut self, dot_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let dot_token = dot_token.token()?.clone();
        let dot_token_built = DotToken { dot_token };
        // Calling user action here
        self.user_grammar.dot_token(&dot_token_built)?;
        self.push(ASTType::DotToken(dot_token_built), context);
        Ok(())
    }

    /// Semantic action for production 412:
    ///
    /// ColonToken: <Code>':';
    ///
    #[parol_runtime::function_name::named]
    fn colon_token(&mut self, colon_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let colon_token = colon_token.token()?.clone();
        let colon_token_built = ColonToken { colon_token };
        // Calling user action here
        self.user_grammar.colon_token(&colon_token_built)?;
        self.push(ASTType::ColonToken(colon_token_built), context);
        Ok(())
    }

    /// Semantic action for production 413:
    ///
    /// LeftParenToken: <Code, Math>'(';
    ///
    #[parol_runtime::function_name::named]
    fn left_paren_token(&mut self, left_paren_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let left_paren_token = left_paren_token.token()?.clone();
        let left_paren_token_built = LeftParenToken { left_paren_token };
        // Calling user action here
        self.user_grammar
            .left_paren_token(&left_paren_token_built)?;
        self.push(ASTType::LeftParenToken(left_paren_token_built), context);
        Ok(())
    }

    /// Semantic action for production 414:
    ///
    /// RightParenLeftBracketToken: <Code>')[';
    ///
    #[parol_runtime::function_name::named]
    fn right_paren_left_bracket_token(
        &mut self,
        right_paren_left_bracket_token: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let right_paren_left_bracket_token = right_paren_left_bracket_token.token()?.clone();
        let right_paren_left_bracket_token_built = RightParenLeftBracketToken {
            right_paren_left_bracket_token,
        };
        // Calling user action here
        self.user_grammar
            .right_paren_left_bracket_token(&right_paren_left_bracket_token_built)?;
        self.push(
            ASTType::RightParenLeftBracketToken(right_paren_left_bracket_token_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 415:
    ///
    /// RightParenToken: <Code, Math>')';
    ///
    #[parol_runtime::function_name::named]
    fn right_paren_token(&mut self, right_paren_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let right_paren_token = right_paren_token.token()?.clone();
        let right_paren_token_built = RightParenToken { right_paren_token };
        // Calling user action here
        self.user_grammar
            .right_paren_token(&right_paren_token_built)?;
        self.push(ASTType::RightParenToken(right_paren_token_built), context);
        Ok(())
    }

    /// Semantic action for production 416:
    ///
    /// LeftBraceToken: <Code>'{';
    ///
    #[parol_runtime::function_name::named]
    fn left_brace_token(&mut self, left_brace_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let left_brace_token = left_brace_token.token()?.clone();
        let left_brace_token_built = LeftBraceToken { left_brace_token };
        // Calling user action here
        self.user_grammar
            .left_brace_token(&left_brace_token_built)?;
        self.push(ASTType::LeftBraceToken(left_brace_token_built), context);
        Ok(())
    }

    /// Semantic action for production 417:
    ///
    /// RightBraceToken: <Code>'}';
    ///
    #[parol_runtime::function_name::named]
    fn right_brace_token(&mut self, right_brace_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let right_brace_token = right_brace_token.token()?.clone();
        let right_brace_token_built = RightBraceToken { right_brace_token };
        // Calling user action here
        self.user_grammar
            .right_brace_token(&right_brace_token_built)?;
        self.push(ASTType::RightBraceToken(right_brace_token_built), context);
        Ok(())
    }

    /// Semantic action for production 418:
    ///
    /// LeftBracketToken: <INITIAL, Code>'[';
    ///
    #[parol_runtime::function_name::named]
    fn left_bracket_token(&mut self, left_bracket_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let left_bracket_token = left_bracket_token.token()?.clone();
        let left_bracket_token_built = LeftBracketToken { left_bracket_token };
        // Calling user action here
        self.user_grammar
            .left_bracket_token(&left_bracket_token_built)?;
        self.push(ASTType::LeftBracketToken(left_bracket_token_built), context);
        Ok(())
    }

    /// Semantic action for production 419:
    ///
    /// RightBracketToken: <INITIAL, Code>']';
    ///
    #[parol_runtime::function_name::named]
    fn right_bracket_token(&mut self, right_bracket_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let right_bracket_token = right_bracket_token.token()?.clone();
        let right_bracket_token_built = RightBracketToken {
            right_bracket_token,
        };
        // Calling user action here
        self.user_grammar
            .right_bracket_token(&right_bracket_token_built)?;
        self.push(
            ASTType::RightBracketToken(right_bracket_token_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 420:
    ///
    /// LeftAngleEquToken: <Code>'<=';
    ///
    #[parol_runtime::function_name::named]
    fn left_angle_equ_token(&mut self, left_angle_equ_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let left_angle_equ_token = left_angle_equ_token.token()?.clone();
        let left_angle_equ_token_built = LeftAngleEquToken {
            left_angle_equ_token,
        };
        // Calling user action here
        self.user_grammar
            .left_angle_equ_token(&left_angle_equ_token_built)?;
        self.push(
            ASTType::LeftAngleEquToken(left_angle_equ_token_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 421:
    ///
    /// LeftAngleToken: '<';
    ///
    #[parol_runtime::function_name::named]
    fn left_angle_token(&mut self, left_angle_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let left_angle_token = left_angle_token.token()?.clone();
        let left_angle_token_built = LeftAngleToken { left_angle_token };
        // Calling user action here
        self.user_grammar
            .left_angle_token(&left_angle_token_built)?;
        self.push(ASTType::LeftAngleToken(left_angle_token_built), context);
        Ok(())
    }

    /// Semantic action for production 422:
    ///
    /// RightAngleLeftBracketToken: '>[';
    ///
    #[parol_runtime::function_name::named]
    fn right_angle_left_bracket_token(
        &mut self,
        right_angle_left_bracket_token: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let right_angle_left_bracket_token = right_angle_left_bracket_token.token()?.clone();
        let right_angle_left_bracket_token_built = RightAngleLeftBracketToken {
            right_angle_left_bracket_token,
        };
        // Calling user action here
        self.user_grammar
            .right_angle_left_bracket_token(&right_angle_left_bracket_token_built)?;
        self.push(
            ASTType::RightAngleLeftBracketToken(right_angle_left_bracket_token_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 423:
    ///
    /// RightAngleEquToken: <Code>'>=';
    ///
    #[parol_runtime::function_name::named]
    fn right_angle_equ_token(&mut self, right_angle_equ_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let right_angle_equ_token = right_angle_equ_token.token()?.clone();
        let right_angle_equ_token_built = RightAngleEquToken {
            right_angle_equ_token,
        };
        // Calling user action here
        self.user_grammar
            .right_angle_equ_token(&right_angle_equ_token_built)?;
        self.push(
            ASTType::RightAngleEquToken(right_angle_equ_token_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 424:
    ///
    /// RightAngleToken: '>';
    ///
    #[parol_runtime::function_name::named]
    fn right_angle_token(&mut self, right_angle_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let right_angle_token = right_angle_token.token()?.clone();
        let right_angle_token_built = RightAngleToken { right_angle_token };
        // Calling user action here
        self.user_grammar
            .right_angle_token(&right_angle_token_built)?;
        self.push(ASTType::RightAngleToken(right_angle_token_built), context);
        Ok(())
    }

    /// Semantic action for production 425:
    ///
    /// ExclamEquToken: <Code>'!=';
    ///
    #[parol_runtime::function_name::named]
    fn exclam_equ_token(&mut self, exclam_equ_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let exclam_equ_token = exclam_equ_token.token()?.clone();
        let exclam_equ_token_built = ExclamEquToken { exclam_equ_token };
        // Calling user action here
        self.user_grammar
            .exclam_equ_token(&exclam_equ_token_built)?;
        self.push(ASTType::ExclamEquToken(exclam_equ_token_built), context);
        Ok(())
    }

    /// Semantic action for production 426:
    ///
    /// ExclamToken: <Code>'!';
    ///
    #[parol_runtime::function_name::named]
    fn exclam_token(&mut self, exclam_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let exclam_token = exclam_token.token()?.clone();
        let exclam_token_built = ExclamToken { exclam_token };
        // Calling user action here
        self.user_grammar.exclam_token(&exclam_token_built)?;
        self.push(ASTType::ExclamToken(exclam_token_built), context);
        Ok(())
    }

    /// Semantic action for production 427:
    ///
    /// AmperDoubleToken: <Code>'&&';
    ///
    #[parol_runtime::function_name::named]
    fn amper_double_token(&mut self, amper_double_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let amper_double_token = amper_double_token.token()?.clone();
        let amper_double_token_built = AmperDoubleToken { amper_double_token };
        // Calling user action here
        self.user_grammar
            .amper_double_token(&amper_double_token_built)?;
        self.push(ASTType::AmperDoubleToken(amper_double_token_built), context);
        Ok(())
    }

    /// Semantic action for production 428:
    ///
    /// DigitsToken: <Code>/[0-9]+/;
    ///
    #[parol_runtime::function_name::named]
    fn digits_token(&mut self, digits_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let digits_token = digits_token.token()?.clone();
        let digits_token_built = DigitsToken { digits_token };
        // Calling user action here
        self.user_grammar.digits_token(&digits_token_built)?;
        self.push(ASTType::DigitsToken(digits_token_built), context);
        Ok(())
    }

    /// Semantic action for production 429:
    ///
    /// IdentifierToken: <Code>/[a-zA-Z_][0-9a-zA-Z_]*/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn identifier_token(&mut self, identifier_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let identifier_token = identifier_token
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let identifier_token_built = IdentifierToken { identifier_token };
        // Calling user action here
        self.user_grammar
            .identifier_token(&identifier_token_built)?;
        self.push(ASTType::IdentifierToken(identifier_token_built), context);
        Ok(())
    }

    /// Semantic action for production 430:
    ///
    /// NewLine: <INITIAL, Code>/\n/;
    ///
    #[parol_runtime::function_name::named]
    fn new_line(&mut self, new_line: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let new_line = new_line.token()?.clone();
        let new_line_built = NewLine { new_line };
        // Calling user action here
        self.user_grammar.new_line(&new_line_built)?;
        self.push(ASTType::NewLine(new_line_built), context);
        Ok(())
    }

    /// Semantic action for production 431:
    ///
    /// WordToken: /[A-Za-z0-9\.\,\:\;\&\=\+\-\(\)\']+/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn word_token(&mut self, word_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let word_token = word_token
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let word_token_built = WordToken { word_token };
        // Calling user action here
        self.user_grammar.word_token(&word_token_built)?;
        self.push(ASTType::WordToken(word_token_built), context);
        Ok(())
    }

    /// Semantic action for production 432:
    ///
    /// DoubleQuoteToken: <INITIAL, Code>/\"/;
    ///
    #[parol_runtime::function_name::named]
    fn double_quote_token(&mut self, double_quote_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let double_quote_token = double_quote_token.token()?.clone();
        let double_quote_token_built = DoubleQuoteToken { double_quote_token };
        // Calling user action here
        self.user_grammar
            .double_quote_token(&double_quote_token_built)?;
        self.push(ASTType::DoubleQuoteToken(double_quote_token_built), context);
        Ok(())
    }
}

impl<'t> UserActionsTrait<'t> for GrammarAuto<'t, '_> {
    ///
    /// This function is implemented automatically for the user's item Grammar.
    ///
    fn call_semantic_action_for_production_number(
        &mut self,
        prod_num: usize,
        children: &[ParseTreeType<'t>],
    ) -> Result<()> {
        match prod_num {
            0 => self.type_down(&children[0], &children[1], &children[2]),
            1 => self.type_down_list0_0(&children[0], &children[1]),
            2 => self.type_down_list0_1(),
            3 => self.type_down_list_0(&children[0], &children[1]),
            4 => self.type_down_list_1(),
            5 => self.block_0(&children[0]),
            6 => self.block_1(&children[0]),
            7 => self.block_2(&children[0]),
            8 => self.block_3(&children[0]),
            9 => self.new_block(&children[0], &children[1], &children[2]),
            10 => self.new_block_list_0(&children[0], &children[1]),
            11 => self.new_block_list_1(),
            12 => self.string(&children[0], &children[1], &children[2]),
            13 => self.string_content(&children[0]),
            14 => self.mark_block_0(&children[0]),
            15 => self.mark_block_1(&children[0]),
            16 => self.mark_block_2(&children[0]),
            17 => self.mark_block_3(&children[0]),
            18 => self.mark_block_4(&children[0]),
            19 => self.mark_block_5(&children[0]),
            20 => self.heading_sign(&children[0], &children[1]),
            21 => self.heading_sign_list_0(&children[0], &children[1]),
            22 => self.heading_sign_list_1(),
            23 => self.heading(&children[0], &children[1]),
            24 => self.paragraph(&children[0], &children[1]),
            25 => self.paragraph_opt_0(&children[0]),
            26 => self.paragraph_opt_1(),
            27 => self.list(&children[0], &children[1], &children[2]),
            28 => self.list_opt_0(&children[0]),
            29 => self.list_opt_1(),
            30 => self.ordered_list(&children[0], &children[1], &children[2]),
            31 => self.ordered_list_opt_0(&children[0]),
            32 => self.ordered_list_opt_1(),
            33 => self.table(&children[0], &children[1], &children[2], &children[3]),
            34 => self.table_list_0(&children[0], &children[1], &children[2]),
            35 => self.table_list_1(),
            36 => self.table_opt_0(&children[0]),
            37 => self.table_opt_1(),
            38 => self.blockquote_sign(&children[0], &children[1]),
            39 => self.blockquote_sign_list_0(&children[0], &children[1]),
            40 => self.blockquote_sign_list_1(),
            41 => self.blockquote(&children[0], &children[1], &children[2]),
            42 => self.blockquote_opt_0(&children[0]),
            43 => self.blockquote_opt_1(),
            44 => self.label(&children[0], &children[1]),
            45 => self.line(&children[0], &children[1], &children[2]),
            46 => self.line_opt_0(&children[0]),
            47 => self.line_opt_1(),
            48 => self.elements(&children[0], &children[1]),
            49 => self.elements_list_0(&children[0], &children[1]),
            50 => self.elements_list_1(),
            51 => self.element_0(&children[0]),
            52 => self.element_1(&children[0]),
            53 => self.element_2(&children[0]),
            54 => self.element_3(&children[0]),
            55 => self.element_4(&children[0]),
            56 => self.element_5(&children[0]),
            57 => self.element_6(&children[0]),
            58 => self.element_7(&children[0], &children[1], &children[2]),
            59 => self.element_list_0(&children[0], &children[1]),
            60 => self.element_list_1(),
            61 => self.link_content(&children[0]),
            62 => self.link(&children[0], &children[1], &children[2]),
            63 => self.link_group_0(&children[0]),
            64 => self.link_group_1(&children[0], &children[1], &children[2]),
            65 => self.link_group_list_0(&children[0], &children[1]),
            66 => self.link_group_list_1(),
            67 => self.escape(&children[0], &children[1]),
            68 => self.monospace(&children[0], &children[1], &children[2]),
            69 => self.monospace_list_0(&children[0], &children[1]),
            70 => self.monospace_list_1(),
            71 => self.monospace_content(&children[0]),
            72 => self.subscript(&children[0], &children[1]),
            73 => self.supscript(&children[0], &children[1]),
            74 => self.format_0(&children[0]),
            75 => self.format_1(&children[0]),
            76 => self.format_2(&children[0]),
            77 => self.format_3(&children[0]),
            78 => self.quote(&children[0], &children[1], &children[2]),
            79 => self.quote_list_0(&children[0], &children[1]),
            80 => self.quote_list_group_0(&children[0]),
            81 => self.quote_list_group_1(&children[0]),
            82 => self.quote_list_group_2(&children[0]),
            83 => self.quote_list_group_3(&children[0]),
            84 => self.quote_list_1(),
            85 => self.strikethrough(&children[0], &children[1], &children[2]),
            86 => self.strikethrough_list_0(&children[0], &children[1]),
            87 => self.strikethrough_list_group_0(&children[0]),
            88 => self.strikethrough_list_group_1(&children[0]),
            89 => self.strikethrough_list_group_2(&children[0]),
            90 => self.strikethrough_list_1(),
            91 => self.strong(&children[0], &children[1], &children[2]),
            92 => self.strong_list_0(&children[0], &children[1]),
            93 => self.strong_list_group_0(&children[0]),
            94 => self.strong_list_group_1(&children[0]),
            95 => self.strong_list_1(),
            96 => self.emphasis(&children[0], &children[1], &children[2]),
            97 => self.emphasis_list_0(&children[0], &children[1]),
            98 => self.emphasis_list_1(),
            99 => self.raw_block(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
            ),
            100 => self.raw_block_opt_0(&children[0]),
            101 => self.raw_block_opt_1(),
            102 => self.raw_text(&children[0]),
            103 => self.code_block(&children[0], &children[1], &children[2]),
            104 => self.expr_0(&children[0]),
            105 => self.expr_1(&children[0]),
            106 => self.expr_2(&children[0]),
            107 => self.expr_3(&children[0]),
            108 => self.expr_4(&children[0]),
            109 => self.list_expr(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
            ),
            110 => self.list_expr_list_0(&children[0], &children[1], &children[2]),
            111 => self.list_expr_list_1(),
            112 => self.control_expr_0(&children[0]),
            113 => self.control_expr_1(&children[0]),
            114 => self.value_expr_0(&children[0]),
            115 => self.value_expr_1(&children[0]),
            116 => self.r#let(&children[0], &children[1], &children[2], &children[3]),
            117 => self.ident_list(&children[0], &children[1]),
            118 => self.ident_list_list_0(&children[0], &children[1], &children[2]),
            119 => self.ident_list_list_1(),
            120 => self.makro(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                &children[6],
            ),
            121 => self.makro_opt_0(&children[0]),
            122 => self.makro_opt_1(),
            123 => self.content(&children[0], &children[1]),
            124 => self.content_tail(&children[0], &children[1]),
            125 => self.content_tail_group_0(&children[0], &children[1]),
            126 => self.content_tail_group_1(&children[0]),
            127 => self.if_else(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
            ),
            128 => self.if_else_group0_0(&children[0]),
            129 => self.if_else_group0_1(&children[0]),
            130 => self.if_else_group0_2(&children[0]),
            131 => self.if_else_group_0(&children[0]),
            132 => self.if_else_group_1(&children[0]),
            133 => self.iterable_0(&children[0]),
            134 => self.iterable_1(&children[0]),
            135 => self.iterable_2(&children[0]),
            136 => self.r#for(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
            ),
            137 => self.for_group_0(&children[0]),
            138 => self.for_group_1(&children[0]),
            139 => self.disjunction(&children[0], &children[1]),
            140 => self.disjunction_list_0(&children[0], &children[1], &children[2]),
            141 => self.disjunction_list_1(),
            142 => self.conjunction(&children[0], &children[1]),
            143 => self.conjunction_list_0(&children[0], &children[1], &children[2]),
            144 => self.conjunction_list_1(),
            145 => self.negation(&children[0], &children[1]),
            146 => self.negation_opt_0(&children[0]),
            147 => self.negation_opt_1(),
            148 => self.relation_0(&children[0], &children[1]),
            149 => self.relation_opt_0(&children[0], &children[1]),
            150 => self.relation_opt_group_0(&children[0]),
            151 => self.relation_opt_group_1(&children[0]),
            152 => self.relation_opt_group_2(&children[0]),
            153 => self.relation_opt_group_3(&children[0]),
            154 => self.relation_opt_group_4(&children[0]),
            155 => self.relation_opt_group_5(&children[0]),
            156 => self.relation_opt_1(),
            157 => self.summation(&children[0], &children[1]),
            158 => self.summation_list_0(&children[0], &children[1], &children[2]),
            159 => self.summation_list_group_0(&children[0]),
            160 => self.summation_list_group_1(&children[0]),
            161 => self.summation_list_1(),
            162 => self.multiplication(&children[0], &children[1]),
            163 => self.multiplication_list_0(&children[0], &children[1], &children[2]),
            164 => self.multiplication_list_group_0(&children[0]),
            165 => self.multiplication_list_group_1(&children[0]),
            166 => self.multiplication_list_group_2(&children[0]),
            167 => self.multiplication_list_1(),
            168 => self.factor(&children[0]),
            169 => self.primary_0(&children[0], &children[1], &children[2]),
            170 => self.primary_1(&children[0]),
            171 => self.value_0(&children[0]),
            172 => self.value_1(&children[0]),
            173 => self.value_2(&children[0]),
            174 => self.value_3(&children[0]),
            175 => self.arg_0(&children[0], &children[1]),
            176 => self.arg_1(&children[0]),
            177 => self.arg_2(&children[0]),
            178 => self.arg_3(&children[0]),
            179 => self.arg_opt_0(&children[0]),
            180 => self.arg_opt_group_0(&children[0], &children[1]),
            181 => self.arg_opt_group_1(&children[0]),
            182 => self.arg_opt_1(),
            183 => self.args(&children[0], &children[1]),
            184 => self.args_list_0(&children[0], &children[1], &children[2]),
            185 => self.args_list_1(),
            186 => self.access(&children[0], &children[1]),
            187 => self.access_opt_0(&children[0]),
            188 => self.access_opt_1(),
            189 => self.call(&children[0], &children[1], &children[2]),
            190 => self.call_group_0(&children[0]),
            191 => self.call_group_1(&children[0], &children[1]),
            192 => self.call_opt_0(&children[0]),
            193 => self.call_opt_1(),
            194 => self.kw_makro(&children[0]),
            195 => self.kw_for(&children[0]),
            196 => self.kw_in(&children[0]),
            197 => self.kw_if(&children[0]),
            198 => self.kw_else(&children[0]),
            199 => self.kw_let(&children[0]),
            200 => self.kw_true(&children[0]),
            201 => self.kw_false(&children[0]),
            202 => self.bool_0(&children[0]),
            203 => self.bool_1(&children[0]),
            204 => self.number(&children[0], &children[1]),
            205 => self.number_opt_0(&children[0], &children[1]),
            206 => self.number_opt_1(),
            207 => self.math_block(&children[0], &children[1], &children[2]),
            208 => self.formular(&children[0]),
            209 => self.symbol_0(&children[0]),
            210 => self.symbol_1(&children[0]),
            211 => self.symbol_2(&children[0]),
            212 => self.symbol_3(&children[0]),
            213 => self.alpha_0(&children[0]),
            214 => self.alpha_1(&children[0]),
            215 => self.beta_0(&children[0]),
            216 => self.beta_1(&children[0]),
            217 => self.gamma_0(&children[0]),
            218 => self.gamma_1(&children[0]),
            219 => self.delta_0(&children[0]),
            220 => self.delta_1(&children[0]),
            221 => self.epsilon_0(&children[0]),
            222 => self.epsilon_1(&children[0]),
            223 => self.zeta_0(&children[0]),
            224 => self.zeta_1(&children[0]),
            225 => self.eta_0(&children[0]),
            226 => self.eta_1(&children[0]),
            227 => self.theta_0(&children[0]),
            228 => self.theta_1(&children[0]),
            229 => self.iota_0(&children[0]),
            230 => self.iota_1(&children[0]),
            231 => self.kappa_0(&children[0]),
            232 => self.kappa_1(&children[0]),
            233 => self.lambda_0(&children[0]),
            234 => self.lambda_1(&children[0]),
            235 => self.mu_0(&children[0]),
            236 => self.mu_1(&children[0]),
            237 => self.nu_0(&children[0]),
            238 => self.nu_1(&children[0]),
            239 => self.xi_0(&children[0]),
            240 => self.xi_1(&children[0]),
            241 => self.omicron_0(&children[0]),
            242 => self.omicron_1(&children[0]),
            243 => self.pi_0(&children[0]),
            244 => self.pi_1(&children[0]),
            245 => self.pi_2(&children[0]),
            246 => self.rho_0(&children[0]),
            247 => self.rho_1(&children[0]),
            248 => self.sigma_0(&children[0]),
            249 => self.sigma_1(&children[0]),
            250 => self.sigma_2(&children[0]),
            251 => self.tau_0(&children[0]),
            252 => self.tau_1(&children[0]),
            253 => self.upsilon_0(&children[0]),
            254 => self.upsilon_1(&children[0]),
            255 => self.phi_0(&children[0]),
            256 => self.phi_1(&children[0]),
            257 => self.chi_0(&children[0]),
            258 => self.chi_1(&children[0]),
            259 => self.psi_0(&children[0]),
            260 => self.psi_1(&children[0]),
            261 => self.omega_0(&children[0]),
            262 => self.omega_1(&children[0]),
            263 => self.greek_0(&children[0]),
            264 => self.greek_1(&children[0]),
            265 => self.greek_2(&children[0]),
            266 => self.greek_3(&children[0]),
            267 => self.greek_4(&children[0]),
            268 => self.greek_5(&children[0]),
            269 => self.greek_6(&children[0]),
            270 => self.greek_7(&children[0]),
            271 => self.greek_8(&children[0]),
            272 => self.greek_9(&children[0]),
            273 => self.greek_10(&children[0]),
            274 => self.greek_11(&children[0]),
            275 => self.greek_12(&children[0]),
            276 => self.greek_13(&children[0]),
            277 => self.greek_14(&children[0]),
            278 => self.greek_15(&children[0]),
            279 => self.greek_16(&children[0]),
            280 => self.greek_17(&children[0]),
            281 => self.greek_18(&children[0]),
            282 => self.greek_19(&children[0]),
            283 => self.greek_20(&children[0]),
            284 => self.greek_21(&children[0]),
            285 => self.greek_22(&children[0]),
            286 => self.greek_23(&children[0]),
            287 => self.double_struck_0(&children[0]),
            288 => self.double_struck_1(&children[0]),
            289 => self.double_struck_2(&children[0]),
            290 => self.double_struck_3(&children[0]),
            291 => self.double_struck_4(&children[0]),
            292 => self.double_struck_5(&children[0]),
            293 => self.double_struck_6(&children[0]),
            294 => self.double_struck_7(&children[0]),
            295 => self.double_struck_8(&children[0]),
            296 => self.double_struck_9(&children[0]),
            297 => self.double_struck_10(&children[0]),
            298 => self.double_struck_11(&children[0]),
            299 => self.double_struck_12(&children[0]),
            300 => self.double_struck_13(&children[0]),
            301 => self.double_struck_14(&children[0]),
            302 => self.double_struck_15(&children[0]),
            303 => self.double_struck_16(&children[0]),
            304 => self.double_struck_17(&children[0]),
            305 => self.double_struck_18(&children[0]),
            306 => self.double_struck_19(&children[0]),
            307 => self.double_struck_20(&children[0]),
            308 => self.double_struck_21(&children[0]),
            309 => self.double_struck_22(&children[0]),
            310 => self.double_struck_23(&children[0]),
            311 => self.double_struck_24(&children[0]),
            312 => self.double_struck_25(&children[0]),
            313 => self.not(&children[0]),
            314 => self.and(&children[0]),
            315 => self.or(&children[0]),
            316 => self.for_all(&children[0]),
            317 => self.exists(&children[0]),
            318 => self.left(&children[0]),
            319 => self.right(&children[0]),
            320 => self.top(&children[0]),
            321 => self.bot(&children[0]),
            322 => self.tack(&children[0], &children[1]),
            323 => self.tack_opt_0(&children[0], &children[1]),
            324 => self.tack_opt_group_0(&children[0]),
            325 => self.tack_opt_group_1(&children[0]),
            326 => self.tack_opt_group_2(&children[0]),
            327 => self.tack_opt_group_3(&children[0]),
            328 => self.tack_opt_1(),
            329 => self.logical_0(&children[0]),
            330 => self.logical_1(&children[0]),
            331 => self.logical_2(&children[0]),
            332 => self.logical_3(&children[0]),
            333 => self.logical_4(&children[0]),
            334 => self.logical_5(&children[0]),
            335 => self.equal(&children[0], &children[1]),
            336 => self.equal_opt_0(&children[0], &children[1]),
            337 => self.equal_opt_1(),
            338 => self.identical(&children[0], &children[1]),
            339 => self.identical_opt_0(&children[0], &children[1]),
            340 => self.identical_opt_1(),
            341 => self.approx(&children[0], &children[1]),
            342 => self.approx_opt_0(&children[0], &children[1]),
            343 => self.approx_opt_1(),
            344 => self.prop(&children[0]),
            345 => self.less(&children[0], &children[1]),
            346 => self.less_opt_0(&children[0], &children[1]),
            347 => self.less_opt_1(),
            348 => self.greater(&children[0], &children[1]),
            349 => self.greater_opt_0(&children[0], &children[1]),
            350 => self.greater_opt_1(),
            351 => self.r#in(&children[0], &children[1]),
            352 => self.in_opt_0(&children[0], &children[1]),
            353 => self.in_opt_1(),
            354 => self.subset(&children[0], &children[1]),
            355 => self.subset_opt_0(&children[0], &children[1]),
            356 => self.subset_opt_group_0(&children[0]),
            357 => self.subset_opt_group_1(&children[0]),
            358 => self.subset_opt_1(),
            359 => self.supset(&children[0], &children[1]),
            360 => self.supset_opt_0(&children[0], &children[1]),
            361 => self.supset_opt_group_0(&children[0]),
            362 => self.supset_opt_group_1(&children[0]),
            363 => self.supset_opt_1(),
            364 => self.relation_1(&children[0]),
            365 => self.relation_2(&children[0]),
            366 => self.relation_3(&children[0]),
            367 => self.relation_4(&children[0]),
            368 => self.relation_5(&children[0]),
            369 => self.relation_6(&children[0]),
            370 => self.relation_7(&children[0]),
            371 => self.relation_8(&children[0]),
            372 => self.relation_9(&children[0]),
            373 => self.variable(&children[0]),
            374 => self.attach_0(&children[0]),
            375 => self.attach_1(&children[0]),
            376 => self.plus_0(&children[0]),
            377 => self.plus_1(&children[0]),
            378 => self.minus_0(&children[0]),
            379 => self.minus_1(&children[0]),
            380 => self.frac_0(&children[0]),
            381 => self.frac_1(&children[0]),
            382 => self.times_0(&children[0]),
            383 => self.times_1(&children[0]),
            384 => self.operation_0(&children[0]),
            385 => self.operation_1(&children[0]),
            386 => self.operation_2(&children[0]),
            387 => self.operation_3(&children[0]),
            388 => self.operation_4(&children[0]),
            389 => self.operation_5(&children[0]),
            390 => self.operation_6(&children[0]),
            391 => self.equ_double_token(&children[0]),
            392 => self.equ_token(&children[0]),
            393 => self.plus_token(&children[0]),
            394 => self.minus_token(&children[0]),
            395 => self.slash_token(&children[0]),
            396 => self.backslash_token(&children[0]),
            397 => self.asterisk_token(&children[0]),
            398 => self.percent_token(&children[0]),
            399 => self.pipe_double_token(&children[0]),
            400 => self.pipe_token(&children[0]),
            401 => self.underscore_double_token(&children[0]),
            402 => self.underscore_token(&children[0]),
            403 => self.caret_token(&children[0]),
            404 => self.backtick_triple_token(&children[0]),
            405 => self.backtick_token(&children[0]),
            406 => self.tilde_token(&children[0]),
            407 => self.hash_token(&children[0]),
            408 => self.sigil_token(&children[0]),
            409 => self.at_token(&children[0]),
            410 => self.comma_token(&children[0]),
            411 => self.dot_token(&children[0]),
            412 => self.colon_token(&children[0]),
            413 => self.left_paren_token(&children[0]),
            414 => self.right_paren_left_bracket_token(&children[0]),
            415 => self.right_paren_token(&children[0]),
            416 => self.left_brace_token(&children[0]),
            417 => self.right_brace_token(&children[0]),
            418 => self.left_bracket_token(&children[0]),
            419 => self.right_bracket_token(&children[0]),
            420 => self.left_angle_equ_token(&children[0]),
            421 => self.left_angle_token(&children[0]),
            422 => self.right_angle_left_bracket_token(&children[0]),
            423 => self.right_angle_equ_token(&children[0]),
            424 => self.right_angle_token(&children[0]),
            425 => self.exclam_equ_token(&children[0]),
            426 => self.exclam_token(&children[0]),
            427 => self.amper_double_token(&children[0]),
            428 => self.digits_token(&children[0]),
            429 => self.identifier_token(&children[0]),
            430 => self.new_line(&children[0]),
            431 => self.word_token(&children[0]),
            432 => self.double_quote_token(&children[0]),
            _ => Err(ParserError::InternalError(format!(
                "Unhandled production number: {}",
                prod_num
            ))
            .into()),
        }
    }

    fn on_comment_parsed(&mut self, token: Token<'t>) {
        self.user_grammar.on_comment_parsed(token)
    }
}
